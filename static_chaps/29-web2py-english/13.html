<h2>Deployment recipes</h2><p>There are multiple ways to deploy web2py in a production environment. The details depend on the configuration and the services provided by the host.</p><p>In this chapter we consider the following issues:</p><ul><li>Production deployment (Apache, Nginx, Lighttpd, Cherokee)</li><li>Security</li><li>Scalability using Redis and a load balancer.</li><li>Deployment on PythonAnywhere, Heroku, Amazon EC2, and on the Google App Engine platform(GAE<sup>[<a href="/web2py_book/default/reference/29/gae" target="_blank">gae</a>]</sup> )</li></ul><p><div class="inxx">Apache</div> <div class="inxx">CGI</div> <div class="inxx">mod_python</div> <div class="inxx">mod_wsgi</div> <div class="inxx">mod_proxy</div> <div class="inxx">WSGI</div> <div class="inxx">Nginx</div> <div class="inxx">Heroku</div> <div class="inxx">PythonAnywhere</div></p><p>web2py comes with an SSL<sup>[<a href="/web2py_book/default/reference/29/ssl" target="_blank">ssl</a>]</sup>  enabled web server, the Rocket wsgiserver<sup>[<a href="/web2py_book/default/reference/29/rocket" target="_blank">rocket</a>]</sup> . While this is a fast web server, it has limited configuration capabilities. For this reason it is best to deploy web2py behind Apache<sup>[<a href="/web2py_book/default/reference/29/apache" target="_blank">apache</a>]</sup> , Nginx<sup>[<a href="/web2py_book/default/reference/29/Nginx" target="_blank">Nginx</a>]</sup> Lighttpd<sup>[<a href="/web2py_book/default/reference/29/lighttpd" target="_blank">lighttpd</a>]</sup> he or Cherokee<sup>[<a href="/web2py_book/default/reference/29/cherokee" target="_blank">cherokee</a>]</sup> . These are free and open-source web servers that are customizable and have been proven to be reliable in high traffic production environments. They can be configured to serve static files directly, deal with HTTPS, and pass control to web2py for dynamic content.</p><p>Until a few years ago, the standard interface for communication between web servers and web applications was the Common Gateway Interface (CGI)<sup>[<a href="/web2py_book/default/reference/29/cgi" target="_blank">cgi</a>]</sup> . The main problem with CGI is that it creates a new process for each HTTP request. If the web application is written in an interpreted language, each HTTP request served by the CGI scripts starts a new instance of the interpreter. This is slow, and it should be avoided in a production environment. Moreover, CGI can only handle simple responses. It cannot handle, for example, file streaming.</p><p>web2py provides a file <code>cgihandler.py</code> to interface to CGI.</p><p>One solution to this problem is to use the mod_python module for Apache. We discuss it here because its use is still very common, though the mod_python project has officially been abandoned by the Apache Software Foundation. mod_python starts one instance of the Python interpreter when Apache starts, and serves each HTTP request in its own thread without having to restart Python each time. This is a better solution than CGI, but it is not an optimal solution, since mod_python uses its own interface for communication between the web server and the web application. In mod_python, all hosted applications run under the same user-id/group-id, which presents security issues.</p><p>web2py provides a file <code>modpythonhandler.py</code> to interface to mod_python.</p><p>In the last few years, the Python community has come together behind a new standard interface for communication between web servers and web applications written in Python. It is called Web Server Gateway Interface (WSGI)<sup>[<a href="/web2py_book/default/reference/29/wsgi-w" target="_blank">wsgi-w</a>]</sup> <sup>[<a href="/web2py_book/default/reference/29/wsgi-o" target="_blank">wsgi-o</a>]</sup> . web2py was built on WSGI, and it provides handlers for using other interfaces when WSGI is not available.</p><p>Apache supports WSGI via the module mod_wsgi<sup>[<a href="/web2py_book/default/reference/29/modwsgi" target="_blank">modwsgi</a>]</sup>  developed by Graham Dumpleton.</p><p>web2py provides a file <code>wsgihandler.py</code> to interface to WSGI.</p><p>Some web hosting services do not support mod_wsgi. In this case, we must use Apache as a proxy and forward all incoming requests to the web2py built-in web server (running for example on localhost:8000).</p><p>In both cases, with mod_wsgi and/or mod_proxy, Apache can be configured to serve static files and deal with SSL encryption directly, taking the burden off web2py.</p><p>Nginx uses uWSGI instead of WSGI, a similar but different protocol which requires its own python adapter.</p><p>The Lighttpd web server does not currently support the WSGI interface, but it does support the FastCGI<sup>[<a href="/web2py_book/default/reference/29/fastcgi" target="_blank">fastcgi</a>]</sup>  interface, which is an improvement over CGI. FastCGI's main aim is to reduce the overhead associated with interfacing the web server and CGI programs, allowing a server to handle more HTTP requests at once.</p><p>According to the Lighttpd web site, "Lighttpd powers several popular Web 2.0 sites such as YouTube and Wikipedia. Its high speed IO-infrastructure allows them to scale several times better with the same hardware than with alternative web-servers". Lighttpd with FastCGI is, in fact, faster than Apache with mod_wsgi.</p><p>web2py provides a file <code>fcgihandler.py</code> to interface to FastCGI.</p><p>web2py also includes a <code>gaehandler.py</code> to interface with the Google App Engine (GAE). On GAE, web applications run "in the cloud". This means that the framework completely abstracts any hardware details. The web application is automatically replicated as many times as necessary to serve all concurrent requests. Replication in this case means more than multiple threads on a single server; it also means multiple processes on different servers. GAE achieves this level of scalability by blocking write access to the file system, and all persistent information must be stored in the Google BigTable datastore or in memcache.</p><p>On non-GAE platforms, scalability is an issue that needs to be addressed, and it may require some tweaks in the web2py applications. The most common way to achieve scalability is by using multiple web servers behind a load-balancer (a simple round robin, or something more sophisticated, receiving heartbeat feedback from the servers).</p><p>Even if there are multiple web servers, there must be one, and only one, database server. By default, web2py uses the file system for storing sessions, error tickets, uploaded files, and the cache. This means that in the default configuration, the corresponding folders have to be shared folders.</p><p><p style="text-align:center"><img src="http://127.0.0.1:8000/web2py_book/default/image/29/en9100.png" alt="image" style="width:300px" /></p></p><p>In the rest of the chapter, we consider various recipes that may provide an improvement over this naive approach, including:</p><ul><li>Store sessions in the database, in cache or do not store sessions at all.</li><li>Store tickets on local filesystem and move them into the database in batches.</li><li>Use memcache instead of cache.ram and cache.disk.</li><li>Store uploaded files in the database instead of the shared filesystem.</li></ul><p>While we recommend following the first three recipes, the fourth recipe may provide an advantage mainly in the case of small files, but may be counterproductive for large files.</p><h3><code>anyserver.py</code></h3><p><div class="inxx">anyserver</div> <div class="inxx">bjoern</div> <div class="inxx">cgi</div> <div class="inxx">cherrypy</div> <div class="inxx">diesel</div> <div class="inxx">eventlet</div> <div class="inxx">fapws</div> <div class="inxx">flup</div> <div class="inxx">gevent</div> <div class="inxx">gunicorn</div> <div class="inxx">mongrel2</div> <div class="inxx">paste</div> <div class="inxx">tornado</div> <div class="inxx">twisted</div> <div class="inxx">wsgiref</div></p><p>Web2py comes with a file called <code>anyserver.py</code> that implements WSGI interfaces to the following popular servers: bjoern, cgi, cherrypy, diesel, eventlet, fapws, flup, gevent, gunicorn, mongrel2, paste, rocket, tornado,  twisted, wsgiref</p><p>You can use any of these servers, for example Tornado, simply by doing:</p><pre><code>python anyserver.py -s tornado -i 127.0.0.1 -p 8000 -l -P</code></pre><p>Here <code>-l</code> is for logging and <code>-P</code> is for the profiler. For information on all the command line options use "-h":</p><pre><code class="code">python anyserver.py -h</code></pre><h3>Linux and Unix</h3><h4>One step production deployment</h4><p>Here are some steps to install apache+python+mod_wsgi+web2py+postgresql from scratch.</p><p>On Ubuntu:</p><pre><code>wget http://web2py.googlecode.com/hg/scripts/setup-web2py-ubuntu.sh
chmod +x setup-web2py-ubuntu.sh
sudo ./setup-web2py-ubuntu.sh</code></pre><p>On Fedora:</p><pre><code>wget http://web2py.googlecode.com/hg/scripts/setup-web2py-fedora.sh
chmod +x setup-web2py-fedora.sh
sudo ./setup-web2py-fedora.sh</code></pre><p>Both of these scripts should run out of the box, but every Linux installation is a bit different, so make sure you check the source code of these scripts before you run them. In the case of Ubuntu, most of what they do is explained below. They do not implement the scalability optimizations discussed below.</p><h4>Apache setup</h4><p>In this section, we use Ubuntu 8.04 Server Edition as the reference platform. The configuration commands are very similar on other Debian-based Linux distribution, but they may differ for Fedora-based systems (which uses <code>yum</code> instead of <code>apt-get</code>).</p><p>First, make sure all the necessary Python and Apache packages are installed by typing the following shell commands:</p><pre><code class="code">sudo apt-get update
sudo apt-get -y upgrade
sudo apt-get -y install openssh-server
sudo apt-get -y install python
sudo apt-get -y install python-dev
sudo apt-get -y install apache2
sudo apt-get -y install libapache2-mod-wsgi
sudo apt-get -y install libapache2-mod-proxy-html</code></pre><p>Then, enable the SSL module, the proxy module, and the WSGI module in Apache:</p><pre><code class="code">sudo ln -s /etc/apache2/mods-available/proxy_http.load            /etc/apache2/mods-enabled/proxy_http.load
sudo a2enmod ssl
sudo a2enmod proxy
sudo a2enmod proxy_http
sudo a2enmod wsgi</code></pre><p>Create the SSL folder, and put the SSL certificates inside it:</p><pre><code class="code">sudo mkdir /etc/apache2/ssl</code></pre><p>You should obtain your SSL certificates from a trusted Certificate Authority such as verisign.com, but, for testing purposes, you can generate your own self-signed certificates following the instructions in ref.<sup>[<a href="/web2py_book/default/reference/29/openssl" target="_blank">openssl</a>]</sup></p><p>Then restart the web server:</p><pre><code class="code">sudo /etc/init.d/apache2 restart</code></pre><p>The Apache configuration file is:</p><pre><code class="code">/etc/apache2/sites-available/default</code></pre><p>The Apache logs are in:</p><pre><code class="code">/var/log/apache2/</code></pre><h4>mod_wsgi</h4><p>Download and unzip web2py source on the machine where you installed the web server above.</p><p>Install web2py under <code>/home/www-data/</code>, for example, and give ownership to user www-data and group www-data. These steps can be performed with the following shell commands:</p><pre><code class="code">cd /home/www-data/
sudo wget http://web2py.com/examples/static/web2py_src.zip
sudo unzip web2py_src.zip
sudo chown -R www-data:www-data /home/www-data/web2py</code></pre><p>To set up web2py with mod_wsgi, create a new Apache configuration file:</p><pre><code class="code">/etc/apache2/sites-available/web2py</code></pre><p>and include the following code:</p><pre><code class="code">&lt;VirtualHost *:80&gt;
  ServerName web2py.example.com
  WSGIDaemonProcess web2py user=www-data group=www-data display-name=%{GROUP}
  WSGIProcessGroup web2py
  WSGIScriptAlias / /home/www-data/web2py/wsgihandler.py

  &lt;Directory /home/www-data/web2py&gt;
    AllowOverride None
    Order Allow,Deny
    Deny from all
    &lt;Files wsgihandler.py&gt;
      Allow from all
    &lt;/Files&gt;
  &lt;/Directory&gt;

  AliasMatch ^/([^/]+)/static/(.*)            /users/www-data/web2py/applications/$1/static/$2
  &lt;Directory /users/www-data/web2py/applications/*/static/&gt;
    Order Allow,Deny
    Allow from all
  &lt;/Directory&gt;

  &lt;Location /admin&gt;
  Deny from all
  &lt;/Location&gt;

  &lt;LocationMatch ^/([^/]+)/appadmin&gt;
  Deny from all
  &lt;/LocationMatch&gt;

  CustomLog /private/var/log/apache2/access.log common
  ErrorLog /private/var/log/apache2/error.log
&lt;/VirtualHost&gt;</code></pre><p>When you restart Apache, it should pass all the requests to web2py without going through the Rocket wsgiserver.</p><p>Here are some explanations:</p><pre><code class="code">WSGIDaemonProcess web2py user=www-data group=www-data display-name=%{GROUP}</code></pre><p>defines a daemon process group in context of "web2py.example.com". By defining this inside of the virtual host, only this virtual host can access this using WSGIProcessGroup, including any virtual host with the same server name but on a different port. The "user" and "group" options should be set to the user who has write access to the directory where web2py was setup. You do not need to set "user" and "group" if you made the web2py installation directory writable by the default user that Apache runs as. The "display-name" option makes the process name appears in <code>ps</code> output as "(wsgi-web2py)" instead of as name of Apache web server executable. As no "processes" or "threads" options are specified, the daemon process group will have a single process with 15 threads running within that process. This is usually more than adequate for most sites and should be left as is. If overriding it, do not use "processes=1" as doing so will disable any in-browser WSGI debugging tools that check the "wsgi.multiprocess" flag. This is because any use of the "processes" option will cause that flag to be set to true, even a single process, and such tools expect that it be set to false. Note: if your application code or third party extension module is not thread safe, use options "processes=5 threads=1" instead. This will create five processes in the daemon process group where each process is single threaded. You might consider using "maximum-requests=1000" if your application leaks Python objects because it is unable to garbage collect properly.</p><pre><code class="code">WSGIProcessGroup web2py</code></pre><p>delegates running of all WSGI applications to the daemon process group that was configured using the WSGIDaemonProcess directive.</p><pre><code class="code">WSGIScriptAlias / /users/www-data/web2py/wsgihandler.py</code></pre><p>mounts the web2py application. In this case it is mounted at the root of the web site.</p><pre><code class="code">&lt;Directory /users/www-data/web2py&gt;
  ...
&lt;/Directory&gt;</code></pre><p>gives Apache permission to access the WSGI script file.</p><pre><code class="code">&lt;Directory /users/www-data/web2py/applications/*/static/&gt;
  Order Allow,Deny
  Allow from all
&lt;/Directory&gt;</code></pre><p>Instructs Apache to bypass web2py when searching static files.</p><pre><code class="code">&lt;Location /admin&gt;
  Deny from all
&lt;/Location&gt;</code></pre><p>and</p><pre><code class="code">&lt;LocationMatch ^/([^/]+)/appadmin&gt;
  Deny from all
&lt;/LocationMatch&gt;</code></pre><p>blocks public access to <strong>admin</strong> and <strong>appadmin</strong></p><p>Normally we would just allow permission to the whole directory where the WSGI script file is located, but web2py places the WSGI script file in a directory which contains other source code, including the admin interface password. Opening up the whole directory would cause security issues, because technically Apache would be given permission to serve all the files up to any user who traversed to that directory via a mapped URL. To avoid security problems, explicitly deny access to the contents of the directory, except for the WSGI script file, and prohibit a user from doing any overrides from a .htaccess file to be extra safe.</p><p>You can find a completed, commented, Apache wsgi configuration file in:</p><pre><code class="code">scripts/web2py-wsgi.conf</code></pre><p>This section was created with help from Graham Dumpleton, developer of mod_wsgi.</p><h4>Setting password</h4><p>In production it may be necessary to set the admin password programmatically. This can be done from the Bash shell with</p><pre><code class="code">sudo -u www-data python -c "from gluon.main import save_password; save_password(raw_input('admin password: '),443)"</code></pre><h4>mod_wsgi and SSL</h4><p>To force some applications (for example <strong>admin</strong> and <strong>appadmin</strong>) to go over HTTPS, store the SSL certificate and key files:</p><pre><code class="code">/etc/apache2/ssl/server.crt
/etc/apache2/ssl/server.key</code></pre><p>and edit the Apache configuration file <code>web2py.conf</code> and append:</p><pre><code class="code">&lt;VirtualHost *:443&gt;
  ServerName web2py.example.com
  SSLEngine on
  SSLCertificateFile /etc/apache2/ssl/server.crt
  SSLCertificateKeyFile /etc/apache2/ssl/server.key

  WSGIProcessGroup web2py

  WSGIScriptAlias / /users/www-data/web2py/wsgihandler.py

  &lt;Directory /users/www-data/web2py&gt;
    AllowOverride None
    Order Allow,Deny
    Deny from all
    &lt;Files wsgihandler.py&gt;
      Allow from all
    &lt;/Files&gt;
  &lt;/Directory&gt;

  AliasMatch ^/([^/]+)/static/(.*)         /users/www-data/web2py/applications/$1/static/$2

  &lt;Directory /users/www-data/web2py/applications/*/static/&gt;
    Order Allow,Deny
    Allow from all
  &lt;/Directory&gt;

  CustomLog /private/var/log/apache2/access.log common
  ErrorLog /private/var/log/apache2/error.log

&lt;/VirtualHost&gt;</code></pre><p>Restart Apache and you should be able to access:</p><pre><code class="code">https://www.example.com/admin
https://www.example.com/examples/appadmin
http://www.example.com/examples</code></pre><p>but not:</p><pre><code class="code">http://www.example.com/admin
http://www.example.com/examples/appadmin</code></pre><h4>mod_proxy</h4><p>Some Unix/Linux distributions can run Apache, but do not support mod_wsgi. In this case, the simplest solution is to run Apache as a proxy and have Apache deal with static files only.</p><p>Here is a minimalist Apache configuration:</p><pre><code class="code">NameVirtualHost *:80
#### deal with requests on port 80
&lt;VirtualHost *:80&gt;
   Alias / /users/www-data/web2py/applications
   ### serve static files directly
   &lt;LocationMatch "^/welcome/static/.*"&gt;
    Order Allow, Deny
    Allow from all
   &lt;/LocationMatch&gt;
   ### proxy all the other requests
   &lt;Location "/welcome"&gt;
     Order deny,allow
     Allow from all
     ProxyRequests off
     ProxyPass http://localhost:8000/welcome
     ProxyPassReverse http://localhost:8000/
     ProxyHTMLURLMap http://127.0.0.1:8000/welcome/ /welcome
   &lt;/Location&gt;
   LogFormat "%h %l %u %t "%r" %&gt;s %b" common
   CustomLog /var/log/apache2/access.log common
&lt;/VirtualHost&gt;</code></pre><p>The above script exposes only the "welcome" application. To expose other applications, you need to add the corresponding &lt;Location&gt;...&lt;/Location&gt; with the same syntax as done for the "welcome" app.</p><p>The script assumes there is a web2py server running on port 8000. Before restarting Apache, make sure this is the case:</p><pre><code class="code">nohup python web2py.py -a '&lt;recycle&gt;' -i 127.0.0.1 -p 8000 &amp;</code></pre><p>You can specify a password with the <code>-a</code> option or use the "&lt;recycle&gt;" parameter instead of a password. In the latter case, the previously stored password is reused and the password is not stored in the shell history.</p><p>You can also use the parameter "&lt;ask&gt;", to be prompted for a password.</p><p>The <code>nohup</code> commands makes sure the server does not die when you close the shell. <code>nohup</code> logs all output into <code>nohup.out</code>.</p><p>To force admin and appadmin over HTTPS use the following Apache configuration file instead:</p><pre><code class="code">NameVirtualHost *:80
NameVirtualHost *:443
#### deal with requests on port 80
&lt;VirtualHost *:80&gt;
   Alias / /users/www-data/web2py/applications
   ### admin requires SSL
   &lt;LocationMatch "^/admin"&gt;
     SSLRequireSSL
   &lt;/LocationMatch&gt;
   ### appadmin requires SSL
   &lt;LocationMatch "^/welcome/appadmin/.*"&gt;
     SSLRequireSSL
   &lt;/LocationMatch&gt;
   ### serve static files directly
   &lt;LocationMatch "^/welcome/static/.*"&gt;
     Order Allow,Deny
     Allow from all
   &lt;/LocationMatch&gt;
   ### proxy all the other requests
   &lt;Location "/welcome"&gt;
     Order deny,allow
     Allow from all
     ProxyPass http://localhost:8000/welcome
     ProxyPassReverse http://localhost:8000/
   &lt;/Location&gt;
   LogFormat "%h %l %u %t "%r" %&gt;s %b" common
   CustomLog /var/log/apache2/access.log common
&lt;/VirtualHost&gt;
&lt;VirtualHost *:443&gt;
   SSLEngine On
   SSLCertificateFile /etc/apache2/ssl/server.crt
   SSLCertificateKeyFile /etc/apache2/ssl/server.key
   &lt;Location "/"&gt;
     Order deny,allow
     Allow from all
     ProxyPass http://localhost:8000/
     ProxyPassReverse http://localhost:8000/
   &lt;/Location&gt;
   LogFormat "%h %l %u %t "%r" %&gt;s %b" common
   CustomLog /var/log/apache2/access.log common
&lt;/VirtualHost&gt;</code></pre><blockquote>The administrative interface must be disabled when web2py runs on a shared host with mod_proxy, or it will be exposed to other users.</blockquote><h4>Start as Linux daemon</h4><p>Unless you are using mod_wsgi, you should setup the web2py server so that it can be started/stopped/restarted as any other Linux daemon, and so it can start automatically at the computer boot stage.</p><p>The process to set this up is specific to various Linux/Unix distributions.</p><p>In the web2py folder, there are two scripts which can be used for this purpose:</p><pre><code class="code">scripts/web2py.ubuntu.sh
scripts/web2py.fedora.sh</code></pre><p>On Ubuntu, or other Debian-based Linux distribution, edit "web2py.ubuntu.sh" and replace the "/usr/lib/web2py" path with the path of your web2py installation, then type the following shell commands to move the file into the proper folder, register it as a startup service, and start it:</p><pre><code class="code">sudo cp scripts/web2py.ubuntu.sh /etc/init.d/web2py
sudo update-rc.d web2py defaults
sudo /etc/init.d/web2py start</code></pre><p>On Fedora, or any other distributions based on Fedora, edit "web2py.fedora.sh" and replace the "/usr/lib/web2py" path with the path of your web2py installation, then type the following shell commands to move the file into the proper folder, register it as a startup service and start it:</p><pre><code class="code">sudo cp scripts/web2py.fedora.sh /etc/rc.d/init.d/web2pyd
sudo chkconfig --add web2pyd
sudo service web2py start</code></pre><h4>Nginx</h4><p>Nginx is a free, open-source web server that has rapidly been gaining popularity for its amazing performance.</p><p>Unlike traditional servers, Nginx does not use threads. Instead it uses an ansynchronous/event-driven architecture to handle concurrency. This architecture results in a small and predictable memory usage, even under heavy load.</p><p>Nginx is more than an HTTP server and reverse proxy, it is also an IMAP/POP3 proxy server.</p><p>Nginx is easy to configure and its configuration files and simpler and more compact than the corresponding Apache ones.</p><p>Nginx does not support WSGI but provides native support for the uWSGI <sup>[<a href="/web2py_book/default/reference/29/uwsgi" target="_blank">uwsgi</a>]</sup> protocol.<div class="inxx">uwsgi</div></p><p>On Ubuntu you can install Nginx with:</p><pre><code class="code">apt-get -y install nginx-full</code></pre><p>Then you will need to create a configuration file such as the following:</p><pre><code class="code"># file /etc/nginx/sites-available/web2py
server {
        listen          80;
        server_name     $hostname;
        #to enable correct use of response.static_version
        #location ~* /(\w+)/static(?:/_[\d]+.[\d]+.[\d]+)?/(.*)$ {
        #    alias /home/www-data/web2py/applications/$1/static/$2;
        #    expires max;
        #}
        location ~* /(\w+)/static/ {
            root /home/www-data/web2py/applications/;
            #remove next comment on production
            #expires max;
        }
        location / {
            #uwsgi_pass      127.0.0.1:9001;
            uwsgi_pass      unix:///tmp/web2py.socket;
            include         uwsgi_params;
            uwsgi_param     UWSGI_SCHEME $scheme;
            uwsgi_param     SERVER_SOFTWARE    nginx/$nginx_version;
        }
}
server {
        listen 443 default_server ssl;
        server_name     $hostname;
        ssl_certificate         /etc/nginx/ssl/web2py.crt;
        ssl_certificate_key     /etc/nginx/ssl/web2py.key;
        ssl_prefer_server_ciphers on;
        ssl_session_cache shared:SSL:10m;
        ssl_session_timeout 10m;
        ssl_ciphers ECDHE-RSA-AES256-SHA:DHE-RSA-AES256-SHA:DHE-DSS-AES256-SHA:DHE-RSA-AES128-SHA:DHE-DSS-AES128-SHA;
        ssl_protocols SSLv3 TLSv1;
        keepalive_timeout    70;
        location / {
            #uwsgi_pass      127.0.0.1:9001;
            uwsgi_pass      unix:///tmp/web2py.socket;
            include         uwsgi_params;
            uwsgi_param     UWSGI_SCHEME $scheme;
            uwsgi_param     SERVER_SOFTWARE    nginx/$nginx_version;
        }
 
}</code></pre><p>You will need to symlink the file and remove the default</p><pre><code class="code">ln -s /etc/nginx/sites-available/web2py /etc/nginx/sites-enabled/web2py
rm /etc/nginx/sites-enabled/default</code></pre><p>You may also need to create the ssl folder for certificates and put certificates in there:</p><pre><code class="code">mkdir /etc/nginx/ssl
cp web2py.key /etc/nginx/ssl
cp web2py.crt /etc/nginx/ssl</code></pre><p>You then need to install and setup uWSGI</p><pre><code class="code">sudo mkdir /etc/uwsgi
sudo mkdir /var/log/uwsgi</code></pre><p>And create a configuration file "/etc/uwsgi/web2py.xml":</p><pre><code class="code">&lt;uwsgi&gt;
    &lt;socket&gt;/tmp/web2py.socket&lt;/socket&gt;
    &lt;pythonpath&gt;/home/www-data/web2py/&lt;/pythonpath&gt;
    &lt;mount&gt;/=wsgihandler:application&lt;/mount&gt;
    &lt;master/&gt;
    &lt;processes&gt;4&lt;/processes&gt;
    &lt;harakiri&gt;60&lt;/harakiri&gt;
    &lt;reload-mercy&gt;8&lt;/reload-mercy&gt;
    &lt;cpu-affinity&gt;1&lt;/cpu-affinity&gt;
    &lt;stats&gt;/tmp/stats.socket&lt;/stats&gt;
    &lt;max-requests&gt;2000&lt;/max-requests&gt;
    &lt;limit-as&gt;512&lt;/limit-as&gt;
    &lt;reload-on-as&gt;256&lt;/reload-on-as&gt;
    &lt;reload-on-rss&gt;192&lt;/reload-on-rss&gt;
    &lt;uid&gt;www-data&lt;/uid&gt;
    &lt;gid&gt;www-data&lt;/gid&gt;
    &lt;no-orphans/&gt;
&lt;/uwsgi&gt;</code></pre><p>This file assumes web2py is installed under "/home/www-data/web2py", as in the Apache case.</p><p>You also need to edit a second configuration file "/etc/init/uwsgi-emperor.conf":</p><pre><code class="code"># Emperor uWSGI script 
description "uWSGI Emperor"
start on runlevel [2345]
stop on runlevel [06]
respawn
exec uwsgi --master --die-on-term --emperor /etc/uwsgi --logto /var/log/uwsgi/uwsgi.log</code></pre><p>Finally restart everything:</p><pre><code class="code">start uwsgi-emperor
/etc/init.d/nginx restart </code></pre><p>You can reload uwsgi with</p><pre><code class="code">restart uwsgi-emperor</code></pre><p>You can stop it with</p><pre><code class="code">stop uwsgi-emperor</code></pre><p>You can reload web2py only (without restarting uwsgi) with</p><pre><code class="code">touch /etc/uwsgi/web2py.xml</code></pre><p>All these steps are performed automatically by the provided scripts:</p><pre><code class="code">scripts/setup-web2py-nginx-uwsgi-on-centos.sh
scripts/setup-web2py-nginx-uwsgi-ubuntu.sh</code></pre><h4>Lighttpd</h4><p><div class="inxx">Lighttpd</div> <div class="inxx">FastCGI</div> <div class="inxx">fcgihandler</div></p><p>You can install Lighttpd on a Ubuntu or other Debian-based Linux distribution with the following shell command:</p><pre><code class="code">apt-get -y install lighttpd</code></pre><p>Once installed, edit <code>/etc/rc.local</code> and create a fcgi web2py background process</p><pre><code class="code">cd /var/www/web2py &amp;&amp; sudo -u www-data nohup python fcgihandler.py &amp;</code></pre><p>Then, you need to edit the Lighttpd configuration file</p><pre><code class="code">/etc/lighttpd/lighttpd.conf</code></pre><p>so that it can find the socket created by the above process. In the config file, write something like:</p><pre><code class="code">server.modules              = (
        "mod_access",
        "mod_alias",
        "mod_compress",
        "mod_rewrite",
        "mod_fastcgi",
        "mod_redirect",
        "mod_accesslog",
        "mod_status",
)

server.port = 80
server.bind = "0.0.0.0"
server.event-handler = "freebsd-kqueue"
server.error-handler-404 = "/test.fcgi"
server.document-root = "/users/www-data/web2py/"
server.errorlog      = "/tmp/error.log"

fastcgi.server = (
  "/handler_web2py.fcgi" =&gt; (
      "handler_web2py" =&gt; ( #name for logs
         "check-local" =&gt; "disable",
         "socket" =&gt; "/tmp/fcgi.sock"
      )
   ),
)

$HTTP["host"] = "(^|.)example.com$" {
 server.document-root="/var/www/web2py"
    url.rewrite-once = (
      "^(/.+?/static/.+)$" =&gt; "/applications$1",
      "(^|/.*)$" =&gt; "/handler_web2py.fcgi$1",
    )
}</code></pre><p>Now check for syntax errors:</p><pre><code class="code">lighttpd -t -f /etc/lighttpd/lighttpd.conf</code></pre><p>and (re)start the web server with:</p><pre><code class="code">/etc/init.d/lighttpd restart</code></pre><p>Notice that FastCGI binds the web2py server to a Unix socket, not to an IP socket:</p><pre><code class="code">/tmp/fcgi.sock</code></pre><p>This is where Lighttpd forwards the HTTP requests to and receives responses from. Unix sockets are lighter than Internet sockets, and this is one of the reasons Lighttpd+FastCGI+web2py is fast. As in the case of Apache, it is possible to setup Lighttpd to deal with static files directly, and to force some applications over HTTPS. Refer to the Lighttpd documentation for details.</p><p>Examples in this section were taken from John Heenan's post in web2pyslices.</p><blockquote>The administrative interface must be disabled when web2py runs on a shared host with FastCGI, or it will be exposed to the other users.</blockquote><h4>Shared hosting with mod_python</h4><p>There are times, specifically on shared hosts, when one does not have the permission to configure the Apache config files directly. At the time of writing most of these hosts still run mod_python even if it is not maintained any more in favor of mod_wsgi.</p><p>You can still run web2py. Here we show an example of how to set it up.</p><p>Place contents of web2py into the "htdocs" folder.</p><p>In the web2py folder, create a file "web2py_modpython.py" file with the following contents:</p><pre><code class="code">from mod_python import apache
import modpythonhandler

def handler(req):
    req.subprocess_env['PATH_INFO'] = req.subprocess_env['SCRIPT_URL']
    return modpythonhandler.handler(req)</code></pre><p>Create/update the file ".htaccess" with the following contents:</p><pre><code class="code">SetHandler python-program
PythonHandler web2py_modpython
#PythonDebug On</code></pre><p>This example was provided by Niktar.</p><h4>Cherokee with FastCGI</h4><p><div class="inxx">Cherokee</div> <div class="inxx">FastCGI</div> Cherokee is a very fast web server and, like web2py, it provides an AJAX-enabled web-based interface for its configuration. Its web interface is written in Python. In addition, there is no restart required for most of the changes.</p><p>Here are the steps required to setup web2py with Cherokee:</p><p>Download Cherokee<sup>[<a href="/web2py_book/default/reference/29/cherokee" target="_blank">cherokee</a>]</sup></p><p>Untar, build, and install:</p><pre><code class="code">tar -xzf cherokee-0.9.4.tar.gz
cd cherokee-0.9.4
./configure --enable-fcgi &amp;&amp; make
make install</code></pre><p>Start web2py normally at least once to make sure it creates the "applications" folder.</p><p>Write a shell script named "startweb2py.sh" with the following code:</p><pre><code class="code">#!/bin/bash
cd /var/web2py
python /var/web2py/fcgihandler.py &amp;</code></pre><p>and give the script execute privileges and run it.  This will start web2py under FastCGI handler.</p><p>Start Cherokee and cherokee-admin:</p><pre><code class="code">sudo nohup cherokee &amp;
sudo nohup cherokee-admin &amp;</code></pre><p>By default, cherokee-admin only listens at local interface on port 9090. This is not a problem if you have full, physical access on that machine. If this is not the case, you can force it to bind to an IP address and port by using the following options:</p><pre><code class="code">-b,  --bind[=IP]
-p,  --port=NUM</code></pre><p>or do an SSH port-forward (more secure, recommended):</p><pre><code class="code">ssh -L 9090:localhost:9090 remotehost</code></pre><p>Open "http://localhost:9090" in your browser.  If everything is ok, you will get cherokee-admin.</p><p>In cherokee-admin web interface, click "info sources".  Choose "Local Interpreter". Write in the following code, then click "Add New".</p><pre><code class="code">Nick: web2py
Connection: /tmp/fcgi.sock
Interpreter: /var/web2py/startweb2py.sh</code></pre><p>Finally, perform the following remaining steps:</p><ul><li>Click "Virtual Servers", then click "Default".</li><li>Click "Behavior", then, under that, click "default".</li><li>Choose "FastCGI" instead of "List and Send" from the list box.</li><li>At the bottom, select "web2py" as "Application Server"</li><li>Put a check in all the checkboxes (you can leave Allow-x-sendfile). If there is a warning displayed, disable and enable one of the checkboxes. (It will automatically re-submit the application server parameter. Sometimes it doesn't, which is a bug).</li><li>Point your browser to "http://yoursite", and "Welcome to web2py" will appear.</li></ul><h4>Postgresql</h4><p>PostgreSQL is a free and open source database which is used in demanding production environments, for example, to store the .org domain name database, and has been proven to scale well into hundreds of terabytes of data. It has very fast and solid transaction support, and provides an auto-vacuum feature that frees the administrator from most database maintenance tasks.</p><p>On an Ubuntu or other Debian-based Linux distribution, it is easy to install PostgreSQL and its Python API with:</p><pre><code class="code">sudo apt-get -y install postgresql
sudo apt-get -y install python-psycopg2</code></pre><p>It is wise to run the web server(s) and the database server on different machines. In this case, the machines running the web servers should be connected with a secure internal (physical) network, or should establish SSL tunnels to securely connect with the database server.</p><p>Edit the PostgreSQL configuration file</p><pre><code class="code">sudo nano /etc/postgresql/9.1/main/postgresql.conf</code></pre><p>and make sure it contains these two lines</p><pre><code class="code">...
listen_addresses = 'localhost' 
...
track_counts = on
...
autovacuum = on   # Enable autovacuum subprocess?  'on'
...</code></pre><p>Edit the PostgreSQL client authentication file</p><pre><code class="code">sudo nano /etc/postgresql/9.1/main/pg_hba.conf</code></pre><p>and change the method of those lines to <code>trust</code></p><pre><code class="code">...
# "local" is for Unix domain socket connections only
local   all             all                                     trust
# IPv4 local connections:
host    all             all             127.0.0.1/32            trust
# IPv6 local connections:
host    all             all             ::1/128                 trust
...</code></pre><p>Start the database server with:</p><pre><code class="code">sudo /etc/init.d/postgresql restart</code></pre><p>When restarting the PostgreSQL server, it should notify which port it is running on. Unless you have multiple database servers, it should be 5432.</p><p>The PostgreSQL logs are in:</p><pre><code class="code">/var/log/postgresql/</code></pre><p>Once the database server is up and running, create a user and a database so that web2py applications can use it:</p><pre><code class="code">sudo -u postgres createuser -PE -s myuser
postgresql&gt; createdb -O myuser -E UTF8 mydb
postgresql&gt; echo 'The following databases have been created:'
postgresql&gt; psql -l
postgresql&gt; psql mydb</code></pre><p>The first of the commands will grant superuser-access to the new user, called <code>myuser</code>. It will prompt you for a password.</p><p>Any web2py application can connect to this database with the command:</p><pre><code class="code">db = DAL("postgres://myuser:mypassword@localhost:5432/mydb")</code></pre><p>where <code>mypassword</code> is the password you entered when prompted, and 5432 is the port where the database server is running.</p><p>Normally you use one database for each application, and multiple instances of the same application connect to the same database. It is also possible for different applications to share the same database.</p><p>For database backup details, read the PostgreSQL documentation; specifically the commands <code>pg_dump</code> and <code>pg_restore</code>.</p><h4>Start the scheduler as a Linux service (upstart)</h4><p>To install the scheduler as a permanent daemon on Linux (w/ Upstart), put the following into /etc/init/web2py-scheduler.conf, assuming your web2py instance is installed in &lt;user&gt;'s home directory, running as &lt;user&gt;, with app &lt;myapp&gt;, on network interface eth0.</p><pre><code class="code">description "web2py task scheduler"
start on (local-filesystems and net-device-up IFACE=eth0)
stop on shutdown
respawn limit 8 60 # Give up if restart occurs 8 times in 60 seconds.
exec sudo -u &lt;user&gt; python /home/&lt;user&gt;/web2py/web2py.py -K &lt;myapp&gt;
respawn</code></pre><p>You can then start/stop/restart/check status of the daemon with:</p><pre><code class="code">sudo start web2py-scheduler
sudo stop web2py-scheduler
sudo restart web2py-scheduler
sudo status web2py-scheduler</code></pre><h3>Windows</h3><h4>Apache and mod_wsgi</h4><p>Installing Apache, and mod_wsgi under Windows requires a different procedure. Here are assuming Python 2.5 is installed, you are running from source and web2py is located at <code>c:/web2py</code>.</p><p>First download the requires packages:</p><ul><li>Apache <code>apache_2.2.11-win32-x86-openssl-0.9.8i.msi</code> from  <sup>[<a href="/web2py_book/default/reference/29/apache1" target="_blank">apache1</a>]</sup></li><li>mod_wsgi from <sup>[<a href="/web2py_book/default/reference/29/modwsgi1" target="_blank">modwsgi1</a>]</sup></li></ul><p>Second, run <code>apache...msi</code> and follow the wizard screens. On the server information screen</p><p><p style="text-align:center"><img src="http://127.0.0.1:8000/web2py_book/default/image/29/en9200.png" alt="image" style="width:300px" /></p></p><p>enter all requested values:</p><ul><li><strong>Network Domain</strong>: enter the DNS domain in which your server is or will be registered in.  For example, if your server's full DNS name is server.mydomain.net, you would type mydomain.net here</li><li><strong>ServerName</strong>: Your server's full DNS name. From the example above, you would type server.mydomain.net here. Enter a fully qualified domain name or IP address from the web2py install, not a shortcut, for more information see <sup>[<a href="/web2py_book/default/reference/29/apache2" target="_blank">apache2</a>]</sup>.</li><li><strong>Administrator's Email Address</strong>: Enter the server administrator's or webmaster's email address here. This address will be displayed along with error messages to the client by default.</li></ul><p>Continue with a typical install to the end unless otherwise required</p><p>The wizard, by default, installed Apache in the folder:</p><pre><code class="code">C:/Program Files/Apache Software Foundation/Apache2.2/</code></pre><p>From now on we refer to this folder simply as <code>Apache2.2</code>.</p><p>Third, copy the downloaded mod_wsgi.so to</p><code>Apache2.2/modules</code><p>written by Chris Travers, published by the Open Source Software Lab at Microsoft, December 2007.</p><p>Fourth, create <code>server.crt</code> and <code>server.key</code> certificates (as discussed in the previous section) and place them in the folder  <code>Apache2.2/conf</code>. Notice the cnf file is in <code>Apache2.2/conf/openssl.cnf</code>.</p><p>Fifth, edit <code>Apache2.2/conf/httpd.conf</code>, remove the comment mark (the # character) from the line</p><pre><code class="code">LoadModule ssl_module modules/mod_ssl.so</code></pre><p>add the following line after all the other LoadModule lines</p><pre><code class="code">LoadModule wsgi_module modules/mod_wsgi.so</code></pre><p>look for "Listen 80" and add this line after it</p><pre><code class="code">Listen 443</code></pre><p>append the following lines at the end changing  drive letter, port number, ServerName according to your values</p><pre><code class="code">NameVirtualHost *:443
&lt;VirtualHost *:443&gt;
  DocumentRoot "C:/web2py/applications"
  ServerName server1

  &lt;Directory "C:/web2py"&gt;
    Order allow,deny
    Deny from all
  &lt;/Directory&gt;

  &lt;Location "/"&gt;
    Order deny,allow
    Allow from all
  &lt;/Location&gt;

  &lt;LocationMatch "^(/[\w_]*/static/.*)"&gt;
    Order Allow,Deny
    Allow from all
  &lt;/LocationMatch&gt;

  WSGIScriptAlias / "C:/web2py/wsgihandler.py"

  SSLEngine On
  SSLCertificateFile conf/server.crt
  SSLCertificateKeyFile conf/server.key

  LogFormat "%h %l %u %t "%r" %&gt;s %b" common
  CustomLog logs/access.log common
&lt;/VirtualHost&gt;</code></pre><p>Save and check the config using: [Start &gt; Program &gt; Apache HTTP Server 2.2 &gt; Configure Apache Server &gt; Test Configuration]</p><p>If there are no problems you will see a command screen open and close. Now you can start Apache:</p><p>[Start &gt; Program &gt; Apache HTTP Server 2.2 &gt; Control Apache Server &gt; Start]</p><p>or better yet start the taskbar monitor</p><code>[Start &gt; Program &gt; Apache HTTP Server 2.2 &gt; Control Apache Server]</code><p>Now you can right-click on the red feather-like taskbar icon to "Open Apache Monitor" and then start, stop and restart Apache as required.</p><p>This section was created by Jonathan Lundell.</p><h4>Start as Windows service</h4><h5>This method is deprecated. Consider using nssm (below)</h5><div class="inxx">Windows service</div><p>What Linux calls a daemon, Windows calls a service. The web2py server can easily be installed/started/stopped as a Windows service.</p><p>In order to use web2py as a Windows service, you must create a file "options.py" with startup parameters:</p><pre><code class="code">import socket, os
ip = socket.gethostname()
port = 80
password = '&lt;recycle&gt;'
pid_filename = 'httpserver.pid'
log_filename = 'httpserver.log'
ssl_certificate = "
ssl_private_key = "
numthreads = 10
server_name = socket.gethostname()
request_queue_size = 5
timeout = 10
shutdown_timeout = 5
folder = os.getcwd()</code></pre><p>You don't need to create "options.py" from scratch since there is already an "options_std.py" in the web2py folder that you can use as a model.</p><p>After creating "options.py" in the web2py installation folder, you can install web2py as a service with:</p><pre><code class="code">python web2py.py -W install</code></pre><p>optionally you can specify an options.py file:</p><pre><code class="code">python web2py.py -W install -L options.py</code></pre><p>You can start/stop the service with:</p><pre><code class="code">python web2py.py -W start
python web2py.py -W stop</code></pre><h4>Using nssm to run as a Windows service</h4><div class="inxx">Windows services with nssm</div><p>Rather than maintaining Windows service code in web2py.py, the developers plan to move to an external tool 'nssm'. nssm is a well respected windows tool with technical advantages, such as automatic restart of services. It also means a consistent way of running web2py services, scheduler services and clean-up processes like session deletes. The use of the -W command-line option is deprecated. The nssm method does not use the options.py file. Instead, options are passed on the command line (some exmaples are provided below)</p><h5>nssm example: running the scheduler as a Windows service with nssm</h5><div class="inxx">Windows scheduler service</div><p>Running the scheduler as a Windows service makes a lot of sense. The easiest approach is to download nssm (from <a href="htp://www.nssm.cc">htp://www.nssm.cc</a>). nssm is an open source scheduling helper. It wraps around an executable command to turn it into a service. The command to start the scheduler is <em>pythonw.exe -K &lt;appname&gt;</em> We use nssm to wrap around this, becoming a service. Before doing this, you need to choose a name for your service. There are strong advantages to creating a specific service for each app which needs a scheduler. Therefore, your naming convention for services may be web2py_scheduler_app1</p><p>After extracting the nssm zip file, open a Windows command prompt in the folder containing the version for your architecture, and type</p><code class="code">nssm install web2py_scheduler_app1</code><p>This shows a dialog asking you to enter Application and Options. Application is the pythonw.exe executable from your Python installation. Options is the rest of the command line. You may need to provide the full path to your web2py.py script. For example, the options field in the nssm dialog may be:</p><code class="code">c:\web2py\web2py.py -K app1</code><p>where app1 is the name of your application.</p><p>It is possible to invoke the scheduler with multiple applications. However, in this mode, web2py detaches each application's scheduler into a subprocess. Therefore, the process started by the service will not die if one of the scheduler instances runs into problems; rather, that child process would die. We then can't take advantage of automatic restarting of services in case of failure. Using one app per service avoids this weakness.</p><h5>nssm example: running web2py.py as a service</h5><p>The example above shows how to use nssm. To run web2py in SSL mode on port 8041, and including some other options, you could give nssm a command line (in the options field of the nssm dialog) like this:</p><code class="code">c:\web2py.py -p 8041 -i "0.0.0.0" --password="112233" --folder="d:\web2py_internet" --socket-timeout=10 --timeout=120 -c "d:\web2py_internet\applications\example.com.au.crt" -k "d:\web2py_internet\applications\web2py.key</code><p>(note that this is not best-practice for storing passwords, since a task manager which shows command lines reveals the password. Investigate the web2py command line option -a "&lt;recycle&gt;")</p><h3>Securing sessions and <strong>admin</strong></h3><p><div class="inxx">security</div> <div class="inxx">admin</div></p><p>It is very dangerous to publicly expose the <strong>admin</strong> application and the <strong>appadmin</strong> controllers unless they run over HTTPS. Moreover, your password and credentials should never be transmitted unencrypted. This is true for web2py and any other web application.</p><p>In your applications, if they require authentication, you should make the session cookies secure with:</p><pre><code class="code">session.secure()</code></pre><p>An easy way to setup a secure production environment on a server is to first stop web2py and then remove all the <code>parameters_*.py</code> files from the web2py installation folder.  Then start web2py without a password. This will completely disable admin and appadmin.</p><pre><code class="code">nohup python web2py --nogui -p 8001 -i 127.0.0.1 -a '' &amp;</code></pre><p>Next, start a second web2py instance accessible only from localhost:</p><pre><code class="code">nohup python web2py --nogui -p 8002 -i 127.0.0.1 -a '&lt;ask&gt;' &amp;</code></pre><p>and create an SSH tunnel from the local machine (the one from which you wish to access the administrative interface) to the server (the one where web2py is running, example.com), using:</p><pre><code class="code">ssh -L 8002:127.0.0.1:8002 username@example.com</code></pre><p>Now you can access the administrative interface locally via the web browser at <code>localhost:8002</code>.</p><p>This configuration is secure because <strong>admin</strong> is not reachable when the tunnel is closed (the user is logged out).</p><blockquote>This solution is secure on shared hosts if and only if other users do not have read access to the folder that contains web2py; otherwise users may be able to steal session cookies directly from the server.</blockquote><h3>Efficiency and scalability</h3><div class="inxx">scalability</div><p>web2py is designed to be easy to deploy and to setup. This does not mean that it compromises on efficiency or scalability, but it means you may need to tweak it to make it scalable.</p><p>In this section we assume multiple web2py installations behind a NAT server that provides local load-balancing.</p><p>In this case, web2py works out-of-the-box if some conditions are met. In particular, all instances of each web2py application must access the same database servers and must see the same files. This latter condition can be implemented by making the following folders shared:</p><pre><code class="code">applications/myapp/sessions
applications/myapp/errors
applications/myapp/uploads
applications/myapp/cache</code></pre><p>The shared folders must support file locking. Possible solutions are ZFS (ZFS was developed by Sun Microsystems and is the preferred choice.), NFS (With NFS you may need to run the<code>nlockmgr</code> daemon to allow file locking.), or Samba (SMB).</p><p>It is possible to share the entire web2py folder or the entire applications folder, but this is not a good idea because this would cause a needless increase of network bandwidth usage.</p><p>We believe the configuration discussed above to be very scalable because it reduces the database load by moving to the shared filesystems those resources that need to be shared but do not need transactional safety (only one client at a time is supposed to access a session file, cache always needs a global lock, uploads and errors are write once/read many files).</p><p>Ideally, both the database and the shared storage should have RAID capability. Do not make the mistake of storing the database on the same storage as the shared folders, or you will create a new bottleneck there.</p><p>On a case-by-case basis, you may need to perform additional optimizations and we will discuss them below. In particular, we will discuss how to get rid of these shared folders one-by-one, and how to store the associated data in the database instead. While this is possible, it is not necessarily a good solution. Nevertheless, there may be reasons to do so. One such reason is that sometimes we do not have the freedom to set up shared folders.</p><h4>Efficiency tricks</h4><p>web2py application code is executed on every request, so you want to minimize this amount of code. Here is what you can do:</p><ul><li>Run once with <code>migrate=True</code> then set all your tables to <code>migrate=False</code>.</li><li>Bytecode compile your app using <strong>admin</strong>.</li><li>Use <code>cache.ram</code> as much as you can but make sure to use a finite set of keys, or else the amount of cache used will grow arbitrarily.</li><li>Minimize the code in models: do not define functions there, define functions in the controllers that need them or - even better - define functions in modules, import them and use those functions as needed.</li><li>Do not put many functions in the same controller but use many controllers with few functions.</li><li>Call <code>session.forget(response)</code> in all controllers and/or functions that do not change the session.</li><li>Try to avoid web2py cron, and use a background process instead. web2py cron can start too many Python instances and cause excessive memory usage.</li></ul><h4>Sessions in database</h4><p>It is possible to instruct web2py to store sessions in a database instead of in the sessions folder. This has to be done for each individual web2py application, although they may all use the same database to store sessions.</p><p>Given a database connection</p><pre><code class="code">db = DAL(...)</code></pre><p>you can store the sessions in this database (db) by simply stating the following, in the same model file that establishes the connection:</p><pre><code class="code">session.connect(request, response, db)</code></pre><p>If it does not exist already, web2py creates, under the hood, a table in the database called <code>web2py_session_</code><em>appname</em> containing the following fields:</p><pre><code class="code">Field('locked', 'boolean', default=False),
Field('client_ip'),
Field('created_datetime', 'datetime', default=now),
Field('modified_datetime', 'datetime'),
Field('unique_key'),
Field('session_data', 'text')</code></pre><p>"unique_key" is a uuid key used to identify the session in the cookie. "session_data" is the cPickled session data.</p><p>To minimize database access, you should avoid storing sessions when they are not needed with:</p><pre><code class="code">session.forget()</code></pre><p>Sessions are automatically forgotten is unchanged.</p><p>With sessions in database, "sessions" folder does not need to be a shared folder because it will no longer be accessed.</p><blockquote>Notice that, if sessions are disabled, you must not pass the <code>session</code> to <code>form.accepts</code> and you cannot use <code>session.flash</code> nor CRUD.</blockquote><h4>HAProxy a high availability load balancer</h4><div class="inxx">HAProxy</div><p>If you need multiple web2py processes running on multiple machines, instead of storing sessions in the database or in cache, you have the option to use a load balancer with sticky sessions.</p><p>Pound<sup>[<a href="/web2py_book/default/reference/29/pound" target="_blank">pound</a>]</sup>  and HAProxy<sup>[<a href="/web2py_book/default/reference/29/haproxy" target="_blank">haproxy</a>]</sup>  are two HTTP load balancers and Reverse proxies that provides sticky sessions. Here we discuss the latter because it seems to be more common on commercial VPS hosting.</p><p>By sticky sessions, we mean that once a session cookie has been issued, the load balancer will always route requests from the client associated to the session, to the same server. This allows you to store the session in the local filesystem without need for a shared filesystem.</p><p>To use HAProxy:</p><p>First, install it, on out Ubuntu test machine:</p><pre><code class="code">sudo apt-get -y install haproxy</code></pre><p>Second edit the configuration file "/etc/haproxy.cfg" to something like this:</p><pre><code class="code">## this config needs haproxy-1.1.28 or haproxy-1.2.1

global
      log 127.0.0.1   local0
      maxconn 1024
      daemon

defaults
      log     global
      mode    http
      option  httplog
      option  httpchk
      option  httpclose
      retries 3
      option redispatch
      contimeout      5000
      clitimeout      50000
      srvtimeout      50000

listen 0.0.0.0:80
      balance url_param WEB2PYSTICKY
      balance roundrobin
      server  L1_1 10.211.55.1:7003  check
      server  L1_2 10.211.55.2:7004  check
      server  L1_3 10.211.55.3:7004  check
      appsession WEB2PYSTICKY len 52 timeout 1h</code></pre><p>The <code>listen</code> directive tells HAProxy, which port to wait for connection from. The <code>server</code> directive tells HAProxy where to find the proxied servers. The <code>appsession</code> directory makes a sticky session and uses the a cookie called <code>WEB2PYSTICKY</code> for this purpose.</p><p>Third, enable this config file and start HAProxy:</p><pre><code class="code">/etc/init.d/haproxy restart</code></pre><p>You can find similar instructions to setup Pound at the URL</p><pre><code class="code">http://web2pyslices.com/main/slices/take_slice/33</code></pre><h4>Cleaning up sessions</h4><p>You should be aware that on a production environment, sessions pile up fast. web2py provides a script called:</p><pre><code class="code">scripts/sessions2trash.py</code></pre><p>that when run in the background, periodically deletes all sessions that have not been accessed for a certain amount of time. Web2py provides a script to cleanup these sessions (it works for both file-based sessions and database sessions).</p><p>Here are some typical use cases:</p><ul><li>Delete expired sessions every 5 minutes:</li></ul><pre><code class="code">nohup python web2py.py -S app -M -R scripts/sessions2trash.py &amp;</code></pre><p>or in Windows, use nssm as described above in the scheduler section. You will probably need to include the full path to both web2py.py and the scripts folder, and the trailing &amp; is not needed.</p><ul><li>Delete sessions older than 60 minutes regardless of expiration, with verbose output, then exit:</li></ul><pre><code class="code">python web2py.py -S app -M -R scripts/sessions2trash.py -A -o -x 3600 -f -v</code></pre><ul><li>Delete all sessions regardless of expiry and exit:</li></ul><pre><code class="code">python web2py.py -S app -M -R scripts/sessions2trash.py -A -o -x 0</code></pre><p>Here <code>app</code> is the name of your application.</p><h4>Uploading files in database</h4><p>By default, all uploaded files handled by SQLFORMs are safely renamed and stored in the filesystem under the "uploads" folder. It is possible to instruct web2py to store uploaded files in the database instead.</p><p>Now, consider the following table:</p><pre><code class="code">db.define_table('dog',
    Field('name')
    Field('image', 'upload'))</code></pre><p>where <code>dog.image</code> is of type upload. To make the uploaded image go in the same record as the name of the dog, you must modify the table definition by adding a blob field and link it to the upload field:</p><pre><code class="code">db.define_table('dog',
    Field('name')
    Field('image', 'upload', uploadfield='image_data'),
    Field('image_data', 'blob'))</code></pre><p>Here "image_data" is just an arbitrary name for the new blob field.</p><p>Line 3 instructs web2py to safely rename uploaded images as usual, store the new name in the image field, and store the data in the uploadfield called "image_data" instead of storing the data on the filesystem. All of this is be done automatically by SQLFORMs and no other code needs to be changed.</p><p>With this tweak, the "uploads" folder is no longer needed.</p><p>On Google App Engine, files are stored by default in the database without the need to define an uploadfield, since one is created by default.</p><h4>Collecting tickets</h4><p>By default, web2py stores tickets (errors) on the local file system. It would not make sense to store tickets directly in the database, because the most common origin of error in a production environment is database failure.</p><p>Storing tickets is never a bottleneck, because this is ordinarily a rare event. Hence, in a production environment with multiple concurrent servers, it is more than adequate to store them in a shared folder. Nevertheless, since only the administrator needs to retrieve tickets, it is also OK to store tickets in a non-shared local "errors" folder and periodically collect them and/or clear them.</p><p>One possibility is to periodically move all local tickets to the database.</p><p>For this purpose, web2py provides the following script:</p><pre><code class="code">scripts/tickets2db.py</code></pre><p>By default the script gets the db uri from a file saved into the private folder, <strong>ticket_storage.txt</strong>. This file should contain a string that is passed directly to a <strong>DAL</strong> instance, like:</p><pre><code class="code">mysql://username:password@localhost/test
postgres://username:password@localhost/test
...</code></pre><p>This allows to leave the script as it is: if you have multiple applications, it will dynamically choose the right connection for every application. If you want to hardcode the uri in it, edit the second reference to db_string, right after the <em>except</em> line. You can run the script with the command:</p><pre><code class="code">nohup python web2py.py -S myapp -M -R scripts/tickets2db.py &amp;</code></pre><p>where myapp is the name of your application.</p><p>This script runs in the background and moves all tickets every 5 minutes to a table and removes the local tickets. You can later view the errors using the admin app, clicking on the "switch to: db" button at the top, with the same exact functionality as if they were stored on the file system.</p><p>With this tweak, the "errors" folder does not need to be a shared folder any more, since errors will be stored into the database.</p><h4>Memcache</h4><div class="inxx">memcache</div><p>We have shown that web2py provides two types of cache: <code>cache.ram</code> and <code>cache.disk</code>. They both work on a distributed environment with multiple concurrent servers, but they do not work as expected. In particular, <code>cache.ram</code> will only cache at the server level; thus it becomes useless. <code>cache.disk</code> will also cache at the server level unless the "cache" folder is a shared folder that supports locking; thus, instead of speeding things up, it becomes a major bottleneck.</p><p>The solution is not to use them, but to use memcache instead. web2py comes with a memcache API.</p><p>To use memcache, create a new model file, for example <code>0_memcache.py</code>, and in this file write (or append) the following code:</p><pre><code class="code">from gluon.contrib.memcache import MemcacheClient
memcache_servers = ['127.0.0.1:11211']
cache.memcache = MemcacheClient(request, memcache_servers)
cache.ram = cache.disk = cache.memcache</code></pre><p>The first line imports memcache. The second line has to be a list of memcache sockets (server:port).  The third line defines <code>cache.memcache</code>.  The fourth line redefines <code>cache.ram</code> and <code>cache.disk</code> in terms of memcache.</p><p>You could choose to redefine only one of them to define a totally new cache object pointing to the Memcache object.</p><p>With this tweak the "cache" folder does not need to be a shared folder any more, since it will no longer be accessed.</p><p>This code requires having memcache servers running on the local network. You should consult the memcache documentation for information on how to setup those servers.</p><h4>Sessions in memcache</h4><p>If you do need sessions and you do not want to use a load balancer with sticky sessions, you have the option to store sessions in memcache:</p><pre><code class="code">from gluon.contrib.memdb import MEMDB
session.connect(request,response,db=MEMDB(cache.memcache))</code></pre><h4>Caching with Redis</h4><sup>[<a href="/web2py_book/default/reference/29/redis" target="_blank">redis</a>]</sup><p>An alternative to Memcache is use Redis. <div class="inxx">Redis</div></p><p>Assuming we have Redis installed and running on localhost at port 6379, we can connect to it using the following code (in a model):</p><pre><code>from gluon.contrib.redis_cache import RedisCache
cache.redis = RedisCache('localhost:6379',db=None, debug=True)</code></pre><p>where 'localhost:6379' is the connection string and <code>db</code> is not a DAL object but a Redis database name.</p><p>We can now use <code>cache.redis</code> in place of (or along with) <code>cache.ram</code> and <code>cache.disk</code>.</p><p>We can also obtain Redis statistics by calling:</p><pre><code class="code">cache.redis.stats()</code></pre><p>Redis cache subsystem allows you to prevent the infamous "thundering herd problem": this is not active by default because usually you choose redis for speed, but at a negligible cost you can make sure that only one thread/process can set a value concurrently. To activate this behaviour, just pass the <code>with_lock=True</code> param to the <code>RedisCache</code> call. You can also enable the behaviour "on-demand" with <code>value = cache.redis('mykey', lambda: time.time(), with_lock=True)</code></p><h4>Sessions in Redis</h4><p>If you have Redis in your stack, why not use it for sessions ?</p><pre><code>from gluon.contrib.redis_session import RedisSession
sessiondb = RedisSession('localhost:6379',db=0, session_expiry=False)
session.connect(request, response, db = sessiondb)</code></pre><p>The code has been tested with ~1M sessions. As long as Redis can fit in memory, the time taken to handle 1 or 1M sessions is the same. While against file-based sessions or db-based sessions the speedup is unnoticeable for ~40K sessions, over that barrier the improvement is remarkable. A big improvement can be also noticed when you're running a "farm" of web2py instances, because sharing the sessions folder or having multiple processes connected to a database often hogs down the system. You'll end up with 1 key per session, plus 2 keys, one holding an integer (needed for assigning different session keys) and the other holding the set of all sessions generated (so for 1000 sessions, 1002 keys).</p><p>If <code>session_expiry</code> is not set, sessions will be handled as usual, you'd need to <a href="http://127.0.0.1:8000/web2py_book/default/chapter/29/13#Cleaning-up-sessions">cleanup sessions as usual</a> once a while.</p><p>However, when <code>session_expiry</code> is set will delete automatically sessions after n seconds (e.g. if set to 3600, session will expire exactly one hour later having been updated the last time), you should occasionally run sessions2trash.py just to clean the key holding the set of all the sessions previously issued (for ~1M sessions, cleaning up requires 3 seconds) The redis backend for sessions is the only one that can prevent concurrent modifications to the same session: this is especially true for ajax-intensive applications that write to sessions often in a semi-concurrent way. To favour speed this is by default not enforced, however if you want to turn on the locking behaviour, just turn it on with <code>with_lock=True</code> parameter passed to the <code>RedisSession</code> object.</p><h4>Removing applications</h4><div class="inxx">removing application</div><p>In a production setting, it may be better not to install the default applications: <strong>admin</strong>, <strong>examples</strong> and <strong>welcome</strong>. Although these applications are quite small, they are not necessary.</p><p>Removing these applications is as easy as deleting the corresponding folders under the applications folder.</p><h4>Using replicated databases</h4><p>In a high performance environment you may have a master-slave database architecture with many replicated slaves and perhaps a couple of replicated servers. The DAL can handle this situation and conditionally connect to different servers depending on the request parameters. The API to do this was described in Chapter 6. Here is an example:</p><pre><code class="code">from random import sample
db = DAL(sample(['mysql://...1','mysql://...2','mysql://...3'], 3))</code></pre><p>In this case, different HTTP requests will be served by different databases at random, and each DB will be hit more or less with the same probability.</p><p>We can also implement a simple Round-Robin</p><pre><code class="code">def fail_safe_round_robin(*uris):
     i = cache.ram('round-robin', lambda: 0, None)
     uris = uris[i:]+uris[:i] # rotate the list of uris
     cache.ram('round-robin', lambda: (i+1)%len(uris), 0)
     return uris
db = DAL(fail_safe_round_robin('mysql://...1','mysql://...2','mysql://...3'))</code></pre><p>This is fail-safe in the sense that if the database server assigned to the request fails to connect, DAL will try the next one in the order.</p><p>It is also possible to connect to different databases depending on the requested action or controller. In a master-slave database configuration, some action performs only a read and some person both read/write. The former can safely connect to a slave db server, while the latter should connect to a master. So you can do:</p><pre><code class="code">if request.function in read_only_actions:
   db = DAL(sample(['mysql://...1','mysql://...2','mysql://...3'], 3))
elif request.action in read_only_actions:
   db = DAL(shuffle(['mysql://...1','mysql://...2','mysql://...3']))
else:
   db = DAL(sample(['mysql://...3','mysql://...4','mysql://...5'], 3))</code></pre><p>where 1,2,3 are slaves and 3,4,5 are masters.</p><h4>Compress static files</h4><p>Browsers can decompress content on-the-fly, so compressing content for those browsers saves your bandwidth and theirs, lowering response times. Nowadays most web servers can compress your content on the fly and send it to the browsers requesting gzipped content. However, for static files, you are wasting CPU cycles to compress the same content over and over.</p><p>You can use <em>scripts/zip_static_files.py</em> to create gzipped versions of your static files and serve those without wasting CPU. Run as <code>python web2py.py -S myapp -R scripts/zip_static_files.py</code> in cron. The script takes care to create (or update) the gzipped version and saves them along with your files, appending a .gz to their name. You just need to let your webserver know when to send those files <sup>[<a href="/web2py_book/default/reference/29/apache-content-negotiation" target="_blank">apache-content-negotiation</a>]</sup> <sup>[<a href="/web2py_book/default/reference/29/nginx-gzipstatic" target="_blank">nginx-gzipstatic</a>]</sup></p><h3>Deploying on PythonAnywhere</h3><p><code class="code">PythonAnywhere</code> <div class="inxx">PythonAnywhere</div></p><p>PythonAnywhere is the simplest way to deploy web2py applications.</p><p>PythonAnywhere is a Python development and hosting environment that displays in your web browser and runs on cloud servers. They are already set up with everything you need to run Python and they support web2py specifically. In our experience PythonAnywhere is easy to use, fast, and powerful. They also provide MySQL databases, python shells and Dropbox integration. Professional hosting is available if the free basic one is not enough for you.</p><p>In order to use PythonAnywhere you need to create an account, login, then use the provided web Dashboard to add a new Web App of type web2py.</p><p><p style="text-align:center"><img src="http://127.0.0.1:8000/web2py_book/default/image/29/pythonanywhere1.png" alt="image" style="width:300px" /></p> <p style="text-align:center"><img src="http://127.0.0.1:8000/web2py_book/default/image/29/pythonanywhere2.png" alt="image" style="width:300px" /></p></p><p>The interface also ask you for an administrative password.</p><p><p style="text-align:center"><img src="http://127.0.0.1:8000/web2py_book/default/image/29/pythonanywhere3.png" alt="image" style="width:300px" /></p></p><p>The web2py folder will be created in your user folder.</p><p>Alternatively, you can also use the web based BASH shell to install web2py as you normally do:</p><pre><code class="code">wget http://www.web2py.com/examples/static/web2py_src.zip
unzip web2py_src.zip</code></pre><p>Always from the shell you should create an admin password for later use:</p><pre><code class="code">python -c "from gluon.main import save_password; save_password(raw_input('admin  password: '),433)"</code></pre><p>Then visit the "Web" panel using the web interface and edit the "/var/www/&lt;username&gt;_pythonanywhere_com_wsgi.py" file. This is the entry point for your program (in our case web2py) and, as you may guess, it is based on the WSGI protocol.</p><p>Edit the "/var/www/&lt;username&gt;_pythonanywhere_com_wsgi.py" file and write in it:</p><pre><code class="code">import sys
path = '/home/&lt;username&gt;/web2py'
if path not in sys.path: sys.path.append(path)
from wsgihandler import application # the web2py handler</code></pre><p>Here "&lt;username&gt;" is your PythonAnywhere username.</p><p>After you've installed web2py, notice that you do not need to start or configure a web server. PythonAnywhere provides one and it is reloaded when you edit the above config file. or press the "Reload web app" button on the Dashboard. Everyone can immediately access it at the url:</p><pre><code class="code">http://yourusername.pythonanywhere.com/</code></pre><p>They also provide a secure version of the site, and you're forced to use it for using the web2py Administrative interface at:</p><pre><code class="code">https://yourusername.pythonanywhere.com/admin/default/index</code></pre><p>We thank the PythonAnywhere team for their help and support.</p><h3>Deploying on Heroku</h3><p><sup>[<a href="/web2py_book/default/reference/29/heroku" target="_blank">heroku</a>]</sup> <div class="inxx">Heroku</div></p><p>Heroku is a modern and agile multiplatform hosting solution. It allows to push your applications to a server cloud using Git. In order to user Heroku you must have Git installed and you must have the Heroku SDK installed. You interact heroku using the SDK locally and your commands will be pushed and executed on the server.</p><p>Applications running on Heroku cannot rely on a persistent filesystem since it is refreshed periodically. For this reason only the application code can be stored on the file system. All data must be stored in the database. Heroku relies on PostgreSQL. Yet the PostgreSQL is also configured using the Heroku SDK and the URI for the database is assigned dynamically at run-time and stored in an environment variable.</p><p>This means that web2py applications must be modified to work on Heroku in order to use the database.</p><p>Web2py provides a "heroku.sh" script to help you. All you need to do is replace:</p><pre><code class="code">db = DAL(...)</code></pre><p>in your code with:</p><pre><code class="code">from gluon.contrib.heroku import get_db
db = get_db(name=None, pool_size=10)</code></pre><p>Here <code>name</code> is the environment variable containing the Heroku PostgreSQL URI (something like <code>HEROKU_POSTGRESQL_RED_URL</code>). It defaults to <code>None</code> and if there is only one <code>HEROKU_POSTGRESQL_*_URL</code> environment variable it will use that. <code>pool_size</code> is the usual DAL pool size.</p><p>When non-running on the Heroku platform <code>get_db</code> will use a development database "sqlite://heroku.test.sqlite".</p><p>In both cases sessions will be stored in database.</p><p>Web2py provides a script "scripts/setup-web2py-heroku.sh" to deploy your web2py installation on heroku. It performs the following steps:</p><p>It installs virtualenv and the psycopg2 driver:</p><pre><code class="code">sudo pip install virtualenv
sudo pip install psycopg2</code></pre><p>It creates and activates a virtualenv</p><pre><code class="code">virtualenv venv --distribute
source venv/bin/activate</code></pre><p>Then creates a requirement file:</p><pre><code class="code">pip freeze &gt; requirements.txt</code></pre><p>And creates a "Procfile" which tells Heroku how to start web2py:</p><pre><code class="code">echo "web: python web2py.py -a 'yourpassword' -i 0.0.0.0 -p $PORT" &gt; Procfile</code></pre><p>You can change this line to use a different server. You must edit it to select your own admin password. <code>$PORT</code> is a variable which is correctly escaped since its value is set at runtime. You should also consider starting web2py with gunicorn using <code>anyserver.py</code> since this is one of the recommended web servers for Python.</p><p>Finally the script creates a Git repository:</p><pre><code class="code">git init
git add .
git add Procfile
git commit -a -m "first commit"</code></pre><p>pushes everything to Heroku, and starts it:</p><pre><code class="code">heroku create
git push heroku master
heroku addons:add heroku-postgresql:dev
heroku scale web=1
heroku open</code></pre><p><code>heroku</code> here is a shell command part of the Heroku SDK.</p><p>We thank Craig Krestiens from Heroku for his help with this recipe.</p><h3>Deploying on EC2</h3><div class="inxx">Amazon EC2</div><p>Amazon Elastic Compute Cloud (Amazon EC2) is a web service that provides resizable computing capacity in the cloud. It is one of the largest and most popular clouds. Many other cloud platforms run on EC2. You can run any application on EC2 by creating and deploying a disk image. Amazon then provides API to replicate the image while sharing part of the file system.</p><p>A description of the entire process is beyond the scope of this book but, assuming you have an existing Amazon EC2 account, you can use the Turnkey Hub find and deploy a ready made web2py image:</p><code>https://hub.turnkeylinux.org/amazon/launch/web2py/</code><p>Once your image is deployed you can login into it as a normal VPS and you can manage (backup/restore/copy) it via the Amazon EC2 web interface.</p><h3>Deploying on Google App Engine</h3><div class="inxx">Google App Engine</div><p>It is possible to run web2py code on Google App Engine (GAE)<sup>[<a href="/web2py_book/default/reference/29/gae" target="_blank">gae</a>]</sup> , including DAL code.</p><p>GAE supports two versions of Python: 2.5 and 2.7 web2py supports both but uses 2.5 by default (this may change in the future). Look into the "app.yaml" file described below for configuration details.</p><p>GAE also supports a Google SQL database (compatible with MySQL) and a Google NoSQL (referred to as "Datastore").</p><p>web2py supports both, and indeed, can connect to both at the same time, using the connection strings detailed in Chapter 6.</p><p>The GAE platform provides several advantages over normal hosting solutions:</p><ul><li>Ease of deployment. Google completely abstracts the underlying architecture.</li><li>Scalability. Google will replicate your app as many times as it takes to serve all concurrent requests.</li><li>One can choose between a SQL and a NoSQL database (or both together).</li></ul><p>But also some disadvantages:</p><ul><li>No read or write access to the file system.</li><li>No HTTPS unless you use the <code>appspot.com</code> domain with a Google certificate.</li><li>Not all Python libraries are supported (scipy is a notable non-supported library at the time of writing).</li></ul><p>While Google Cloud SQL is a regular mysql database, Google Datastore has some specific disadvantages:</p><ul><li>No typical transactions; <em>eventual consistency</em> rather than strong consistency for queries.</li><li>No complex datastore queries. In particular there are no <code>JOIN</code>, <code>LIKE</code>, and <code>DATE/DATETIME</code> operators.</li><li>No multiple <code>OR</code> sub-queries unless they involve one and the same field.</li></ul><p>Here we provide a quick overview of GAE and we focus on web2py specific issues, we refer you to the official GAE documentation online for details.</p><blockquote>Attention: You must run the web2py source distribution, not a binary distribution.</blockquote><h4>Configuration</h4><p>There are three configuration files to be aware of:</p><pre><code class="code">web2py/app.yaml
web2py/queue.yaml
web2py/index.yaml</code></pre><p><code>app.yaml</code> and <code>queue.yaml</code> are most easily created by using the template files <code>app.example.yaml</code> and <code>queue.example.yaml</code> as starting points. <code>index.yaml</code> is created automatically by the Google deployment software.</p><p><code>app.yaml</code> has the following structure (it has been shortened using ...):</p><pre><code class="code">application: web2py
version: 1
api_version: 1
runtime: python
handlers:
- url: /_ah/stats.*
  ...
- url: /(?P&lt;a&gt;.+?)/static/(?P&lt;b&gt;.+)
  ...
- url: /_ah/admin/.*
  ...
- url: /_ah/queue/default
  ...
- url: .*
  ...
skip_files:
...</code></pre><p><code>app.example.yaml</code> (when copied to <code>app.yaml</code>) is configured to deploy the web2py <code>welcome</code> application, but not the <code>admin</code> or <code>example</code> applications. You must replace <code>web2py</code> with the application id that you used when registering with Google App Engine.</p><p><code>url: /(.+?)/static/(.+)</code> instructs GAE to serve your app static files directly, without calling web2py logic, for speed.</p><p><code>url:.*</code> instructs web2py to use the <code>gaehandler.py</code> for every other request.</p><p>The <code>skip_files:</code> session is list of regular expressions for files that do not need to deployed on GAE. In particular the lines:</p><pre><code class="code"> (applications/(admin|examples)/.*)|
 ((admin|examples|welcome).(w2p|tar))|</code></pre><p>tell GAE not to deploy the default applications, except for the unpacked welcome scaffolding application. You can add more applications to be ignored here.</p><p>Except for the application id and version, you probably do not need to edit <code>app.yaml</code>, though you may wish to exclude the <code>welcome</code> application.</p><p>The file <code>queue.yaml</code> is used to configure GAE task queues.</p><p>The file <code>index.yaml</code> is automatically generated when you run your application locally using the GAE appserver (the web server that comes with the Google SDK). It contains something like this:</p><pre><code class="code">indexes:
- kind: person
  properties:
  - name: name
    direction: desc</code></pre><p>In this example it tells GAE to create an index for table "person" that will be used to sort by "name" in reversed alphabetical order. You will not be able to search and sort records in your app without corresponding indexes.</p><p>It is important to always run your apps locally with the appserver and try every functionality of your app, before deployment. This will be important for testing purposes, but also to automatically generate the "index.yaml" file. Occasionally you may want to edit this file and perform cleanup, such as removing duplicate entries.</p><h4>Running and deployment</h4><h5>Linux</h5><p>Here we assume you have installed the GAE SDK.  At the time of writing, GAE runs on Python 2.5.2.  You can run your app from inside the "web2py" folder by using the appserver command:</p><pre><code class="code">python2.5 dev_appserver.py ../web2py</code></pre><p>This will start the appserver and you can run your application at the URL:</p><pre><code class="code">http://127.0.0.1:8080/</code></pre><p>In order to upload your app on GAE, make sure you have edited the "app.yaml" file as explained before and set the proper application id, then run:</p><pre><code class="code">python2.5 appcfg.py update ../web2py</code></pre><h5>Mac, Windows</h5><p>On Mac and Windows, you can also use the Google App Engine Launcher. You can download the software from ref.<sup>[<a href="/web2py_book/default/reference/29/gae" target="_blank">gae</a>]</sup> .</p><p>Choose [File][Add Existing Application], set the path to the path of the top-level web2py folder, and press the [Run] button in the toolbar. After you have tested that it works locally, you can deploy it on GAE by simply clicking on the [Deploy] button on the toolbar (assuming you have an account).</p><p><p style="text-align:center"><img src="http://127.0.0.1:8000/web2py_book/default/image/29/en9300.png" alt="image" style="width:300px" /></p></p><p>On GAE, the web2py tickets/errors are also logged into the GAE administration console where logs can be accessed and searched online.</p><p><p style="text-align:center"><img src="http://127.0.0.1:8000/web2py_book/default/image/29/en9400.png" alt="image" style="width:300px" /></p></p><h4>Configuring the handler</h4><p>The file <code>gaehandler.py</code> is responsible for serving files on GAE and it has a few options. Here are their default values:</p><pre><code class="code">LOG_STATS = False
APPSTATS = True
DEBUG = False</code></pre><p><code>LOG_STATS</code> will log the time to serve pages in the GAE logs.</p><p><code>APPSTATS</code> will enable GAE appstats which provides profiling statistics. They will be made available at the URL:</p><pre><code class="code">http://localhost:8080/_ah/stats</code></pre><p><code>DEBUG</code> sets debug mode. It make no difference in practice unless checked explicitly in your code via <code>gluon.settings.web2py_runtime</code>.</p><h4>Avoid the filesystem</h4><p>On GAE you have no access to the filesystem. You cannot open any file for writing.</p><p>For this purpose, on GAE, web2py automatically stores all uploaded files in the datastore, whether or not "upload" Field(s) have a <code>uploadfield</code> attribute.</p><p>You also should store sessions and tickets in the database and you have to be explicit:</p><pre><code class="code">if request.env.web2py_runtime_gae
    db = DAL('gae')
    session.connect(request,response,db)
else:
    db = DAL('sqlite://storage.sqlite')</code></pre><p>The above code checks whether you are running on GAE, connects to BigTable, and instructs web2py to store sessions and tickets in there. It connects to a sqlite database otherwise. This code is already in the scaffolding app in the file "db.py".</p><h4>Memcache</h4><p>If you prefer, you can store sessions in memcache too:</p><pre><code class="code">from gluon.contrib.gae_memcache import MemcacheClient
from gluon.contrib.memdb import MEMDB
cache.memcache = MemcacheClient(request)
cache.ram = cache.disk = cache.memcache
session.connect(request,response,db=MEMDB(cache.memcache.client))</code></pre><p>Notice that on GAE cache.ram and cache.disk should not be used, so we make them point to cache.memcache.</p><h4>Datastore issues</h4><p>While the Google Clould SQL functions as a regular SQL database, and is indeed based at the time of writing on mysql, Google Datastore presents significant differences.</p><h5>Eventual consistency</h5><p>The <em>eventual consistency</em> offered by Google Datastore deserves special attention. In the Datastore, transactions that rely on primary Datastore keys, or a shared entity group, offer a strong consistency: every subsequent transaction or query will see the result of any prior transaction for the same key or entity group. On the other hand, queries that do not rely on primary keys or shared entity groups offer only <em>eventual consistency</em>: new or modified data will be eventually made available to queries, after an unspecified delay that is typically up to a few seconds.</p><p>web2py does not rely on primary Datastore keys, nor shared entity groups.  The statement:</p><pre><code class="code">id = db.table.insert(field1=value1, field2=value2)</code></pre><p>has the following effect:</p><ul><li>A new row is inserted in the table <code>db.table</code>; the row has a field <code>id</code> whose value is assigned by web2py.  The row also has a primary Datastore key, but this primary key is <em>not</em> <code>id</code>, and is not exposed.</li><li>The indices on <code>db.table</code> are updated.  In particular, the index over <code>id</code> is updated, so the new row is <em>eventually</em> available to queries over <code>db.table.id</code>.</li></ul><p>Only after these two steps terminate, is the new data available for queries by <code>id</code>. In particular, the following common web2py paradigm will <em>fail</em>:</p><pre><code class="code">def insert():
    form = SQLFORM(db.table)
    if form.process().accepted:
        session.flash = T('The data has been inserted.')
        redirect(URL('view', args=[form.vars.id]))
    return dict(form=form)

def view():
    row = db.table(request.args(0))
    if row is None:
        session.flash = T('Data not found')
        redirect(URL(index))
    form = SQLFORM(db.table, record=row, readonly=True)
    return dict(form=form)</code></pre><p>Once a user visits the <code>insert</code> page and inserts data, the user is redirected to the <code>view</code> page. When using the Google Datastore, often the data just inserted is not found in the <code>view</code> controller.  Why?</p><p>What happens is this.  In the <code>insert</code> controller, the data is inserted in the database, and the transaction is completed.  Then, asynchronously and after the transaction completes, Google Datastore rebuilds the indices, including the index on the <code>id</code> field of <code>db.table</code>.  When the user accesses the <code>view</code> controller, there is no guarantee that the index on <code>db.table.id</code> already includes the new data item, and thus, the user is often presented with the "Data not found" message.</p><h5>Lack of JOINs</h5><p>The lack of JOIN operations and typical relational functionality of the Datastore requires removing JOINs from web2py queries and de-normalizing the database.</p><p>Google App Engine supports some special field types, such as <code>ListProperty</code> and <code>StringListProperty</code>. You can use these types with web2py using the following old syntax:</p><pre><code class="code">from gluon.dal import gae
db.define_table('product',
    Field('name'),
    Field('tags', type=gae.StringListProperty())</code></pre><p>or the equivalent new syntax:</p><pre><code class="code">db.define_table('product',
    Field('name'),
    Field('tags', 'list:string')</code></pre><p>In both cases the "tags" field is a <code>StringListProperty</code> therefore its values must be lists of strings, compatibly with the GAE documentation. The second notation is to be preferred because web2py will treat the field in a smarter way in the context of forms and because it will work with relational databases too.</p><p>Similarly, web2py supports <code>list:integer</code> and <code>list:reference</code> which map into a <code>ListProperty(int)</code>.</p><p><code>list</code> types are discussed in more detail in Chapter 6.</p><h4>Database migrations</h4><p>A good practice for migrations using Google AppEngine is the following. AppEngine supports multiple code versions. Use one code version (e.g., version 1) for the user-visible site, and another code version (e.g., version 2) for the admin code.  In <code>app.yaml</code> for version 2, declare the handler as follows (assuming Python 2.7 is used):</p><pre><code class="code">- url: .*
  script: gaehandler.wsgiapp    # WSGI (Python 2.7 only)
  secure: optional
  login: admin</code></pre><p>The <code>login: admin</code> clause ensures that only admins can use version 2. In the database connection string, specify <code>migrate_enabled=False</code>. To perform a migration, it is best to disable database access concurrent to the migration. Proceed as follows:</p><ul><li>Add a file named <code>DISABLED</code> to the top directory of your version 1 application (the parent directory of the <code>/controllers</code>, <code>/views</code>, etc. directories), and upload the new version to GAE. This will disable version 1, and display a message <em>"The site is temporarily down for maintenance"</em>.</li><li>Upload to version 2 code with <code>migrate_enabled=True</code> in the db connection string, and visit it from an admin account, triggering the migration.</li><li>Upload to version 2 code with <code>migrate_enabled=False</code>, to disable further migrations.</li><li>Remove the file named <code>DISABLED</code> from version 1, and upload the code to version 1.  This makes the site again visible to all.</li></ul><h4>GAE and https</h4><p>If you application has id "myapp" your GAE domain is</p><pre><code class="code">http://myapp.appspot.com/</code></pre><p>and it can also be accessed via HTTPS</p><pre><code class="code">https://myapp.appspot.com/</code></pre><p>In this case it will use an "appspot.com" certificate provided by Google.</p><p>You can register a DNS entry and use any other domain name you own for your app but you will not be able to use HTTPS on it. At the time of writing, this is a GAE limitation.</p>