<h2>The Python language</h2><div class="inxx">Python</div><h3>About Python</h3><p>Python is a general-purpose high-level programming language. Its design philosophy emphasizes programmer productivity and code readability. It has a minimalist core syntax with very few basic commands and simple semantics, but it also has a large and comprehensive standard library, including an Application Programming Interface (API) <div class="inxx">API</div> to many of the underlying operating system (OS) functions. Python code, while minimalist, defines built-in objects such as linked lists (<code>list</code>), tuples (<code>tuple</code>), hash tables (<code>dict</code>), and arbitrarily long integers (<code>long</code>).</p><p>Python supports multiple programming paradigms, including object-oriented (<code>class</code>), imperative (<code>def</code>), and functional (<code>lambda</code>) programming. Python has a dynamic type system and automatic memory management using reference counting (similar to Perl, Ruby, and Scheme).</p><p>Python was first released by Guido van Rossum in 1991. The language has an open, community-based development model managed by the non-profit Python Software Foundation. There are many interpreters and compilers that implement the Python language, including one in Java (Jython) but, in this brief review, we refer to the reference C implementation created by Guido.</p><p>You can find many tutorials, the official documentation and library references of the language on the official Python website.<sup>[<a href="/book/default/reference/29/python" target="_blank">python</a>]</sup></p><p>For additional Python references, we can recommend the books in ref.<sup>[<a href="/book/default/reference/29/guido" target="_blank">guido</a>]</sup>  and ref.<sup>[<a href="/book/default/reference/29/lutz" target="_blank">lutz</a>]</sup> .</p><p>You may skip this chapter if you are already familiar with the Python language.</p><h3>Starting up</h3><div class="inxx">shell</div><p>The binary distributions of web2py for Microsoft Windows or Apple OS X come packaged with the Python interpreter built into the distribution file itself.</p><p>You can start it on Windows with the following command (type at the DOS prompt):</p><pre><code class="code">web2py.exe -S welcome</code></pre><p>On Apple OS X, enter the following command type in a Terminal window (assuming you're in the same folder as web2py.app):</p><pre><code class="code">./web2py.app/Contents/MacOS/web2py -S welcome</code></pre><p>On a Linux or other Unix box, chances are that you have Python already installed. If so, at a shell prompt type:</p><pre><code class="code">python web2py.py -S welcome</code></pre><p>If you do not have Python 2.5 (or later 2.x) already installed, you will have to download and install it before running web2py.</p><p>The <code>-S welcome</code> command line option instructs web2py to run the interactive shell as if the commands were executed in a controller for the <strong>welcome</strong> application, the web2py scaffolding application. This exposes almost all web2py classes, objects and functions to you. This is the only difference between the web2py interactive command line and the normal Python command line.</p><p>The admin interface also provides a web-based shell for each application. You can access the one for the "welcome" application at.</p><pre><code class="code">http://127.0.0.1:8000/admin/shell/index/welcome</code></pre><p>You can try all the examples in this chapter using the normal shell or the web-based shell.</p><h3>help, dir</h3><p><div class="inxx">help</div> <div class="inxx">dir</div></p><p>The Python language provides two commands to obtain documentation about objects defined in the current scope, both built-in and user-defined.</p><p>We can ask for <code>help</code> about an object, for example "1":</p><pre><code class="code">&gt;&gt;&gt; help(1)
Help on int object:

class int(object)
 |  int(x[, base]) -&gt; integer
 |
 |  Convert a string or number to an integer, if possible.  A floating point
 |  argument will be truncated towards zero (this does not include a string
 |  representation of a floating point number!)  When converting a string, use
 |  the optional base.  It is an error to supply a base when converting a
 |  non-string. If the argument is outside the integer range a long object
 |  will be returned instead.
 |
 |  Methods defined here:
 |
 |  __abs__(...)
 |      x.__abs__() &lt;==&gt; abs(x)
...</code></pre><p>and, since "1" is an integer, we get a description about the <code>int</code> class and all its methods. Here the output has been truncated because it is very long and detailed.</p><p>Similarly, we can obtain a list of methods of the object "1" with the command <code>dir</code>:</p><pre><code class="code">&gt;&gt;&gt; dir(1)
['__abs__', ..., '__xor__']</code></pre><h3>Types</h3><div class="inxx">type</div><p>Python is a dynamically typed language, meaning that variables do not have a type and therefore do not have to be declared. Values, on the other hand, do have a type. You can query a variable for the type of value it contains:</p><pre><code class="code">&gt;&gt;&gt; a = 3
&gt;&gt;&gt; print type(a)
&lt;type 'int'&gt;
&gt;&gt;&gt; a = 3.14
&gt;&gt;&gt; print type(a)
&lt;type 'float'&gt;
&gt;&gt;&gt; a = 'hello python'
&gt;&gt;&gt; print type(a)
&lt;type 'str'&gt;</code></pre><p>Python also includes, natively, data structures such as lists and dictionaries.</p><h4><code>str</code></h4><p><div class="inxx">str</div> <div class="inxx">ASCII</div> <div class="inxx">UTF8</div> <div class="inxx">Unicode</div> <div class="inxx">encode</div></p><p>Python supports the use of two different types of strings: ASCII strings and Unicode strings. ASCII strings are delimited by '...', "..." or by <em>'..</em>' or """...""". Triple quotes delimit multiline strings. Unicode strings start with a <code>u</code> followed by the string containing Unicode characters. A Unicode string can be converted into an ASCII string by choosing an encoding for example:</p><pre><code class="code">&gt;&gt;&gt; a = 'this is an ASCII string'
&gt;&gt;&gt; b = u'This is a Unicode string'
&gt;&gt;&gt; a = b.encode('utf8')</code></pre><p>After executing these three commands, the resulting <code>a</code> is an ASCII string storing UTF8 encoded characters. By design, web2py uses UTF8 encoded strings internally.</p><p>It is also possible to write variables into strings in various ways:</p><pre><code class="code">&gt;&gt;&gt; print 'number is ' + str(3)
number is 3
&gt;&gt;&gt; print 'number is %s' % (3)
number is 3
&gt;&gt;&gt; print 'number is %(number)s' % dict(number=3)
number is 3</code></pre><p>The last notation is more explicit and less error prone, and is to be preferred.</p><p>Many Python objects, for example numbers, can be serialized into strings using <code>str</code> or <code>repr</code>. These two commands are very similar but produce slightly different output. For example:</p><pre><code class="code">&gt;&gt;&gt; for i in [3, 'hello']:
        print str(i), repr(i)
3 3
hello 'hello'</code></pre><p>For user-defined classes, <code>str</code> and <code>repr</code> can be defined/redefined using the special operators <code>__str__</code> and <code>__repr__</code>. These are briefly described later on; for more, refer to the official Python documentation<sup>[<a href="/book/default/reference/29/pydocs" target="_blank">pydocs</a>]</sup> . <code>repr</code> always has a default value.</p><p>Another important characteristic of a Python string is that, like a list, it is an iterable object.</p><pre><code class="code">&gt;&gt;&gt; for i in 'hello':
        print i
h
e
l
l
o</code></pre><h4><code>list</code></h4><div class="inxx">list</div><p>The main methods of a Python list are append, insert, and delete:</p><pre><code class="code">&gt;&gt;&gt; a = [1, 2, 3]
&gt;&gt;&gt; print type(a)
&lt;type 'list'&gt;
&gt;&gt;&gt; a.append(8)
&gt;&gt;&gt; a.insert(2, 7)
&gt;&gt;&gt; del a[0]
&gt;&gt;&gt; print a
[2, 7, 3, 8]
&gt;&gt;&gt; print len(a)
4</code></pre><p>Lists can be sliced:</p><pre><code class="code">&gt;&gt;&gt; print a[:3]
[2, 7, 3]
&gt;&gt;&gt; print a[1:]
[7, 3, 8]
&gt;&gt;&gt; print a[-2:]
[3, 8]</code></pre><p>and concatenated:</p><pre><code class="code">&gt;&gt;&gt; a = [2, 3]
&gt;&gt;&gt; b = [5, 6]
&gt;&gt;&gt; print a + b
[2, 3, 5, 6]</code></pre><p>A list is iterable; you can loop over it:</p><pre><code class="code">&gt;&gt;&gt; a = [1, 2, 3]
&gt;&gt;&gt; for i in a:
        print i
1
2
3</code></pre><p>The elements of a list do not have to be of the same type; they can be any type of Python object.</p><p>There is a very common situation for which a <em>list comprehension</em> can be used.  Consider the following code:</p><pre><code class="code">&gt;&gt;&gt; a = [1,2,3,4,5]
&gt;&gt;&gt; b = []
&gt;&gt;&gt; for x in a:
        if x % 2 == 0:
            b.append(x * 3)
&gt;&gt;&gt; b
[6, 12]</code></pre><p>This code clearly processes a list of items, selects and modifies a subset of the input list, and creates a new result list, and this code can be entirely replaced with the following list comprehension:</p><pre><code class="code">&gt;&gt;&gt; a = [1,2,3,4,5]
&gt;&gt;&gt; b = [x * 3 for x in a if x % 2 == 0]
&gt;&gt;&gt; b
[6, 12]</code></pre><h4><code>tuple</code></h4><div class="inxx">tuple</div><p>A tuple is like a list, but its size and elements are immutable, while in a list they are mutable. If a tuple element is an object, the object attributes are mutable. A tuple is delimited by round brackets.</p><pre><code class="code">&gt;&gt;&gt; a = (1, 2, 3)</code></pre><p>So while this works for a list:</p><pre><code class="code">&gt;&gt;&gt; a = [1, 2, 3]
&gt;&gt;&gt; a[1] = 5
&gt;&gt;&gt; print a
[1, 5, 3]</code></pre><p>the element assignment does not work for a tuple:</p><pre><code class="code">&gt;&gt;&gt; a = (1, 2, 3)
&gt;&gt;&gt; print a[1]
2
&gt;&gt;&gt; a[1] = 5
Traceback (most recent call last):
  File "&lt;stdin&gt;", line 1, in &lt;module&gt;
TypeError: 'tuple' object does not support item assignment</code></pre><p>A tuple, like a list, is an iterable object. Notice that a tuple consisting of a single element must include a trailing comma, as shown below:</p><pre><code class="code">&gt;&gt;&gt; a = (1)
&gt;&gt;&gt; print type(a)
&lt;type 'int'&gt;
&gt;&gt;&gt; a = (1,)
&gt;&gt;&gt; print type(a)
&lt;type 'tuple'&gt;</code></pre><p>Tuples are very useful for efficient packing of objects because of their immutability, and the brackets are often optional:</p><pre><code class="code">&gt;&gt;&gt; a = 2, 3, 'hello'
&gt;&gt;&gt; x, y, z = a
&gt;&gt;&gt; print x
2
&gt;&gt;&gt; print z
hello</code></pre><h4><code>dict</code></h4><div class="inxx">dict</div><p>A Python <code>dict</code>-ionary is a hash table that maps a key object to a value object. For example:</p><pre><code class="code">&gt;&gt;&gt; a = {'k':'v', 'k2':3}
&gt;&gt;&gt; a['k']
v
&gt;&gt;&gt; a['k2']
3
&gt;&gt;&gt; a.has_key('k')
True
&gt;&gt;&gt; a.has_key('v')
False</code></pre><p>Keys can be of any hashable type (int, string, or any object whose class implements the <code>__hash__</code> method). Values can be of any type. Different keys and values in the same dictionary do not have to be of the same type. If the keys are alphanumeric characters, a dictionary can also be declared with the alternative syntax:</p><pre><code class="code">&gt;&gt;&gt; a = dict(k='v', h2=3)
&gt;&gt;&gt; a['k']
v
&gt;&gt;&gt; print a
{'k':'v', 'h2':3}</code></pre><p>Useful methods are <code>has_key</code>, <code>keys</code>, <code>values</code> and <code>items</code>:</p><pre><code class="code">&gt;&gt;&gt; a = dict(k='v', k2=3)
&gt;&gt;&gt; print a.keys()
['k', 'k2']
&gt;&gt;&gt; print a.values()
['v', 3]
&gt;&gt;&gt; print a.items()
[('k', 'v'), ('k2', 3)]</code></pre><p>The <code>items</code> method produces a list of tuples, each containing a key and its associated value.</p><p>Dictionary elements and list elements can be deleted with the command <code>del</code>:</p><pre><code class="code">&gt;&gt;&gt; a = [1, 2, 3]
&gt;&gt;&gt; del a[1]
&gt;&gt;&gt; print a
[1, 3]
&gt;&gt;&gt; a = dict(k='v', h2=3)
&gt;&gt;&gt; del a['h2']
&gt;&gt;&gt; print a
{'k':'v'}</code></pre><p>Internally, Python uses the <code>hash</code> operator to convert objects into integers, and uses that integer to determine where to store the value.</p><pre><code class="code">&gt;&gt;&gt; hash("hello world")
-1500746465</code></pre><h3>About indentation</h3><p>Python uses indentation to delimit blocks of code. A block starts with a line ending in colon, and continues for all lines that have a similar or higher indentation as the next line. For example:</p><pre><code class="code">&gt;&gt;&gt; i = 0
&gt;&gt;&gt; while i &lt; 3:
&gt;&gt;&gt;    print i
&gt;&gt;&gt;    i = i + 1
&gt;&gt;&gt;
0
1
2</code></pre><p>It is common to use four spaces for each level of indentation. It is a good policy not to mix tabs with spaces, which can result in (invisible) confusion.</p><h3><code>for...in</code></h3><div class="inxx">for</div><p>In Python, you can loop over iterable objects:</p><pre><code class="code">&gt;&gt;&gt; a = [0, 1, 'hello', 'python']
&gt;&gt;&gt; for i in a:
        print i
0
1
hello
python</code></pre><p>One common shortcut is <code>xrange</code>, which generates an iterable range without storing the entire list of elements.</p><pre><code class="code">&gt;&gt;&gt; for i in xrange(0, 4):
        print i
0
1
2
3</code></pre><p>This is equivalent to the C/C++/C#/Java syntax:</p><pre><code class="code">for(int i=0; i&lt;4; i=i+1) { print(i); }</code></pre><p>Another useful command is <code>enumerate</code>, which counts while looping:</p><pre><code class="code">&gt;&gt;&gt; a = [0, 1, 'hello', 'python']
&gt;&gt;&gt; for i, j in enumerate(a):
        print i, j
0 0
1 1
2 hello
3 python</code></pre><p>There is also a keyword <code>range(a, b, c)</code> that returns a list of integers starting with the value <code>a</code>, incrementing by <code>c</code>, and ending with the last value smaller than <code>b</code>,  <code>a</code> defaults to 0 and <code>c</code> defaults to 1. <code>xrange</code> is similar but does not actually generate the list, only an iterator over the list; thus it is better for looping.</p><p>You can jump out of a loop using <code>break</code></p><pre><code class="code">&gt;&gt;&gt; for i in [1, 2, 3]:
         print i
         break
1</code></pre><p>You can jump to the next loop iteration without executing the entire code block with <code>continue</code></p><pre><code class="code">&gt;&gt;&gt; for i in [1, 2, 3]:
         print i
         continue
         print 'test'
1
2
3</code></pre><h3><code>while</code></h3><div class="inxx">while</div><p>The <code>while</code> loop in Python works much as it does in many other programming languages, by looping an indefinite number of times and testing a condition before each iteration. If the condition is <code>False</code>, the loop ends.</p><pre><code class="code">&gt;&gt;&gt; i = 0
&gt;&gt;&gt; while i &lt; 10:
        i = i + 1
&gt;&gt;&gt; print i
10</code></pre><p>There is no <code>loop...until</code> construct in Python.</p><h3><code>if...elif...else</code></h3><p><div class="inxx">if</div> <div class="inxx">elif</div> <div class="inxx">else</div> The use of conditionals in Python is intuitive:</p><pre><code class="code">&gt;&gt;&gt; for i in range(3):
&gt;&gt;&gt;     if i == 0:
&gt;&gt;&gt;         print 'zero'
&gt;&gt;&gt;     elif i == 1:
&gt;&gt;&gt;         print 'one'
&gt;&gt;&gt;     else:
&gt;&gt;&gt;         print 'other'
zero
one
other</code></pre><p>"elif" means "else if". Both <code>elif</code> and <code>else</code> clauses are optional. There can be more than one <code>elif</code> but only one <code>else</code> statement. Complex conditions can be created using the <code>not</code>, <code>and</code> and <code>or</code> operators.</p><pre><code class="code">&gt;&gt;&gt; for i in range(3):
&gt;&gt;&gt;     if i == 0 or (i == 1 and i + 1 == 2):
&gt;&gt;&gt;         print '0 or 1'</code></pre><h3><code>try...except...else...finally</code></h3><p><div class="inxx">try</div> <div class="inxx">except</div> <div class="inxx">finally</div> <div class="inxx">Exception</div> Python can throw - pardon, raise - Exceptions:</p><pre><code class="code">&gt;&gt;&gt; try:
&gt;&gt;&gt;     a = 1 / 0
&gt;&gt;&gt; except Exception, e:
&gt;&gt;&gt;     print 'oops: %s' % e
&gt;&gt;&gt; else:
&gt;&gt;&gt;     print 'no problem here'
&gt;&gt;&gt; finally:
&gt;&gt;&gt;     print 'done'
oops: integer division or modulo by zero
done</code></pre><p>If the exception is raised, it is caught by the <code>except</code> clause, which is executed, while the <code>else</code> clause is not. If no exception is raised, the <code>except</code> clause is not executed, but the <code>else</code> one is. The <code>finally</code> clause is always executed.</p><p>There can be multiple <code>except</code> clauses for different possible exceptions:</p><pre><code class="code">&gt;&gt;&gt; try:
&gt;&gt;&gt;     raise SyntaxError
&gt;&gt;&gt; except ValueError:
&gt;&gt;&gt;     print 'value error'
&gt;&gt;&gt; except SyntaxError:
&gt;&gt;&gt;     print 'syntax error'
syntax error</code></pre><p>The <code>else</code> and <code>finally</code> clauses are optional.</p><p>Here is a list of built-in Python exceptions + HTTP (defined by web2py)</p><pre><code class="code">BaseException
 +-- HTTP (defined by web2py)
 +-- SystemExit
 +-- KeyboardInterrupt
 +-- Exception
      +-- GeneratorExit
      +-- StopIteration
      +-- StandardError
      |    +-- ArithmeticError
      |    |    +-- FloatingPointError
      |    |    +-- OverflowError
      |    |    +-- ZeroDivisionError
      |    +-- AssertionError
      |    +-- AttributeError
      |    +-- EnvironmentError
      |    |    +-- IOError
      |    |    +-- OSError
      |    |         +-- WindowsError (Windows)
      |    |         +-- VMSError (VMS)
      |    +-- EOFError
      |    +-- ImportError
      |    +-- LookupError
      |    |    +-- IndexError
      |    |    +-- KeyError
      |    +-- MemoryError
      |    +-- NameError
      |    |    +-- UnboundLocalError
      |    +-- ReferenceError
      |    +-- RuntimeError
      |    |    +-- NotImplementedError
      |    +-- SyntaxError
      |    |    +-- IndentationError
      |    |         +-- TabError
      |    +-- SystemError
      |    +-- TypeError
      |    +-- ValueError
      |    |    +-- UnicodeError
      |    |         +-- UnicodeDecodeError
      |    |         +-- UnicodeEncodeError
      |    |         +-- UnicodeTranslateError
      +-- Warning
           +-- DeprecationWarning
           +-- PendingDeprecationWarning
           +-- RuntimeWarning
           +-- SyntaxWarning
           +-- UserWarning
           +-- FutureWarning
           +-- ImportWarning
           +-- UnicodeWarning</code></pre><p>For a detailed description of each of them, refer to the official Python documentation.</p><p>web2py exposes only one new exception, called <code>HTTP</code>. When raised, it causes the program to return an HTTP error page (for more on this refer to Chapter 4).</p><p>Any object can be raised as an exception, but it is good practice to raise objects that extend one of the built-in exception classes.</p><h3><code>def...return</code></h3><p><div class="inxx">def</div> <div class="inxx">return</div></p><p>Functions are declared using <code>def</code>.  Here is a typical Python function:</p><pre><code class="code">&gt;&gt;&gt; def f(a, b):
        return a + b
&gt;&gt;&gt; print f(4, 2)
6</code></pre><p>There is no need (or way) to specify types of the arguments or the return type(s). In this example, a function <code>f</code> is defined that can take two arguments.</p><p>Functions are the first code syntax feature described in this chapter to introduce the concept of <em>scope</em>, or <em>namespace</em>.  In the above example, the identifiers <code>a</code> and <code>b</code> are undefined outside of the scope of function <code>f</code>:</p><pre><code class="code">&gt;&gt;&gt; def f(a):
        return a + 1
&gt;&gt;&gt; print f(1)
2
&gt;&gt;&gt; print a
Traceback (most recent call last):
  File "&lt;pyshell#22&gt;", line 1, in &lt;module&gt;
    print a
NameError: name 'a' is not defined</code></pre><p>Identifiers defined outside of function scope are accessible within the function; observe how the identifier <code>a</code> is handled in the following code:</p><pre><code class="code">&gt;&gt;&gt; a = 1
&gt;&gt;&gt; def f(b):
        return a + b
&gt;&gt;&gt; print f(1)
2
&gt;&gt;&gt; a = 2
&gt;&gt;&gt; print f(1) # new value of a is used
3
&gt;&gt;&gt; a = 1 # reset a
&gt;&gt;&gt; def g(b):
        a = 2 # creates a new local a
        return a + b
&gt;&gt;&gt; print g(2)
4
&gt;&gt;&gt; print a # global a is unchanged
1</code></pre><p>If <code>a</code> is modified, subsequent function calls will use the new value of the global <code>a</code> because the function definition binds the storage location of the identifier <code>a</code>, not the value of <code>a</code> itself at the time of function declaration; however, if <code>a</code> is assigned-to inside function <code>g</code>, the global <code>a</code> is unaffected because the new local <code>a</code> hides the global value.  The external-scope reference can be used in the creation of <em>closures</em>:</p><pre><code class="code">&gt;&gt;&gt; def f(x):
        def g(y):
            return x * y
        return g
&gt;&gt;&gt; doubler = f(2) # doubler is a new function
&gt;&gt;&gt; tripler = f(3) # tripler is a new function
&gt;&gt;&gt; quadrupler = f(4) # quadrupler is a new function
&gt;&gt;&gt; print doubler(5)
10
&gt;&gt;&gt; print tripler(5)
15
&gt;&gt;&gt; print quadrupler(5)
20</code></pre><p>Function <code>f</code> creates new functions; and note that the scope of the name <code>g</code> is entirely internal to <code>f</code>.  Closures are extremely powerful.</p><p>Function arguments can have default values, and can return multiple results:</p><pre><code class="code">&gt;&gt;&gt; def f(a, b=2):
        return a + b, a - b
&gt;&gt;&gt; x, y = f(5)
&gt;&gt;&gt; print x
7
&gt;&gt;&gt; print y
3</code></pre><p>Function arguments can be passed explicitly by name, and this means that the order of arguments specified in the caller can be different than the order of arguments with which the function was defined:</p><pre><code class="code">&gt;&gt;&gt; def f(a, b=2):
        return a + b, a - b
&gt;&gt;&gt; x, y = f(b=5, a=2)
&gt;&gt;&gt; print x
7
&gt;&gt;&gt; print y
-3</code></pre><p>Functions can also take a runtime-variable number of arguments:</p><pre><code class="code">&gt;&gt;&gt; def f(*a, **b):
        return a, b
&gt;&gt;&gt; x, y = f(3, 'hello', c=4, test='world')
&gt;&gt;&gt; print x
(3, 'hello')
&gt;&gt;&gt; print y
{'c':4, 'test':'world'}</code></pre><p>Here arguments not passed by name (3, 'hello') are stored in the tuple <code>a</code>, and arguments passed by name (<code>c</code> and <code>test</code>) are stored in the dictionary <code>b</code>.</p><p>In the opposite case, a list or tuple can be passed to a function that requires individual positional arguments by unpacking them:</p><pre><code class="code">&gt;&gt;&gt; def f(a, b):
        return a + b
&gt;&gt;&gt; c = (1, 2)
&gt;&gt;&gt; print f(*c)
3</code></pre><p>and a dictionary can be unpacked to deliver keyword arguments:</p><pre><code class="code">&gt;&gt;&gt; def f(a, b):
        return a + b
&gt;&gt;&gt; c = {'a':1, 'b':2}
&gt;&gt;&gt; print f(**c)
3</code></pre><h4><code>lambda</code></h4><div class="inxx">lambda</div><p><code>lambda</code> provides a way to create a very short unnamed function very easily:</p><pre><code class="code">&gt;&gt;&gt; a = lambda b: b + 2
&gt;&gt;&gt; print a(3)
5</code></pre><p>The expression "<code>lambda</code> [a]:[b]" literally reads as "a function with arguments [a] that returns [b]". The <code>lambda</code> expression is itself unnamed, but the function acquires a name by being assigned to identifier <code>a</code>.  The scoping rules for <code>def</code> apply to <code>lambda</code> equally, and in fact the code above, with respect to <code>a</code>, is identical to the function declaration using <code>def</code>:</p><pre><code class="code">&gt;&gt;&gt; def a(b):
        return b + 2
&gt;&gt;&gt; print a(3)
5</code></pre><p>The only benefit of <code>lambda</code> is brevity; however, brevity can be very convenient in certain situations.  Consider a function called <code>map</code> that applies a function to all items in a list, creating a new list:</p><pre><code class="code">&gt;&gt;&gt; a = [1, 7, 2, 5, 4, 8]
&gt;&gt;&gt; map(lambda x: x + 2, a)
[3, 9, 4, 7, 6, 10]</code></pre><p>This code would have doubled in size had <code>def</code> been used instead of <code>lambda</code>. The main drawback of <code>lambda</code> is that (in the Python implementation) the syntax allows only for a single expression; however, for longer functions, <code>def</code> can be used and the extra cost of providing a function name decreases as the length of the function grows. Just like <code>def</code>, <code>lambda</code> can be used to <em>curry</em> functions: new functions can be created by wrapping existing functions such that the new function carries a different set of arguments:</p><pre><code class="code">&gt;&gt;&gt; def f(a, b): return a + b
&gt;&gt;&gt; g = lambda a: f(a, 3)
&gt;&gt;&gt; g(2)
5</code></pre><p>There are many situations where currying is useful, but one of those is directly useful in web2py: caching. Suppose you have an expensive function that checks whether its argument is prime:</p><pre><code class="code">def isprime(number):
    for p in range(2, number):
        if (number % p) == 0:
            return False
    return True</code></pre><p>This function is obviously time consuming.</p><p>Suppose you have a caching function <code>cache.ram</code> that takes three arguments: a key, a function and a number of seconds.</p><pre><code class="code">value = cache.ram('key', f, 60)</code></pre><p>The first time it is called, it calls the function <code>f()</code>, stores the output in a dictionary in memory (let's say "d"), and returns it so that value is:</p><pre><code class="code">value = d['key']=f()</code></pre><p>The second time it is called, if the key is in the dictionary and not older than the number of seconds specified (60), it returns the corresponding value without performing the function call.</p><pre><code class="code">value = d['key']</code></pre><p>How would you cache the output of the function <strong>isprime</strong> for any input? Here is how:</p><pre><code class="code">&gt;&gt;&gt; number = 7
&gt;&gt;&gt; seconds = 60
&gt;&gt;&gt; print cache.ram(str(number), lambda: isprime(number), seconds)
True
&gt;&gt;&gt; print cache.ram(str(number), lambda: isprime(number), seconds)
True</code></pre><p>The output is always the same, but the first time <code>cache.ram</code> is called, <code>isprime</code> is called; the second time it is not.</p><blockquote>Python functions, created with either <code>def</code> or <code>lambda</code> allow re-factoring existing functions in terms of a different set of arguments.
<code>cache.ram</code> and <code>cache.disk</code> are web2py caching functions.</blockquote><h3><code>class</code></h3><div class="inxx">class</div><p>Because Python is dynamically typed, Python classes and objects may seem odd. In fact, you do not need to define the member variables (attributes) when declaring a class, and different instances of the same class can have different attributes. Attributes are generally associated with the instance, not the class (except when declared as "class attributes", which is the same as "static member variables" in C++/Java).</p><p>Here is an example:</p><pre><code class="code">&gt;&gt;&gt; class MyClass(object): pass
&gt;&gt;&gt; myinstance = MyClass()
&gt;&gt;&gt; myinstance.myvariable = 3
&gt;&gt;&gt; print myinstance.myvariable
3</code></pre><p>Notice that <code>pass</code> is a do-nothing command. In this case it is used to define a class <code>MyClass</code> that contains nothing. <code>MyClass()</code> calls the constructor of the class (in this case the default constructor) and returns an object, an instance of the class. The <code>(object)</code> in the class definition indicates that our class extends the built-in <code>object</code> class. This is not required, but it is good practice.</p><p>Here is a more complex class:</p><pre><code class="code">&gt;&gt;&gt; class MyClass(object):
&gt;&gt;&gt;    z = 2
&gt;&gt;&gt;    def __init__(self, a, b):
&gt;&gt;&gt;        self.x = a
&gt;&gt;&gt;        self.y = b
&gt;&gt;&gt;    def add(self):
&gt;&gt;&gt;        return self.x + self.y + self.z
&gt;&gt;&gt; myinstance = MyClass(3, 4)
&gt;&gt;&gt; print myinstance.add()
9</code></pre><p>Functions declared inside the class are methods. Some methods have special reserved names. For example, <code>__init__</code> is the constructor. All variables are local variables of the method except variables declared outside methods. For example, <code>z</code> is a <em>class variable</em>, equivalent to a C++ <em>static member variable</em> that holds the same value for all instances of the class.</p><p>Notice that <code>__init__</code> takes 3 arguments and <code>add</code> takes one, and yet we call them with 2 and 0 arguments respectively. The first argument represents, by convention, the local name used inside the method to refer to the current object. Here we use <code>self</code> to refer to the current object, but we could have used any other name. <code>self</code> plays the same role as <code>*this</code> in C++ or <code>this</code> in Java, but <code>self</code> is not a reserved keyword.</p><p>This syntax is necessary to avoid ambiguity when declaring nested classes, such as a class that is local to a method inside another class.</p><h3>Special attributes, methods and operators</h3><p>Class attributes, methods, and operators starting with a double underscore are usually intended to be private (i.e. to be used internally but not exposed outside the class) although this is a convention that is not enforced by the interpreter.</p><p>Some of them are reserved keywords and have a special meaning.</p><p>Here, as an example, are three of them:</p><ul><li><code>__len__</code></li><li><code>__getitem__</code></li><li><code>__setitem__</code></li></ul><p>They can be used, for example, to create a container object that acts like a list:</p><pre><code class="code">&gt;&gt;&gt; class MyList(object):
&gt;&gt;&gt;     def __init__(self, *a): self.a = list(a)
&gt;&gt;&gt;     def __len__(self): return len(self.a)
&gt;&gt;&gt;     def __getitem__(self, i): return self.a[i]
&gt;&gt;&gt;     def __setitem__(self, i, j): self.a[i] = j
&gt;&gt;&gt; b = MyList(3, 4, 5)
&gt;&gt;&gt; print b[1]
4
&gt;&gt;&gt; b.a[1] = 7
&gt;&gt;&gt; print b.a
[3, 7, 5]</code></pre><p>Other special operators include <code>__getattr__</code> and <code>__setattr__</code>, which define the get and set attributes for the class, and <code>__sum__</code> and <code>__sub__</code>, which overload arithmetic operators. For the use of these operators we refer the reader to more advanced books on this topic. We have already mentioned the special operators <code>__str__</code> and <code>__repr__</code>.</p><h3>File input/output</h3><p><div class="inxx">file.read</div> <div class="inxx">file.write</div></p><p>In Python you can open and write in a file with:</p><pre><code class="code">&gt;&gt;&gt; file = open('myfile.txt', 'w')
&gt;&gt;&gt; file.write('hello world')
&gt;&gt;&gt; file.close()</code></pre><p>Similarly, you can read back from the file with:</p><pre><code class="code">&gt;&gt;&gt; file = open('myfile.txt', 'r')
&gt;&gt;&gt; print file.read()
hello world</code></pre><p>Alternatively, you can read in binary mode with "rb", write in binary mode with "wb", and open the file in append mode "a", using standard C notation.</p><p>The <code>read</code> command takes an optional argument, which is the number of bytes. You can also jump to any location in a file using <code>seek</code>.</p><div class="inxx">file.seek</div><p>You can read back from the file with <code>read</code></p><pre><code class="code">&gt;&gt;&gt; print file.seek(6)
&gt;&gt;&gt; print file.read()
world</code></pre><p>and you can close the file with:</p><pre><code class="code">&gt;&gt;&gt; file.close()</code></pre><p>In the standard distribution of Python, which is known as CPython, variables are reference-counted, including those holding file handles, so CPython knows that when the reference count of an open file handle decreases to zero, the file may be closed and the variable disposed.  However, in other implementations of Python such as PyPy, garbage collection is used instead of reference counting, and this means that it is possible that there may accumulate too many open file handles at one time, resulting in an error before the <em>gc</em> has a chance to close and dispose of them all.  Therefore it is best to explicitly close file handles when they are no longer needed.  <em>web2py</em> provides two helper functions, <code>read_file()</code> and <code>write_file()</code> inside the <code>gluon.fileutils</code> namespace that encapsulate the file access and ensure that the file handles being used are properly closed.</p><blockquote>When using web2py, you do not know where the current directory is, because it depends on how web2py is configured. The variable <code>request.folder</code> contains the path to the current application. Paths can be concatenated with the command <code>os.path.join</code>, discussed below.</blockquote><h3><code>exec</code>, <code>eval</code></h3><p><div class="inxx">exec</div> <div class="inxx">eval</div></p><p>Unlike Java, Python is a truly interpreted language. This means it has the ability to execute Python statements stored in strings. For example:</p><pre><code class="code">&gt;&gt;&gt; a = "print 'hello world'"
&gt;&gt;&gt; exec(a)
'hello world'</code></pre><p>What just happened? The function <code>exec</code> tells the interpreter to call itself and execute the content of the string passed as argument. It is also possible to execute the content of a string within a context defined by the symbols in a dictionary:</p><pre><code class="code">&gt;&gt;&gt; a = "print b"
&gt;&gt;&gt; c = dict(b=3)
&gt;&gt;&gt; exec(a, {}, c)
3</code></pre><p>Here the interpreter, when executing the string <code>a</code>, sees the symbols defined in <code>c</code> (<code>b</code> in the example), but does not see <code>c</code> or <code>a</code> themselves. This is different than a restricted environment, since <code>exec</code> does not limit what the inner code can do; it just defines the set of variables visible to the code.</p><p>A related function is <code>eval</code>, which works very much like <code>exec</code> except that it expects the argument to evaluate to a value, and it returns that value.</p><pre><code class="code">&gt;&gt;&gt; a = "3*4"
&gt;&gt;&gt; b = eval(a)
&gt;&gt;&gt; print b
12</code></pre><h3><code>import</code></h3><p><div class="inxx">import</div> <div class="inxx">random</div> The real power of Python is in its library modules. They provide a large and consistent set of Application Programming Interfaces (APIs) to many system libraries (often in a way independent of the operating system).</p><p>For example, if you need to use a random number generator, you can do:</p><pre><code class="code">&gt;&gt;&gt; import random
&gt;&gt;&gt; print random.randint(0, 9)
5</code></pre><p>This prints a random integer between 0 and 9 (including 9), 5 in the example. The function <code>randint</code> is defined in the module <code>random</code>. It is also possible to import an object from a module into the current namespace:</p><pre><code class="code">&gt;&gt;&gt; from random import randint
&gt;&gt;&gt; print randint(0, 9)</code></pre><p>or import all objects from a module into the current namespace:</p><pre><code class="code">&gt;&gt;&gt; from random import *
&gt;&gt;&gt; print randint(0, 9)</code></pre><p>or import everything in a newly defined namespace:</p><pre><code class="code">&gt;&gt;&gt; import random as myrand
&gt;&gt;&gt; print myrand.randint(0, 9)</code></pre><p>In the rest of this book, we will mainly use objects defined in modules <code>os</code>, <code>sys</code>, <code>datetime</code>, <code>time</code> and <code>cPickle</code>.</p><blockquote>All of the web2py objects are accessible via a module called <code>gluon</code>, and that is the subject of later chapters. Internally, web2py uses many Python modules (for example <code>thread</code>), but you rarely need to access them directly.</blockquote><p>In the following subsections we consider those modules that are most useful.</p><h4><code>os</code></h4><p><div class="inxx">os</div> <div class="inxx">os.path.join</div> <div class="inxx">os.unlink</div></p><p>This module provides an interface to the operating system API. For example:</p><pre><code class="code">&gt;&gt;&gt; import os
&gt;&gt;&gt; os.chdir('..')
&gt;&gt;&gt; os.unlink('filename_to_be_deleted')</code></pre><blockquote>Some of the <code>os</code> functions, such as <code>chdir</code>, MUST NOT be used in web2py because they are not thread-safe.</blockquote><p><code>os.path.join</code> is very useful; it allows the concatenation of paths in an OS-independent way:</p><pre><code class="code">&gt;&gt;&gt; import os
&gt;&gt;&gt; a = os.path.join('path', 'sub_path')
&gt;&gt;&gt; print a
path/sub_path</code></pre><p>System environment variables can be accessed via:</p><pre><code class="code">&gt;&gt;&gt; print os.environ</code></pre><p>which is a read-only dictionary.</p><h4><code>sys</code></h4><p><div class="inxx">sys</div> <div class="inxx">sys.path</div></p><p>The <code>sys</code> module contains many variables and functions, but the one we use the most is <code>sys.path</code>. It contains a list of paths where Python searches for modules. When we try to import a module, Python looks for it in all the folders listed in <code>sys.path</code>. If you install additional modules in some location and want Python to find them, you need to append the path to that location to <code>sys.path</code>.</p><pre><code class="code">&gt;&gt;&gt; import sys
&gt;&gt;&gt; sys.path.append('path/to/my/modules')</code></pre><p>When running web2py, Python stays resident in memory, and there is only one <code>sys.path</code>, while there are many threads servicing the HTTP requests. To avoid a memory leak, it is best to check if a path is already present before appending:</p><pre><code class="code">&gt;&gt;&gt; path = 'path/to/my/modules'
&gt;&gt;&gt; if not path in sys.path:
        sys.path.append(path)</code></pre><h4><code>datetime</code></h4><p><div class="inxx">date</div> <div class="inxx">datetime</div> <div class="inxx">time</div></p><p>The use of the datetime module is best illustrated by some examples:</p><pre><code class="code">&gt;&gt;&gt; import datetime
&gt;&gt;&gt; print datetime.datetime.today()
2008-07-04 14:03:90
&gt;&gt;&gt; print datetime.date.today()
2008-07-04</code></pre><p>Occasionally you may need to time-stamp data based on the UTC time as opposed to local time. In this case you can use the following function:</p><pre><code class="code">&gt;&gt;&gt; import datetime
&gt;&gt;&gt; print datetime.datetime.utcnow()
2008-07-04 14:03:90</code></pre><p>The datetime module contains various classes: date, datetime, time and timedelta. The difference between two date or two datetime or two time objects is a timedelta:</p><pre><code class="code">&gt;&gt;&gt; a = datetime.datetime(2008, 1, 1, 20, 30)
&gt;&gt;&gt; b = datetime.datetime(2008, 1, 2, 20, 30)
&gt;&gt;&gt; c = b - a
&gt;&gt;&gt; print c.days
1</code></pre><p>In web2py, date and datetime are used to store the corresponding SQL types when passed to or returned from the database.</p><h4><code>time</code></h4><div class="inxx">time</div><p>The time module differs from <code>date</code> and <code>datetime</code> because it represents time as seconds from the epoch (beginning of 1970).</p><pre><code class="code">&gt;&gt;&gt; import time
&gt;&gt;&gt; t = time.time()
1215138737.571</code></pre><p>Refer to the Python documentation for conversion functions between time in seconds and time as a <code>datetime</code>.</p><h4><code>cPickle</code></h4><div class="inxx">cPickle</div><p>This is a very powerful module. It provides functions that can serialize almost any Python object, including self-referential objects. For example, let's build a weird object:</p><pre><code class="code">&gt;&gt;&gt; class MyClass(object): pass
&gt;&gt;&gt; myinstance = MyClass()
&gt;&gt;&gt; myinstance.x = 'something'
&gt;&gt;&gt; a = [1 ,2, {'hello':'world'}, [3, 4, [myinstance]]]</code></pre><p>and now:</p><pre><code class="code">&gt;&gt;&gt; import cPickle
&gt;&gt;&gt; b = cPickle.dumps(a)
&gt;&gt;&gt; c = cPickle.loads(b)</code></pre><p>In this example, <code>b</code> is a string representation of <code>a</code>, and <code>c</code> is a copy of <code>a</code> generated by de-serializing <code>b</code>.</p><p>cPickle can also serialize to and de-serialize from a file:</p><pre><code class="code">&gt;&gt;&gt; cPickle.dump(a, open('myfile.pickle', 'wb'))
&gt;&gt;&gt; c = cPickle.load(open('myfile.pickle', 'rb'))</code></pre>