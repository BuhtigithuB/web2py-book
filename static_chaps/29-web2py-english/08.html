<h2>Emails and SMS</h2><div class="inxx">Mail</div><h3>Setting up email</h3><p>Web2py provides the <code>gluon.tools.Mail</code> class to make it easy to send emails using web2py. One can define a mailer with</p><pre><code class="code">from gluon.tools import Mail
mail = Mail()
mail.settings.server = 'smtp.example.com:25'
mail.settings.sender = 'you@example.com'
mail.settings.login = 'username:password'</code></pre><p>Note, if your application uses <code>Auth</code> (discussed in the next chapter), the <code>auth</code> object will include its own mailer in <code>auth.settings.mailer</code>, so you can use that instead as follows:</p><pre><code class="code">mail = auth.settings.mailer
mail.settings.server = 'smtp.example.com:25'
mail.settings.sender = 'you@example.com'
mail.settings.login = 'username:password'</code></pre><p>You need to replace the mail.settings with the proper parameters for your SMTP server. Set <code>mail.settings.login = None</code> if the SMTP server does not require authentication. If you don't want to use TLS, set <code>mail.settings.tls = False</code></p><div class="inxx">email logging</div><blockquote>For debugging purposes you can set
<pre><code class="code">mail.settings.server = 'logging'</code></pre>
and emails will not be sent but logged to the console instead.</blockquote><h4>Configuring email for Google App Engine</h4><div class="inxx">email from GAE</div><p>For sending emails from Google App Engine account:</p><pre><code class="code">mail.settings.server = 'gae'</code></pre><p>At the time of writing web2py does not support attachments and encrypted emails on Google App Engine. Notice cron and scheduler do not work on GAE.</p><h4>x509 and PGP Encryption</h4><p><div class="inxx">PGP</div> <div class="inxx">x509</div></p><p>It is possible to send x509 (SMIME) encrypted emails using the following settings:</p><pre><code class="code">mail.settings.cipher_type = 'x509'
mail.settings.sign = True
mail.settings.sign_passphrase = 'your passphrase'
mail.settings.encrypt = True
mail.settings.x509_sign_keyfile = 'filename.key'
mail.settings.x509_sign_certfile = 'filename.cert'
mail.settings.x509_crypt_certfiles = 'filename.cert'</code></pre><p>It is possible to send PGP encrypted emails. First of all you need to install the python-pyme package. Then you can use GnuPG (GPG) to create the key-files for the sender (take the email-address from mail.settings.sender) and put the files pubring.gpg and  secring.gpg in a directory (e.g. "/home/www-data/.gnupg").</p><p>Use the following settings:</p><pre><code class="code">mail.settings.gpg_home = '/home/www-data/.gnupg/'
mail.settings.cipher_type = 'gpg'
mail.settings.sign = True
mail.settings.sign_passphrase = 'your passphrase'
mail.settings.encrypt = True</code></pre><h3>Sending emails</h3><p><div class="inxx">mail.send</div> <div class="inxx">email html</div> <div class="inxx">email attachments</div></p><p>Once <code>mail</code> is defined, it can be used to send email via:</p><pre><code class="code">mail.send(to=['somebody@example.com'],
          subject='hello',
          # If reply_to is omitted, then mail.settings.sender is used
          reply_to='us@example.com',
          message='hi there')</code></pre><p>Mail returns <code>True</code> if it succeeds in sending the email and <code>False</code> otherwise.  A complete argument list for <code>mail.send()</code> is as follows:</p><pre><code class="code">send(self, to, subject='None', message='None', attachments=[],
     cc=[], bcc=[], reply_to=[], sender=None, encoding='utf-8',
     raw=True, headers={})</code></pre><p>Note, <code>to</code>, <code>cc</code>, and <code>bcc</code> each take a list of email addresses.</p><p><code>sender</code> defaults to <code>None</code> and in this case the sender will be set to <code>mail.settings.sender</code>.</p><p><code>headers</code> is dictionary of headers to refine the headers just before sending the email. For example:</p><pre><code class="code">headers = {'Return-Path' : 'bounces@example.org'}</code></pre><p>Following are some additional examples demonstrating the use of <code>mail.send()</code>.</p><h4>Simple text email</h4><pre><code class="code">mail.send('you@example.com',
  'Message subject',
  'Plain text body of the message')</code></pre><h4>HTML emails</h4><pre><code class="code">mail.send('you@example.com',
  'Message subject',
  '&lt;html&gt;html body&lt;/html&gt;')</code></pre><p>If the email body starts with <code>&lt;html&gt;</code> and ends with <code>&lt;/html&gt;</code>, it will be sent as a HTML email.</p><h4>Combining text and HTML emails</h4><p>The email message can be a tuple (text, html):</p><pre><code class="code">mail.send('you@example.com',
  'Message subject',
  ('Plain text body', '&lt;html&gt;html body&lt;/html&gt;'))</code></pre><h4><code>cc</code> and <code>bcc</code> emails</h4><pre><code class="code">mail.send('you@example.com',
  'Message subject',
  'Plain text body',
  cc=['other1@example.com', 'other2@example.com'],
  bcc=['other3@example.com', 'other4@example.com'])</code></pre><h4>Attachments</h4><pre><code class="code">mail.send('you@example.com',
  'Message subject',
  '&lt;html&gt;&lt;img src="cid:photo" /&gt;&lt;/html&gt;',
  attachments = mail.Attachment('/path/to/photo.jpg', content_id='photo'))</code></pre><h4>Multiple attachments</h4><pre><code class="code">mail.send('you@example.com',
  'Message subject',
  'Message body',
  attachments = [mail.Attachment('/path/to/fist.file'),
                 mail.Attachment('/path/to/second.file')])</code></pre><h3>Sending SMS messages</h3><div class="inxx">SMS</div><p>Sending SMS messages from a web2py application requires a third party service that can relay the messages to the receiver. Usually this is not a free service, but it differs from country to country. We have tried a few of these services with little success. Phone companies block emails originating from these services since they are eventually used as a source of spam.</p><p>A better way is to use the phone companies themselves to relay the SMS. Each phone company has an email address uniquely associated with every cell-phone number, so SMS messages can be sent as emails to the phone number.</p><p>web2py comes with a module to help in this process:</p><pre><code class="code">from gluon.contrib.sms_utils import SMSCODES, sms_email
email = sms_email('1 (111) 111-1111','T-Mobile USA (tmail)')
mail.send(to=email, subject='test', message='test')</code></pre><p>SMSCODES is a dictionary that maps names of major phone companies to the email address postfix. The <code>sms_email</code> function takes a phone number (as a string) and the name of a phone company and returns the email address of the phone.</p><h3>Using the template system to generate messages</h3><div class="inxx">emails</div><p>It is possible to use the template system to generate emails. For example, consider the database table</p><pre><code class="code">db.define_table('person', Field('name'))</code></pre><p>where you want to send to every person in the database the following message, stored in a view file "message.html":</p><pre><code class="code">Dear {{=person.name}},
You have won the second prize, a set of steak knives.</code></pre><p>You can achieve this in the following way</p><pre><code class="code">for person in db(db.person).select():
    context = dict(person=person)
    message = response.render('message.html', context)
    mail.send(to=['who@example.com'],
              subject='None',
              message=message)</code></pre><p>Most of the work is done in the statement</p><pre><code class="code">response.render('message.html', context)</code></pre><p>It renders the view "message.html" with the variables defined in the dictionary "context", and it returns a string with the rendered email text. The context is a dictionary that contains variables that will be visible to the template file.</p><p>If the message starts with <code>&lt;html&gt;</code> and ends with <code>&lt;/html&gt;</code>, the email will be an HTML email.</p><p>Note, if you want to include a link back to your website in an HTML email, you can use the <code>URL</code> function. However, by default, the <code>URL</code> function generates a relative URL, which will not work from an email. To generate an absolute URL, you need to specify the <code>scheme</code> and <code>host</code> arguments to the URL function. For example:</p><pre><code class="code">&lt;a href="{{=URL(..., scheme=True, host=True)}}"&gt;Click here&lt;/a&gt;</code></pre><p>or</p><pre><code class="code">&lt;a href="{{=URL(..., scheme='http', host='www.site.com')}}"&gt;Click here&lt;/a&gt;</code></pre><p>The same mechanism that is used to generate email text can also be used to generate SMS messages or any other type of message based on a template.</p><h3>Sending messages using a background task</h3><p>The operation of sending an email message can take up to several seconds because of the need to log into and communicate with a potentially remote SMTP server. To keep the user from having to wait for the send operation to complete, it is sometimes desirable to queue the email to be sent at a later time via a background task. As described in Chapter 4, this can be done by setting up a homemade task queue or using the web2py scheduler. Here we provide an example using a homemade task queue.</p><p>First, in a model file within our application, we set up a database model to store our email queue:</p><pre><code class="code">db.define_table('queue',
    Field('status'),
    Field('email'),
    Field('subject'),
    Field('message'))</code></pre><p>From a controller, we can then enqueue messages to be sent by:</p><pre><code class="code">db.queue.insert(status='pending',
                email='you@example.com',
                subject='test',
                message='test')</code></pre><p>Next, we need a background processing script that reads the queue and sends the emails:</p><pre><code class="code">## in file /app/private/mail_queue.py
import time
while True:
    rows = db(db.queue.status=='pending').select()
    for row in rows:
        if mail.send(to=row.email,
            subject=row.subject,
            message=row.message):
            row.update_record(status='sent')
        else:
            row.update_record(status='failed')
        db.commit()
    time.sleep(60) # check every minute</code></pre><p>Finally, as described in Chapter 4, we need to run the mail_queue.py script as if it were inside a controller in our app:</p><pre><code class="code">python web2py.py -S app -M -R applications/app/private/mail_queue.py</code></pre><p>where <code>-S app</code> tells web2py to run "mail_queue.py" as "app", <code>-M</code> tells web2py to execute models.</p><p>Here we assume that the <code>mail</code> object referenced in "mail_queue.py" is defined in a model file in our app and is therefore available in the "mail_queue.py" script because of the <code>-M</code> option. Also notice that it is important to commit any change as soon as possible in order not to lock the database to other concurrent processes.</p><p>As noted in Chapter 4, this type of background process should not be executed via cron (except perhaps for cron @reboot) because you need to be sure that no more than one instance is running at the same time.</p><p>Note, one drawback to sending email via a background process is that it makes it difficult to provide feedback to the user in case the email fails. If email is sent directly from the controller action, you can catch any errors and immediately return an error message to the user. With a background process, however, the email is sent asynchronously, after the controller action has already returned its response, so it becomes more complex to notify the user of a failure.</p><h3>Reading and managing email boxes (Experimental)</h3><p>The <code>IMAP</code> adapter is intended as an interface with email IMAP servers to perform simple queries in the web2py <code>DAL</code> query syntax, so email read, search and other related IMAP mail services (as those implemented by brands like Google(r), and Yahoo(r) can be managed from web2py applications.</p><p>It creates its table and field names "statically", meaning that the developer should leave the table and field definitions to the DAL instance by calling the adapter <code>.define_tables()</code> method. The tables are defined with the IMAP server mailbox list information.</p><h4>Connection</h4><p>For a single mail account, this is the code recommended to start IMAP support at the app's model</p><pre><code class="code"># Replace user, password, server and port in the connection string
# Set port as 993 for SSL support
imapdb = DAL("imap://user:password@server:port", pool_size=1)
imapdb.define_tables()</code></pre><p>Note that <code>&lt;imapdb&gt;.define_tables()</code> returns a dictionary of strings mapping DAL tablenames to the server mailbox names with the structure <code>{&lt;tablename&gt;: &lt;server mailbox name&gt;, ...}</code>, so you can get the actual mailbox name in the IMAP server.</p><p>If you want to set you own tablename/mailbox configuration and skip the automatic name configuration, you can pass a custom dictionary to the adapter in this way:</p><pre><code class="code">imapdb.define_tables({"inbox":"MAILBOX", "trash":"SPAM"})</code></pre><p>To handle the different native mailbox names for the user interface,  the following attributes give access to the adapter auto mailbox mapped names (which native mailbox has what table name and vice versa):</p><table><tbody><tr class="first"><td><strong>Attribute</strong></td><td><strong>Type</strong></td><td><strong>Format</strong></td></tr><tr class="even"><td>imapdb.mailboxes</td><td>dict</td><td><code>{&lt;tablename&gt;: &lt;server native name&gt;, ...}</code></td></tr><tr><td>imapdb.&lt;table&gt;.mailbox</td><td>string</td><td><code>"server native name"</code></td></tr></tbody></table><p>The first can be useful to retrieve IMAP query sets by the native email service mailbox</p><pre><code class="code"># mailbox is a string containing the actual mailbox name
tablenames = dict([(v,k) for k,v in imapdb.mailboxes.items()])
myset = imapdb(imapdb[tablenames[mailbox]])</code></pre><h4>Fetching mail and updating flags</h4><p>Here's a list of IMAP commands you could use in the controller. For the examples, it's assumed that your IMAP service has a mailbox named <code>INBOX</code>, which is the case for Gmail(r) accounts.</p><p>To count today's unseen messages smaller than 6000 octets from the inbox mailbox do</p><pre><code class="code">q = imapdb.INBOX.seen == False
q &amp;= imapdb.INBOX.created == request.now.date()
q &amp;= imapdb.INBOX.size &lt; 6000
unread = imapdb(q).count()</code></pre><p>You can fetch the previous query messages with</p><pre><code class="code">rows = imapdb(q).select()</code></pre><p>Usual query operators are implemented, including belongs</p><pre><code class="code">messages = imapdb(imapdb.INBOX.uid.belongs(&lt;uid sequence&gt;)).select()</code></pre><p><strong>Note</strong>: It's strongly advised that you keep the query results below a given data size threshold to avoid jamming the server with large select commands.</p><p>To perform faster email queries, it is recommended to pass a filtered set of fields:</p><pre><code class="code">fields = ["INBOX.uid", "INBOX.sender", "INBOX.subject", "INBOX.created"]
rows = imapdb(q).select(*fields)</code></pre><p>The adapter knows when to retrieve partial message payloads (fields like <code>content</code>, <code>size</code> and <code>attachments</code> require retrieving the complete message data)</p><p>It is possible to filter query select results with limitby and sequences of mailbox fields</p><pre><code class="code"># Replace the arguments with actual values
myset.select(&lt;fields sequence&gt;, limitby=(&lt;int&gt;, &lt;int&gt;))</code></pre><p>Say you want to have an app action show a mailbox message. First we retrieve the message (If your IMAP service supports it, fetch messages by <code>uid</code> field to avoid using old sequence references).</p><pre><code class="code">mymessage = imapdb(imapdb.INBOX.uid == &lt;uid&gt;).select().first()</code></pre><p>Otherwise, you can use the message's <code>id</code>.</p><pre><code class="code">mymessage = imapdb.INBOX[&lt;id&gt;]</code></pre><p>Note that using the message's id as reference is not recommended, because sequence numbers can change with mailbox maintenance operations as message deletions. If you still want to record references to messages (i.e. in another database's record field), the solution is to use the uid field as reference whenever supported, and retrieve each message with the recorded value.</p><p>Finally, add something like the following to show the message content in a view</p><pre><code class="code">{{=P(T("Message from"), " ", mymessage.sender)}}
{{=P(T("Received on"), " ", mymessage.created)}}
{{=H5(mymessage.subject)}}
{{for text in mymessage.content:}}
  {{=DIV(text)}}
  {{=TR()}}
{{pass}}</code></pre><p>As expected, we can take advantage of the <code>SQLTABLE</code> helper to build message lists in views</p><pre><code class="code">{{=SQLTABLE(myset.select(), linkto=URL(...))}}</code></pre><p>And of course, it's possible to feed a form helper with the appropriate sequence id value</p><pre><code class="code">{{=SQLFORM(imapdb.INBOX, &lt;message id&gt;, fields=[...])}}</code></pre><p>The current adapter supported fields available are the following:</p><table><tbody><tr class="first"><td><strong>Field</strong></td><td><strong>Type</strong></td><td><strong>Description</strong></td></tr><tr class="even"><td>uid</td><td>string</td><td></td></tr><tr><td>answered</td><td>boolean</td><td>Flag</td></tr><tr class="even"><td>created</td><td>date</td><td></td></tr><tr><td>content</td><td>list:string</td><td>A list of text or html parts</td></tr><tr class="even"><td>to</td><td>string</td><td></td></tr><tr><td>cc</td><td>string</td><td></td></tr><tr class="even"><td>bcc</td><td>string</td><td></td></tr><tr><td>size</td><td>integer</td><td>the amount of octets of the message*</td></tr><tr class="even"><td>deleted</td><td>boolean</td><td>Flag</td></tr><tr><td>draft</td><td>boolean</td><td>Flag</td></tr><tr class="even"><td>flagged</td><td>boolean</td><td>Flag</td></tr><tr><td>sender</td><td>string</td><td></td></tr><tr class="even"><td>recent</td><td>boolean</td><td>Flag</td></tr><tr><td>seen</td><td>boolean</td><td>Flag</td></tr><tr class="even"><td>subject</td><td>string</td><td></td></tr><tr><td>mime</td><td>string</td><td>The mime header declaration</td></tr><tr class="even"><td>email</td><td>string</td><td>The complete RFC822 message**</td></tr><tr><td>attachments</td><td>list</td><td>Each non text decoded part as dictionary</td></tr><tr class="even"><td>encoding</td><td>string</td><td>The message's main detected charset</td></tr></tbody></table><p>*At the application side it is measured as the length of the RFC822 message string</p><p><strong>WARNING</strong>: As row id's are mapped to email sequence numbers, make sure your IMAP client web2py app does not delete messages during select or update actions, to prevent updating or deleting different messages.</p><p>Standard <code>CRUD</code> database operations are not supported. There's no way of defining custom fields or tables and make inserts with different data types because updating mailboxes with IMAP services is usually reduced to posting flag updates to the server. Still, it's possible to access those flag commands through the DAL IMAP interface</p><p>To mark last query messages as seen</p><pre><code class="code">seen = imapdb(q).update(seen=True)</code></pre><p>Here we delete messages in the IMAP database that have mails from mr. Gumby</p><pre><code class="code">deleted = 0
for tablename in imapdb.tables():
    deleted += imapdb(imapdb[tablename].sender.contains("gumby")).delete()</code></pre><p>It is possible also to mark messages for deletion instead of erasing them directly with</p><pre><code class="code">myset.update(deleted=True)</code></pre><div class="inxx">IMAP</div>