<h2>The core</h2><h3>Command line options</h3><p>It is possible to skip the GUI and start web2py directly from the command line by typing something like:</p><div class="inxx">password</div><pre><code class="code">python web2py.py -a 'your password' -i 127.0.0.1 -p 8000</code></pre><p>When web2py starts, it creates a file called "parameters_8000.py" where it stores the hashed password. If you use "&lt;ask&gt;" as the password, web2py prompts you for it.</p><p>For additional security, you can start web2py with:</p><pre><code class="code">python web2py.py -a '&lt;recycle&gt;' -i 127.0.0.1 -p 8000</code></pre><p>In this case web2py reuses the previously stored hashed password. If no password is provided, or if the "parameters_8000.py" file is deleted, the web-based administrative interface is disabled.</p><div class="inxx">PAM</div><p>On some Unix/Linux systems, if the password is</p><pre><code class="code">&lt;pam_user:some_user&gt;</code></pre><p>web2py uses the PAM password of the Operating System account of <code>some_user</code> to authenticate the administrator, unless blocked by the PAM configuration.</p><blockquote>web2py normally runs with CPython (the C implementation of the Python interpreter created by Guido van Rossum), but it can also run with PyPy and Jython. The latter possibility allows the use of web2py in the context of a Java EE infrastructure. To use Jython, simply replace "python web2py.py ..." with "jython web2py.py". Details about installing Jython, zxJDBC modules required to access the databases can be found in Chapter 14.</blockquote><p>The "web2py.py" script can take many command-line arguments specifying the maximum number of threads, enabling of SSL, etc. For a complete list type:</p><div class="inxx">command line</div><pre><code class="code">&gt;&gt;&gt; python web2py.py -h
Usage: python web2py.py

web2py Web Framework startup script. ATTENTION: unless a password
is specified (-a 'passwd'), web2py will attempt to run a GUI.
In this case command line options are ignored.

Options:
  --version             show program's version number and exit
  -h, --help            show this help message and exit
  -i IP, --ip=IP        IP address of the server (e.g., 127.0.0.1 or ::1);
                        Note: This value is ignored when using the
                        'interfaces' option.
  -p PORT, --port=PORT  port of server (8000)
  -a PASSWORD, --password=PASSWORD
                        password to be used for administration (use -a
                        "&lt;recycle&gt;" to reuse the last password))
  -c SSL_CERTIFICATE, --ssl_certificate=SSL_CERTIFICATE
                        file that contains ssl certificate
  -k SSL_PRIVATE_KEY, --ssl_private_key=SSL_PRIVATE_KEY
                        file that contains ssl private key
  --ca-cert=SSL_CA_CERTIFICATE
                        Use this file containing the CA certificate to
                        validate X509 certificates from clients
  -d PID_FILENAME, --pid_filename=PID_FILENAME
                        file to store the pid of the server
  -l LOG_FILENAME, --log_filename=LOG_FILENAME
                        file to log connections
  -n NUMTHREADS, --numthreads=NUMTHREADS
                        number of threads (deprecated)
  --minthreads=MINTHREADS
                        minimum number of server threads
  --maxthreads=MAXTHREADS
                        maximum number of server threads
  -s SERVER_NAME, --server_name=SERVER_NAME
                        server name for the web server
  -q REQUEST_QUEUE_SIZE, --request_queue_size=REQUEST_QUEUE_SIZE
                        max number of queued requests when server unavailable
  -o TIMEOUT, --timeout=TIMEOUT
                        timeout for individual request (10 seconds)
  -z SHUTDOWN_TIMEOUT, --shutdown_timeout=SHUTDOWN_TIMEOUT
                        timeout on shutdown of server (5 seconds)
  --socket-timeout=SOCKET_TIMEOUT
                        timeout for socket (5 second)
  -f FOLDER, --folder=FOLDER
                        location of the applications folder (also known as directory) 
  -v, --verbose         increase --test verbosity
  -Q, --quiet           disable all output
  -D DEBUGLEVEL, --debug=DEBUGLEVEL
                        set debug output level (0-100, 0 means all, 100 means
                        none; default is 30)
  -S APPNAME, --shell=APPNAME
                        run web2py in interactive shell or IPython (if
                        installed) with specified appname (if app does not
                        exist it will be created). APPNAME like a/c/f (c,f
                        optional)
  -B, --bpython         run web2py in interactive shell or bpython (if
                        installed) with specified appname (if app does not
                        exist it will be created). Use combined with --shell
  -P, --plain           only use plain python shell; should be used with
                        --shell option
  -M, --import_models   auto import model files; default is False; should be
                        used with --shell option
  -R PYTHON_FILE, --run=PYTHON_FILE
                        run PYTHON_FILE in web2py environment; should be used
                        with --shell option
  -K SCHEDULER, --scheduler=SCHEDULER
                        run scheduled tasks for the specified apps: expects a
                        list of app names as -K app1,app2,app3 or a list of
                        app:groups as -K app1:group1:group2,app2:group1 to
                        override specific group_names. (only strings, no
                        spaces allowed. Requires a scheduler defined in the
                        models
  -X, --with-scheduler  run schedulers alongside webserver
  -T TEST_PATH, --test=TEST_PATH
                        run doctests in web2py environment; TEST_PATH like
                        a/c/f (c,f optional)
  -W WINSERVICE, --winservice=WINSERVICE 
                        -W install|start|stop as Windows service. 
                        However, this is deprecated. Please see 
                        use of nssm in the Deployment Recipes chapter
  -C, --cron            trigger a cron run manually; usually invoked from a
                        system crontab
  --softcron            triggers the use of softcron
  -Y, --run-cron        start the background cron process
  -J, --cronjob         identify cron-initiated command
  -L CONFIG, --config=CONFIG
                        config file
  -F PROFILER_FILENAME, --profiler=PROFILER_FILENAME
                        profiler filename
  -t, --taskbar         use web2py gui and run in taskbar (system tray)
  --nogui               text-only, no GUI
  -A ARGS, --args=ARGS  should be followed by a list of arguments to be passed
                        to script, to be used with -S, -A must be the last
                        option
  --no-banner           Do not print header banner
  --interfaces=INTERFACES
                        listen on multiple addresses: "ip1:port1:key1:cert1:ca
                        _cert1;ip2:port2:key2:cert2:ca_cert2;..."
                        (:key:cert:ca_cert optional; no spaces; IPv6 addresses
                        must be in square [] brackets)
  --run_system_tests    runs web2py tests</code></pre><p>Lower-case options are used to configure the web server. The <code>-L</code> option tells web2py to read configuration options from a file, <code>-W</code> installs web2py as a windows service, while <code>-S</code>, <code>-P</code> and <code>-M</code> options start an interactive Python shell. The <code>-T</code> option finds and runs controller doctests in a web2py execution environment. For example, the following example runs doctests from all controllers in the "welcome" application:</p><pre><code class="code">python web2py.py -vT welcome</code></pre><p>if you run web2py as a Windows Service, <code>-W</code>,  it is not convenient to pass the configuration using command line arguments. For this reason, in the web2py folder there is a sample "options_std.py" configuration file for the internal web server:</p><pre><code class="code">import socket
import os

ip = '0.0.0.0'
port = 80
interfaces = [('0.0.0.0', 80)]
               #,('0.0.0.0',443,'ssl_private_key.pem','ssl_certificate.pem')]
password = '&lt;recycle&gt;'  # ## &lt;recycle&gt; means use the previous password
pid_filename = 'httpserver.pid'
log_filename = 'httpserver.log'
profiler_filename = None
ssl_certificate = None  # 'ssl_certificate.pem'  # ## path to certificate file
ssl_private_key = None  # 'ssl_private_key.pem'  # ## path to private key file
#numthreads = 50 # ## deprecated; remove
minthreads = None
maxthreads = None
server_name = socket.gethostname()
request_queue_size = 5
timeout = 30
shutdown_timeout = 5
folder = os.getcwd()
extcron = None
nocron = None</code></pre><p>This file contains the web2py defaults. If you edit this file, you need to import it explicitly with the <code>-L</code> command-line option. It only works if you run web2py as a Windows Service.</p><h3>Workflow</h3><p>The web2py workflow is the following:</p><ul><li>An HTTP requests arrives to the web server (the built-in Rocket server or a different server connected to web2py via WSGI or another adapter). The web server handles each request in its own thread, in parallel.</li><li>The HTTP request header is parsed and passed to the dispatcher (explained later in this chapter).</li><li>The dispatcher decides which of the installed application will handle the request and maps the PATH_INFO in the URL into a function call. Each URL corresponds to one function call.</li><li>Requests for files in the static folder are handled directly, and large files are automatically streamed to the client.</li><li>Requests for anything but a static file are mapped into an action (i.e. a function in a controller file, in the requested application).</li><li>Before calling the action, a few things happen: if the request header contains a session cookie for the app, the session object is retrieved; if not, a session id is created (but the session file is not saved until later); an execution environment for the request is created; models are executed in this environment.</li><li>Finally the controller action is executed in the pre-built environment.</li><li>If the action returns a string, this is returned to the client (or if the action returns a web2py HTML helper object, it is serialized and returned to the client).</li><li>If the action returns an iterable, this is used to loop and stream the data to the client.</li><li>If the action returns a dictionary, web2py tries to locate a view to render the dictionary. The view must have the same name as the action (unless specified otherwise) and the same extension as the requested page (defaults to .html); on failure, web2py may pick up a generic view (if available and if enabled). The view sees every variable defined in the models as well as those in the dictionary returned by the action, but does not see global variables defined in the controller.</li><li>The entire user code is executed in a single database transaction unless specified otherwise.</li><li>If the user code succeeds, the transaction is committed.</li><li>If the user code fails, the traceback is stored in a ticket, and a ticket ID is issued to the client. Only the system administrator can search and read the tracebacks in tickets.</li></ul><p>There are some caveats to keep in mind:</p><ul><li>Models in the same folder/subfolder are executed in alphabetical order.</li><li>Any variable defined in a model will be visible to other models following alphabetically, to the controllers, and to the views.</li></ul><div class="inxx">models_to_run</div><ul><li>Models in subfolders are executed conditionally. For example, if the user has requested "/a/c/f" where "a" is the application, "c" is the controller, and "f" is the function (action), then the following models are executed:</li></ul><pre><code>applications/a/models/*.py
applications/a/models/c/*.py
applications/a/models/c/f/*.py</code></pre> This behaviour is enforced by default. Altering the <code>response.models_to_run</code> regex list, you can force the behaviour you want. Look at <a href="#markmin_response_models_to_run">response</a> for additional details<ul><li>The requested controller is executed and the requested function is called. This means all top-level code in the controller is also executed at every request for that controller.</li><li>The view is only called if the action returns a dictionary.</li><li>If a view is not found, web2py tries to use a generic view. By default, generic views are disabled, although the 'welcome' app includes a line in /models/db.py to enable them on localhost only. They can be enabled per extension type and per action (using <code>response.generic_patterns</code>). In general, generic views are a development tool and typically should not be used in production. If you want some actions to use a generic view, list those actions in <code>response.generic_patterns</code> (discussed in more detail in the chapter on Services).</li></ul><p>The possible behaviors of an action are the following:</p><p><strong>Return a string</strong></p><pre><code>def index(): return 'data'</code></pre><p><strong>Return a dictionary for a view</strong>:</p><pre><code>def index(): return dict(key='value')</code></pre><p><strong>Return all local variables</strong>:</p><pre><code>def index(): return locals()</code></pre><p><strong>Redirect the user to another page</strong>:</p><pre><code>def index(): redirect(URL('other_action'))</code></pre><p><strong>Return an HTTP page other than "200 OK"</strong>:</p><pre><code>def index(): raise HTTP(404)</code></pre><p><strong>Return a helper</strong> (for example, a FORM):</p><pre><code>def index(): return FORM(INPUT(_name='test'))</code></pre><p>(this is mostly used for Ajax callbacks and components, see chapter 12)</p><p>When an action returns a dictionary, it may contain code generated by helpers, including forms based on database tables or forms from a factory, for example:</p><pre><code>def index(): return dict(form=SQLFORM.factory(Field('name')).process())</code></pre><p>(all forms generated by web2py use postbacks, see chapter 3)</p><h3>Dispatching</h3><p><div class="inxx">url mapping</div> <div class="inxx">dispatching</div></p><p>web2py maps a URL of the form:</p><pre><code class="code">http://127.0.0.1:8000/a/c/f.html</code></pre><p>to the function <code>f()</code> in controller "c.py" in application "a". If <code>f</code> is not present, web2py defaults to the <code>index</code> controller function. If <code>c</code> is not present, web2py defaults to the "default.py" controller, and if <code>a</code> is not present, web2py defaults to the <code>init</code> application. If there is no <code>init</code> application, web2py tries to run the <code>welcome</code> application. This is shown schematically in the image below:</p><p><p style="text-align:center"><img src="http://127.0.0.1:8000/web2py_book/default/image/29/en5700.png" alt="image" style="width:480px" /></p></p><p>By default, any new request also creates a new session. In addition, a session cookie is returned to the client browser to keep track of the session.</p><p>The extension <code>.html</code> is optional; <code>.html</code> is assumed as default. The extension determines the extension of the view that renders the output of the controller function <code>f()</code>. It allows the same content to be served in multiple formats (html, xml, json, rss, etc.).</p><blockquote>Functions that take arguments or start with a double underscore are not publicly exposed and can only be called by other functions.</blockquote><div class="inxx">static files</div><p>There is an exception made for URLs of the form:</p><pre><code class="code">http://127.0.0.1:8000/a/static/filename</code></pre><p>There is no controller called "static". web2py interprets this as a request for the file called "filename" in the subfolder "static" of the application "a".</p><p><div class="inxx">PARTIAL CONTENT</div> <div class="inxx">IF_MODIFIED_SINCE</div> When static files are downloaded, web2py does not create a session, nor does it issue a cookie or execute the models. web2py always streams static files in chunks of 1MB, and sends PARTIAL CONTENT when the client sends a RANGE request for a subset of the file.</p><p>web2py also supports the IF_MODIFIED_SINCE protocol, and does not send the file if it is already stored in the browser's cache and if the file has not changed since that version.</p><p>When linking to an audio or video file in the static folder, if you want to force the browser to download the file instead of streaming the audio/video via a media player, add <code>?attachment</code> to the URL. This tells web2py to set the <code>Content-Disposition</code> header of the HTTP response to "attachment". For example:</p><pre><code class="code">&lt;a href="/app/static/my_audio_file.mp3?attachment"&gt;Download&lt;/a&gt;</code></pre><p>When the above link is clicked, the browser will prompt the user to download the MP3 file rather than immediately streaming the audio. (As discussed <a href="#markmin_response">below</a>, you can also set HTTP response headers directly by assigning a <code>dict</code> of header names and their values to <code>response.headers</code>.)</p><p><div class="inxx">request.application</div> <div class="inxx">request.controller</div> <div class="inxx">request.function</div> <div class="inxx">GET</div> <div class="inxx">POST</div> <div class="inxx">request.args</div> web2py maps GET/POST requests of the form:</p><pre><code class="code">http://127.0.0.1:8000/a/c/f.html/x/y/z?p=1&amp;q=2</code></pre><p>to function <code>f</code> in controller "c.py" in application <code>a</code>, and it stores the URL parameters in the <code>request</code> variable as follows:</p><pre><code class="code">request.args = ['x', 'y', 'z']</code></pre><p>and:</p><pre><code class="code">request.vars = {'p':1, 'q':2}</code></pre><p>and:</p><pre><code class="code">request.application = 'a'
request.controller = 'c'
request.function = 'f'</code></pre><p>In the above example, both <code>request.args[i]</code> and <code>request.args(i)</code> can be used to retrieve the i-th element of the <code>request.args</code>, but while the former raises an exception if the list does not have such an index, the latter returns None in this case.</p><div class="inxx">request.url</div><pre><code class="code">request.url</code></pre><p>stores the full URL of the current request (not including GET variables).</p><p><div class="inxx">request.ajax</div> <div class="inxx">request.cid</div></p><pre><code class="code">request.ajax</code></pre><p>defaults False but it is True if web2py determines that the action was called by an Ajax request.</p><p>If the request is an Ajax request and it is initiated by a web2py component, the name of the component can be found in:</p><pre><code class="code">request.cid</code></pre><p>Components are discussed in more detail in Chapter 12.</p><p><div class="inxx">request.get_vars</div> <div class="inxx">request.post_vars</div> <div class="inxx">request.vars</div> If the HTTP request is a GET, then <code>request.env.request_method</code> is set to "GET"; if it is a POST, <code>request.env.request_method</code> is set to "POST". URL query variables are stored in <code>request.get_vars</code>. <code>request.post_vars</code> contains all parameters passed into the body of a request (usually a POST, PUT or a DELETE one). The <code>request.vars</code> Storage dictionary contains both of them (<code>get_vars</code> and <code>post_vars</code> get merged)</p><p>web2py stores WSGI and web2py environment variables in <code>request.env</code>, for example:</p><pre><code class="code">request.env.path_info = 'a/c/f'</code></pre><p>and HTTP headers into environment variables, for example:</p><pre><code class="code">request.env.http_host = '127.0.0.1:8000'</code></pre><blockquote>Notice that web2py validates all URLs to prevent directory traversal attacks.</blockquote><p>URLs are only allowed to contain alphanumeric characters, underscores, and slashes; the <code>args</code> may contain non-consecutive dots. Spaces are replaced by underscores before validation. If the URL syntax is invalid, web2py returns an HTTP 400 error message<sup>[<a href="/web2py_book/default/reference/29/http-w" target="_blank">http-w</a>]</sup> <sup>[<a href="/web2py_book/default/reference/29/http-o" target="_blank">http-o</a>]</sup> .</p><p>If the URL corresponds to a request for a static file, web2py simply reads and returns (streams) the requested file.</p><p>If the URL does not request a static file, web2py processes the request in the following order:</p><ul><li>Parses cookies.</li><li>Creates an environment in which to execute the function.</li><li>Initializes <code>request</code>, <code>response</code>, <code>cache</code>.</li><li>Opens the existing <code>session</code> or creates a new one.</li><li>Executes the models belonging to the requested application.</li><li>Executes the requested controller action function.</li><li>If the function returns a dictionary, executes the associated view.</li><li>On success, commits all open transactions.</li><li>Saves the session.</li><li>Returns an HTTP response.</li></ul><p>Notice that the controller and the view are executed in different copies of the same environment; therefore, the view does not see the controller, but it sees the models and it sees the variables returned by the controller action function.</p><p>If an exception (other than HTTP) is raised, web2py does the following:</p><ul><li>Stores the traceback in an error file and assigns a ticket number to it.</li><li>Rolls back all open database transactions.</li><li>Returns an error page reporting the ticket number.</li></ul><p>If the exception is an <code>HTTP</code> exception, this is assumed to be the intended behavior (for example, an <code>HTTP</code> redirect), and all open database transactions are committed. The behavior after that is specified by the <code>HTTP</code> exception itself. The <code>HTTP</code> exception class is not a standard Python exception; it is defined by web2py.</p><h3>Libraries</h3><p>The web2py libraries are exposed to the user applications as global objects. For example (<code>request</code>, <code>response</code>, <code>session</code>, <code>cache</code>), classes (helpers,  validators, DAL API), and functions (<code>T</code> and <code>redirect</code>).</p><p>These objects are defined in the following core files:</p><pre><code class="code">web2py.py
gluon/__init__.py    gluon/highlight.py   gluon/restricted.py  gluon/streamer.py
gluon/admin.py       gluon/html.py        gluon/rewrite.py     gluon/template.py
gluon/cache.py       gluon/http.py        gluon/rocket.py      gluon/storage.py
gluon/cfs.py         gluon/import_all.py  gluon/sanitizer.py   gluon/tools.py
gluon/compileapp.py  gluon/languages.py   gluon/serializers.py gluon/utils.py
gluon/contenttype.py gluon/main.py        gluon/settings.py    gluon/validators.py
gluon/dal.py         gluon/myregex.py     gluon/shell.py       gluon/widget.py
gluon/decoder.py     gluon/newcron.py     gluon/sql.py         gluon/winservice.py
gluon/fileutils.py   gluon/portalocker.py gluon/sqlhtml.py     gluon/xmlrpc.py
gluon/globals.py     gluon/reserved_sql_keywords.py</code></pre><blockquote>Notice that many of these modules, specifically <code>dal</code> (the Database Abstraction Layer), <code>template</code> (the template language), <code>rocket</code> (the web server), and
<code>html</code> (the helpers) have no dependencies and can be used outside of web2py.</blockquote><p>The tar gzipped scaffolding app that ship with web2py is</p><pre><code class="code">welcome.w2p</code></pre><p>This is created upon installation and overwritten on upgrade.</p><blockquote>The first time you start web2py, two new folders are created: deposit and applications. The deposit folder is used as temporary storage for installing and uninstalling applications.

The first time you start web2py and after an upgrade, the "welcome" app is zipped into a "welcome.w2p" file to be used as a scaffolding app.</blockquote><p>When web2py is upgraded it comes with a file called "NEWINSTALL". If web2py finds this file, it understands an upgrade was performed, hence it removed the file and creates a new "welcome.w2p".</p><p>The current web2py version is stored in the field "VERSION" and it follows standard semantic versioning notation where the build id is the build timestamp.</p><p>web2py unit-tests are in</p><pre><code class="code">gluon/tests/</code></pre><p>There are handlers for connecting with various web servers:</p><pre><code class="code">cgihandler.py       # discouraged
gaehandler.py       # for Google App Engine
fcgihandler.py      # for FastCGI
wsgihandler.py      # for WSGI
isapiwsgihandler.py # for IIS
modpythonhandler.py # deprecated</code></pre><p>("fcgihandler" calls  "gluon/contrib/gateways/fcgi.py" developed by Allan Saddi) and</p><pre><code>anyserver.py</code></pre><p>which is a script to interface with many different web servers, described in Chapter 13.</p><p>There are three example files in the "examples" directory:</p><pre><code class="code">options_std.py
routes.parametric.example.py
routes.patterns.example.py</code></pre><p>They are all meant to be copied to the root dir (where web2py.py or web2py.exe is) and edited according to your own preferences. The former is an optional configuration file that can be passed to web2py.py with the <code>-L</code> option. The second is an example of a URL mapping file. It is loaded automatically when renamed "routes.py". The third is an alternative syntax for URL mapping, and can also be renamed (or copied to) "routes.py".</p><p>The files</p><pre><code class="code">app.example.yaml
queue.example.yaml</code></pre><p>are example configuration files used for deployment on the Google App Engine. You can read more about them in the Deployment Recipes chapter and on the Google Documentation pages.</p><p>There are also additional libraries, some developed by a third party:</p><p><strong>feedparser</strong><sup>[<a href="/web2py_book/default/reference/29/feedparser" target="_blank">feedparser</a>]</sup>  by Mark Pilgrim for reading RSS and Atom feeds:</p><pre><code class="code">gluon/contrib/__init__.py
gluon/contrib/feedparser.py</code></pre><p><strong>markdown2</strong><sup>[<a href="/web2py_book/default/reference/29/markdown2" target="_blank">markdown2</a>]</sup>  by Trent Mick for wiki markup:</p><pre><code class="code">gluon/contrib/markdown/__init__.py
gluon/contrib/markdown/markdown2.py</code></pre><p><strong>markmin</strong> markup:</p><pre><code class="code">gluon/contrib/markmin</code></pre><p>(see <a href="../05/#markmin_markmin_syntax">MARKMIN syntax</a> for more)</p><p><strong>fpdf</strong> created my Mariano Reingart for generating PDF documents:</p><pre><code>gluon/contrib/fpdf</code></pre><p>This is not documented in this book but it is hosted and documented here:</p><pre><code>http://code.google.com/p/pyfpdf/</code></pre><p><strong>pysimplesoap</strong> is a lightweight SOAP server implementation created by Mariano Reingart:</p><pre><code class="code">gluon/contrib/pysimplesoap/</code></pre><p><strong>simplejsonrpc</strong> is a lightweight JSON-RPC client also created by Mariano Reingart: <div class="inxx">jsonrpc</div></p><pre><code>gluon/contrib/simplejsonrpc.py</code></pre><p><strong>memcache</strong><sup>[<a href="/web2py_book/default/reference/29/memcache" target="_blank">memcache</a>]</sup>  Python API by Evan Martin:</p><pre><code>gluon/contrib/memcache/__init__.py
gluon/contrib/memcache/memcache.py</code></pre><p><strong>redis_cache</strong> <div class="inxx">redis</div> is a module to store cache in the redis database:</p><pre><code>gluon/contrib/redis_cache.py</code></pre><p><strong>gql</strong>, a port of the DAL to the Google App Engine:</p><pre><code class="code">gluon/contrib/gql.py</code></pre><p><strong>memdb</strong>, a port of the DAL on top of memcache:</p><pre><code class="code">gluon/contrib/memdb.py</code></pre><p><strong>gae_memcache</strong> is an API to use memcache on the Google App Engine:</p><pre><code class="code">gluon/contrib/gae_memcache.py</code></pre><p><strong>pyrtf</strong><sup>[<a href="/web2py_book/default/reference/29/pyrtf" target="_blank">pyrtf</a>]</sup>  for generating Rich Text Format (RTF) documents, developed by Simon Cusack and revised by Grant Edwards:</p><pre><code class="code">gluon/contrib/pyrtf/</code></pre><p><strong>PyRSS2Gen</strong><sup>[<a href="/web2py_book/default/reference/29/pyrss2gen" target="_blank">pyrss2gen</a>]</sup>  developed by Dalke Scientific Software, to generate RSS feeds:</p><pre><code class="code">gluon/contrib/rss2.py</code></pre><p><strong>simplejson</strong><sup>[<a href="/web2py_book/default/reference/29/simplejson" target="_blank">simplejson</a>]</sup>  by Bob Ippolito, the standard library for parsing and writing JSON objects:</p><pre><code class="code">gluon/contrib/simplejson/</code></pre><p><strong>Google Wallet</strong> <sup>[<a href="/web2py_book/default/reference/29/googlewallet" target="_blank">googlewallet</a>]</sup> provides "pay now" buttons which link Google as payment processor:</p><pre><code class="code">gluon/contrib/google_wallet.py</code></pre><p><strong>Stripe.com</strong> <sup>[<a href="/web2py_book/default/reference/29/stripe" target="_blank">stripe</a>]</sup> provides a simple API for accepting credit card payments:</p><pre><code class="code">gluon/contrib/stripe.py</code></pre><p><strong>AuthorizeNet</strong> <sup>[<a href="/web2py_book/default/reference/29/authorizenet" target="_blank">authorizenet</a>]</sup>  provides API to accept credit card payments via Authorize.net network</p><pre><code class="code">gluon/contrib/AuthorizeNet.py</code></pre><p><strong>Dowcommerce</strong> <sup>[<a href="/web2py_book/default/reference/29/dowcommerce" target="_blank">dowcommerce</a>]</sup> credit card processing API:</p><pre><code class="code">gluon/contrib/DowCommerce.py</code></pre><p><strong>PaymentTech</strong> credit card processing API:</p><pre><code class="code">gluon/contrib/paymentech.py</code></pre><p><strong>PAM</strong><sup>[<a href="/web2py_book/default/reference/29/PAM" target="_blank">PAM</a>]</sup>  authentication API created by Chris AtLee:</p><pre><code class="code">gluon/contrib/pam.py</code></pre><p>A Bayesian classifier to populate the database with dummy data for testing purposes:</p><pre><code class="code">gluon/contrib/populate.py</code></pre><p>A file with API for running on Heroku.com : <div class="inxx">heroku</div></p><pre><code class="code">gluon/contrib/heroku.py</code></pre><p>A file that allows interaction with the taskbar in windows, when web2py is running as a service:</p><pre><code class="code">gluon/contrib/taskbar_widget.py</code></pre><p>Optional <strong>login_methods</strong> and login_forms to be used for authentication:</p><pre><code class="code">gluon/contrib/login_methods/__init__.py
gluon/contrib/login_methods/basic_auth.py
gluon/contrib/login_methods/browserid_account.py
gluon/contrib/login_methods/cas_auth.py
gluon/contrib/login_methods/dropbox_account.py
gluon/contrib/login_methods/email_auth.py
gluon/contrib/login_methods/extended_login_form.py
gluon/contrib/login_methods/gae_google_account.py
gluon/contrib/login_methods/ldap_auth.py
gluon/contrib/login_methods/linkedin_account.py
gluon/contrib/login_methods/loginza.py
gluon/contrib/login_methods/oauth10a_account.py
gluon/contrib/login_methods/oauth20_account.py
gluon/contrib/login_methods/oneall_account.py
gluon/contrib/login_methods/openid_auth.py
gluon/contrib/login_methods/pam_auth.py
gluon/contrib/login_methods/rpx_account.py
gluon/contrib/login_methods/x509_auth.py</code></pre><p>web2py also contains a folder with useful scripts including</p><pre><code class="code">scripts/setup-web2py-fedora.sh
scripts/setup-web2py-ubuntu.sh
scripts/setup-web2py-nginx-uwsgi-ubuntu.sh
scripts/setup-web2py-heroku.sh
scripts/update-web2py.sh
scripts/make_min_web2py.py
...
scripts/sessions2trash.py
scripts/sync_languages.py
scripts/tickets2db.py
scripts/tickets2email.py
...
scripts/extract_mysql_models.py
scripts/extract_pgsql_models.py
...
scripts/access.wsgi
scripts/cpdb.py</code></pre><p>The <code>setup-web2py-*</code> are particularly useful because they attempt a complete installation and setup of a web2py production environment from scratch. Some of these are discussed in Chapter 14, but all of them contain a documentation string inside that explains their purpose and usage.</p><p>Finally web2py includes these files required to build the binary distributions.</p><pre><code class="code">Makefile
setup_exe.py
setup_app.py</code></pre><p>These are setup scripts for <strong>py2exe</strong> and <strong>py2app</strong>, respectively, and they are only required to build the binary distributions of web2py. YOU SHOULD NEVER NEED TO RUN THEM.</p><p>web2py applications contain additional files, particularly third-party JavaScript libraries, such as jQuery, calendar, and Codemirror. Their authors are acknowledged in the files themselves.</p><h3>Applications</h3><p>Applications developed in web2py are composed of the following parts:</p><ul><li><strong>models</strong> describe a representation of the data as database tables and relations between tables.</li><li><strong>controllers</strong> describe the application logic and workflow.</li><li><strong>views</strong> describe how data should be presented to the user using HTML and JavaScript.</li><li><strong>languages</strong> describe how to translate strings in the application into various supported languages.</li><li><strong>static files</strong> do not require processing (e.g. images, CSS stylesheets, etc).</li><li><strong>ABOUT</strong> and <strong>README</strong> documents are self-explanatory.</li><li><strong>errors</strong> store error reports generated by the application.</li><li><strong>sessions</strong> store information related to each particular user.</li><li><strong>databases</strong> store SQLite databases and additional table information.</li><li><strong>cache</strong> store cached application items.</li><li><strong>modules</strong> are other optional Python modules.</li><li><strong>private</strong> files are accessed by the controllers but not directly by the developer.</li><li><strong>uploads</strong> files are accessed by the models but not directly by the developer (e.g., files uploaded by users of the application).</li><li><strong>tests</strong> is a directory for storing test scripts, fixtures and mocks.</li></ul><p>Models, views, controllers, languages, and static files are accessible via the web administration [design] interface. ABOUT, README, and errors are also accessible via the administration interface through the corresponding menu items. Sessions, cache, modules and private files are accessible to the applications but not via the administration interface.</p><p>Everything is neatly organized in a clear directory structure that is replicated for every installed web2py application, although the user never needs to access the filesystem directly:</p><p><div class="inxx">about</div> <div class="inxx">license</div> <div class="inxx">cache</div> <div class="inxx">controllers</div> <div class="inxx">databases</div> <div class="inxx">errors</div> <div class="inxx">languages</div> <div class="inxx">models</div> <div class="inxx">modules</div> <div class="inxx">private</div> <div class="inxx">session</div> <div class="inxx">static</div> <div class="inxx">tests</div> <div class="inxx">uploads</div> <div class="inxx">views</div> <div class="inxx">__init__.py</div></p><pre><code class="code">__init__.py  ABOUT        LICENSE    models    views
controllers  modules      private    tests     cron
cache        errors       upload     sessions  static</code></pre><p>"__init__.py" is an empty file which is required in order to allow Python (and web2py) to import the modules in the <code>modules</code> directory.</p><p>Notice that the <strong>admin</strong> application simply provides a web interface to web2py applications on the server file system. web2py applications can also be created and developed from the command-line or your preferred text editor/IDE; you don't have to use the browser <strong>admin</strong> interface.  A new application can be created manually by replicating the above directory structure under ,e.g., "applications/newapp/" (or simply untar the <code>welcome.w2p</code> file into your new application directory). Application files can also be created and edited from the command-line without having to use the web <strong>admin</strong> interface.</p><h3>API</h3><p>Models, controllers, and views are executed in an environment where the following objects are already imported for us:</p><p><strong>Global Objects:</strong> <div class="inxx">request</div> <div class="inxx">response</div> <div class="inxx">session</div> <div class="inxx">cache</div></p><pre><code class="code">request, response, session, cache</code></pre><p><strong>Internationalization:</strong> <div class="inxx">T</div> <div class="inxx">internationalization</div></p><pre><code class="code">T</code></pre><p><strong>Navigation:</strong> <div class="inxx">redirect</div> <div class="inxx">HTTP</div></p><pre><code class="code">redirect, HTTP</code></pre><p><strong>Helpers:</strong> <div class="inxx">helpers</div></p><pre><code class="code">XML, URL, BEAUTIFY

A, B, BODY, BR, CENTER, CODE, COL, COLGROUP,
DIV, EM, EMBED, FIELDSET, FORM, H1, H2, H3, H4, H5, H6,
HEAD, HR, HTML, I, IFRAME, IMG, INPUT, LABEL, LEGEND,
LI, LINK, OL, UL, META, OBJECT, OPTION, P, PRE,
SCRIPT, OPTGROUP, SELECT, SPAN, STYLE,
TABLE, TAG, TD, TEXTAREA, TH, THEAD, TBODY, TFOOT,
TITLE, TR, TT, URL, XHTML, xmlescape, embed64

CAT, MARKMIN, MENU, ON</code></pre><p><strong>Forms and tables</strong></p><pre><code>SQLFORM (SQLFORM.factory, SQLFORM.grid, SQLFORM.smartgrid)</code></pre><p><strong>Validators:</strong> <div class="inxx">validators</div></p><pre><code class="code">CLEANUP, CRYPT, IS_ALPHANUMERIC, IS_DATE_IN_RANGE, IS_DATE,
IS_DATETIME_IN_RANGE, IS_DATETIME, IS_DECIMAL_IN_RANGE,
IS_EMAIL, IS_EMPTY_OR, IS_EXPR, IS_FLOAT_IN_RANGE, IS_IMAGE,
IS_IN_DB, IS_IN_SET, IS_INT_IN_RANGE, IS_IPV4, IS_LENGTH,
IS_LIST_OF, IS_LOWER, IS_MATCH, IS_EQUAL_TO, IS_NOT_EMPTY,
IS_NOT_IN_DB, IS_NULL_OR, IS_SLUG, IS_STRONG, IS_TIME,
IS_UPLOAD_FILENAME, IS_UPPER, IS_URL</code></pre><p><strong>Database:</strong> <div class="inxx">DAL</div></p><pre><code class="code">DAL, Field</code></pre><p>For backward compatibility <code>SQLDB=DAL</code> and <code>SQLField=Field</code>. We encourage you to use the new syntax <code>DAL</code> and <code>Field</code>, instead of the old syntax.</p><p>Other objects and modules are defined in the libraries, but they are not automatically imported since they are not used as often.</p><p>The core API entities in the web2py execution environment are <code>request</code>, <code>response</code>, <code>session</code>, <code>cache</code>, <code>URL</code>, <code>HTTP</code>, <code>redirect</code> and <code>T</code> and are discussed below.</p><p>A few objects and functions, including <strong>Auth</strong>, <strong>Crud</strong> and <strong>Service</strong>, are defined in "gluon/tools.py" and they need to be imported as necessary:</p><pre><code class="code">from gluon.tools import Auth, Crud, Service</code></pre><p>They are imported in <code>db.py</code> in the scaffolding application.</p><h4>Accessing the API from Python modules</h4><p>Your models or controller may import python modules, and these may need to use some of the web2py API. The way to do it is by importing them:</p><pre><code>from gluon import *</code></pre><p>In fact, any Python module, even if not imported by a web2py application, can import the web2py API as long as web2py is in the <code>sys.path</code>.</p><p>There is one caveat, though. Web2py defines some global objects (request, response, session, cache, T) that can only exist when an HTTP request is present (or is faked). Therefore, modules can access them only if they are called from an application. For this reasons they are placed into a container caller <code>current</code>, which is a thread local object. Here is an example.</p><p>Create a module "/myapp/modules/test.py" that contains:</p><pre><code>from gluon import *
def ip(): return current.request.client</code></pre><p>Now from a controller in "myapp" you can do</p><pre><code>import test
def index():
    return "Your ip is " + test.ip()</code></pre><p>Notice a few things:</p><ul><li><code>import test</code> looks for the module first in the current app's modules folder, then in the folders listed in <code>sys.path</code>. Therefore, app-level modules always take precedence over Python modules. This allows different apps to ship with different versions of their modules, without conflicts.</li><li>Different users can call the same action <code>index</code> concurrently, which calls the function in the module, and yet there is no conflict because <code>current.request</code> is a different object in different threads. Just be careful not to access <code>current.request</code> outside of functions or classes (i.e., at the top level) in the module.</li><li><code>import test</code> is a shortcut for <code>from applications.appname.modules import test</code>. Using the longer syntax, it is possible to import modules from other applications.</li></ul><p>For uniformity with normal Python behavior, by default web2py does not reload modules when changes are made. Yet this can be changed. To turn on the auto-reload feature for modules, use the <code>track_changes</code> function as follows (typically in a model file, before any imports):</p><pre><code class="code">from gluon.custom_import import track_changes; track_changes(True)</code></pre><p>From now on, every time a module is imported, the importer will check if the Python source file (.py) has changed. If it has changed, the module will be reloaded.</p><blockquote>Do not call track_changes in the modules themselves.</blockquote><p>Track changes only tracks changes for modules that are stored in the application. Modules that import <code>current</code> can access:</p><ul><li><code>current.request</code></li><li><code>current.response</code></li><li><code>current.session</code></li><li><code>current.cache</code></li><li><code>current.T</code></li></ul><p>and any other variable your application chooses to store in current. For example a model could do</p><pre><code>auth = Auth(db)
from gluon import current
current.auth = auth</code></pre><p>and now all modules imported can access <code>current.auth</code>.</p><p><code>current</code> and <code>import</code> create a powerful mechanism to build extensible and reusable modules for your applications.</p><blockquote>Beware! Given <code>from gluon import current</code>, it is correct to use <code>current.request</code> and any of the other thread local objects but one should never assign them to global variables in the module, such as in
<pre><code>request = current.request # WRONG! DANGER!</code></pre>
nor one should use it assign class attributes
<pre><code>class MyClass:
    request = current.request # WRONG! DANGER!</code></pre>
This is because the thread local object must be extracted at runtime. Global variables instead are defined only once when the model is imported for the first time.</blockquote><p>Another caveat has to do with cache. You cannot use the <code>cache</code> object to decorate functions in modules, that is because it would not behave as expected. In order to cache a function <code>f</code> in a module you must use <code>lazy_cache</code>:</p><pre><code class="code">from gluon.cache import lazy_cache

@lazy_cache('key', time_expire=60, cache_model='ram')
def f(a,b,c,): ....</code></pre><p>Mind that the key is user defined but must be uniquely associated to the function. If omitted web2py will automatically determine a key.</p><h3><code>request</code></h3><p><div class="inxx">request</div> <div class="inxx">Storage</div> <div class="inxx">request.cookies</div> <div class="inxx">user_agent</div></p><p>The <code>request</code> object is an instance of the ubiquitous web2py class that is called <code>gluon.storage.Storage</code>, which extends the Python <code>dict</code> class. It is basically a dictionary, but the item values can also be accessed as attributes:</p><pre><code class="code">request.vars</code></pre><p>is the same as:</p><pre><code class="code">request['vars']</code></pre><p>Unlike a dictionary, if an attribute (or key) does not exist, it does not raise an exception. Instead, it returns <code>None</code>.</p><blockquote>It is sometimes useful to create your own Storage objects. You can do so as follows:
<pre><code class="code">from gluon.storage import Storage
my_storage = Storage() # empty storage object
my_other_storage = Storage(dict(a=1, b=2)) # convert dictionary to Storage</code></pre></blockquote><p><code>request</code> has the following items/attributes, some of which are also an instance of the <code>Storage</code> class:</p><ul><li><code>request.cookies</code>: a <code>Cookie.SimpleCookie()</code> object containing the cookies passed with the HTTP request. It acts like a dictionary of cookies. Each cookie is a Morsel object <sup>[<a href="/web2py_book/default/reference/29/morsel" target="_blank">morsel</a>]</sup>.</li><li><code>request.env</code>: a <code>Storage</code> object containing the environment variables passed to the controller, including HTTP header variables from the HTTP request and standard WSGI parameters. The environment variables are all converted to lower case, and dots are converted to underscores for easier memorization.</li><li><code>request.application</code>: the name of the requested application.</li><li><code>request.controller</code>: the name of the requested controller.</li><li><code>request.function</code>: the name of the requested function.</li><li><code>request.extension</code>: the extension of the requested action. It defaults to "html". If the controller function returns a dictionary and does not specify a view, this is used to determine the extension of the view file that will render the dictionary (parsed from the <code>request.env.path_info</code>).</li><li><code>request.folder</code>: the application directory. For example if the application is "welcome", <code>request.folder</code> is set to the absolute path "/path/to/welcome". In your programs, you should always use this variable and the <code>os.path.join</code> function to build paths to the files you need to access. Although web2py always uses absolute paths, it is a good rule never to explicitly  change the current working folder (whatever that is) since this is not a thread-safe practice.</li><li><code>request.now</code>: a <code>datetime.datetime</code> object storing the datetime of the current request.</li><li><code>request.utcnow</code>: a <code>datetime.datetime</code> object storing the UTC datetime of the current request.</li><li><code>request.args</code>: A list of the URL path components following the controller function name; equivalent to <code>request.env.path_info.split('/')[3:]</code></li><li><code>request.vars</code>: a <code>gluon.storage.Storage</code> object containing all request parameters.</li><li><code>request.get_vars</code>: a <code>gluon.storage.Storage</code> object containing only parameters passed into the query string (a request to <code>/a/c/f?var1=1&amp;var2=2</code> will end in <code>{var1: "1", var2: "2"}</code>)</li><li><code>request.post_vars</code>: a <code>gluon.storage.Storage</code> object containing only the parameters passed into the body of the request (usually in POST, PUT, DELETE requests).</li><li><code>request.client</code>: The ip address of the client as determined by, if present, <code>request.env.http_x_forwarded_for</code> or by <code>request.env.remote_addr</code> otherwise. While this is useful it should not be trusted because the <code>http_x_forwarded_for</code> can be spoofed.</li><li><code>request.is_local</code>: <code>True</code> if the client is localhost, <code>False</code> otherwise. Should work behind a proxy if the proxy supports <code>http_x_forwarded_for</code>.</li><li><code>request.is_https</code>: <code>True</code> if the request is using the HTTPS protocol, <code>False</code> otherwise.</li><li><code>request.body</code>: a read-only file stream that contains the body of the HTTP request. This is automatically parsed to get the <code>request.post_vars</code> and then rewinded. It can be read with <code>request.body.read()</code>.</li><li><code>request.ajax</code> is True if the function is being called via an Ajax request.</li><li><code>request.cid</code> is the <code>id</code> of the component that generated the Ajax request (if any). You can read more about components in Chapter 12.</li><li><code>request.requires_https()</code> prevents further code execution if the request is not over HTTPS and redirects the visitor to the current page over HTTPS.</li><li><code>request.restful</code> this is a new and very useful decorator that can be used to change the default behavior of web2py actions by separating GET/POST/PUSH/DELETE requests. It will be discussed in some detail in Chapter 10.</li><li><code>request.user_agent()</code> parses the user_agent field from the client and returns the information in the form of a dictionary. It is useful to detect mobile devices. It uses "gluon/contrib/user_agent_parser.py" created by Ross Peoples. To see what it does, try to embed the following code in a view:</li></ul><pre><code class="code">{{=BEAUTIFY(request.user_agent())}}</code></pre><ul><li><code>request.global_settings</code> <div class="inxx">request.global_settings</div> contains web2py system wide settings. They are set automatically and you should not change them. For example <code>request.global_settings.gluon_parent</code> contains the full path to the web2py folder, <code>request.global_settings.is_pypy</code> determines if web2py is running on PyPy.</li><li><code>request.wsgi</code> is a hook that allows you to call third party WSGI applications from inside actions</li></ul><p>The latter includes:</p><ul><li><code>request.wsgi.environ</code></li><li><code>request.wsgi.start_response</code></li><li><code>request.wsgi.middleware</code></li></ul><p>their usage is discussed at the end of this Chapter.</p><p>As an example, the following call on a typical system:</p><pre><code class="code">http://127.0.0.1:8000/examples/default/status/x/y/z?p=1&amp;q=2</code></pre><p>results in the following <code>request</code> object: <div class="inxx">request</div> <div class="inxx">env</div></p><table><tbody><tr class="first"><td><strong>variable</strong></td><td><strong>value</strong></td></tr><tr class="even"><td><code>request.application</code></td><td><code>examples</code></td></tr><tr><td><code>request.controller</code></td><td><code>default</code></td></tr><tr class="even"><td><code>request.function</code></td><td><code>status</code></td></tr><tr><td><code>request.extension</code></td><td><code>html</code></td></tr><tr class="even"><td><code>request.view</code></td><td><code>status</code></td></tr><tr><td><code>request.folder</code></td><td><code>applications/examples/</code></td></tr><tr class="even"><td><code>request.args</code></td><td><code>['x', 'y', 'z']</code></td></tr><tr><td><code>request.vars</code></td><td><code>&lt;Storage {'p': 1, 'q': 2}&gt;</code></td></tr><tr class="even"><td><code>request.get_vars</code></td><td><code>&lt;Storage {'p': 1, 'q': 2}&gt;</code></td></tr><tr><td><code>request.post_vars</code></td><td><code>&lt;Storage {}&gt;</code></td></tr><tr class="even"><td><code>request.is_local</code></td><td><code>False</code></td></tr><tr><td><code>request.is_https</code></td><td><code>False</code></td></tr><tr class="even"><td><code>request.ajax</code></td><td><code>False</code></td></tr><tr><td><code>request.cid</code></td><td><code>None</code></td></tr><tr class="even"><td><code>request.wsgi</code></td><td><code>&lt;hook&gt;</code></td></tr><tr><td><code>request.env.content_length</code></td><td><code>0</code></td></tr><tr class="even"><td><code>request.env.content_type</code></td><td></td></tr><tr><td><code>request.env.http_accept</code></td><td><code>text/xml,text/html;</code></td></tr><tr class="even"><td><code>request.env.http_accept_encoding</code></td><td><code>gzip, deflate</code></td></tr><tr><td><code>request.env.http_accept_language</code></td><td><code>en</code></td></tr><tr class="even"><td><code>request.env.http_cookie</code></td><td><code>session_id_examples=127.0.0.1.119725</code></td></tr><tr><td><code>request.env.http_host</code></td><td><code>127.0.0.1:8000</code></td></tr><tr class="even"><td><code>request.env.http_referer</code></td><td><code>http://web2py.com/</code></td></tr><tr><td><code>request.env.http_user_agent</code></td><td><code>Mozilla/5.0</code></td></tr><tr class="even"><td><code>request.env.path_info</code></td><td><code>/examples/simple_examples/status</code></td></tr><tr><td><code>request.env.query_string</code></td><td><code>remote_addr:127.0.0.1</code></td></tr><tr class="even"><td><code>request.env.request_method</code></td><td><code>GET</code></td></tr><tr><td><code>request.env.script_name</code></td><td></td></tr><tr class="even"><td><code>request.env.server_name</code></td><td><code>127.0.0.1</code></td></tr><tr><td><code>request.env.server_port</code></td><td><code>8000</code></td></tr><tr class="even"><td><code>request.env.server_protocol</code></td><td><code>HTTP/1.1</code></td></tr><tr><td><code>request.env.server_software</code></td><td><code>Rocket 1.2.6</code></td></tr><tr class="even"><td><code>request.env.web2py_path</code></td><td><code>/Users/mdipierro/web2py</code></td></tr><tr><td><code>request.env.web2py_version</code></td><td><code>Version 2.4.1</code></td></tr><tr class="even"><td><code>request.env.wsgi_errors</code></td><td><code>&lt;open file, mode 'w' at &gt;</code></td></tr><tr><td><code>request.env.wsgi_input</code></td><td></td></tr><tr class="even"><td><code>request.env.wsgi_url_scheme</code></td><td><code>http</code></td></tr></tbody></table><p>Which environment variables are actually defined depends on the web server. Here we are assuming the built-in Rocket wsgi server. The set of variables is not much different when using the Apache web server.</p><p>The <code>request.env.http_*</code> variables are parsed from the request HTTP header.</p><p>The <code>request.env.web2py_*</code> variables are not parsed from the web server environment, but are created by web2py in case your applications need to know about the web2py location and version, and whether it is running on the Google App Engine (because specific optimizations may be necessary).</p><p>Also notice the <code>request.env.wsgi_*</code> variables. They are specific to the wsgi adapter.</p><h3><code>response</code></h3><div class="inxx">response</div><div class="inxx">response.body</div><div class="inxx">response.cookies</div><div class="inxx">response.download</div><div class="inxx">response.files</div><div class="inxx">response.flash</div><div class="inxx">response.headers</div><div class="inxx">response.meta</div><div class="inxx">response.menu</div><div class="inxx">response.postprocessing</div><div class="inxx">response.render</div><div class="inxx">response.static_version</div><div class="inxx">response.status</div><div class="inxx">response.stream</div><div class="inxx">response.subtitle</div><div class="inxx">response.title</div><div class="inxx">response.toolbar</div><div class="inxx">response.view</div><div class="inxx">response.delimiters</div><div class="inxx">response.js</div><div class="inxx">response.write</div><div class="inxx">response.include_files</div><div class="inxx">response.include_meta</div><div class="inxx">response.optimize_css</div><div class="inxx">response.optimize_js</div><div class="inxx">response._caller</div><div class="inxx">response.models_to_run</div><p><code>response</code> is another instance of the <code>Storage</code> class. It contains the following:</p><ul><li><code>response.body</code>: a <code>StringIO</code> object into which web2py writes the output page body. NEVER CHANGE THIS VARIABLE.</li><li><code>response.cookies</code>: similar to <code>request.cookies</code>, but while the latter contains the cookies sent from the client to the server, the former contains cookies sent by the server to the client. The session cookie is handled automatically.</li><li><code>response.download(request, db)</code>: a method used to implement the controller function that allows downloading of uploaded files. <code>response.download</code> expects the last <code>arg</code> in <code>request.args</code> to be the encoded filename (i.e., the filename generated at upload time and stored in the upload field). It extracts the upload field name and table name as well as the original filename from the encoded filename. <code>response.download</code> takes two optional arguments: <code>chunk_size</code> sets the size in bytes for chunked streaming (defaults to 64K), and <code>attachments</code> determines whether the downloaded file should be treated as an attachment or not (default to <code>True</code>). Note, <code>response.download</code> is specifically for downloading files associated with <code>db</code> upload fields. Use <code>response.stream</code> (see below) for other types of file downloads and streaming. Also, note that it is not necessary to use <code>response.download</code> to access files uploaded to the /static folder -- static files can (and generally should) be accessed directly via URL (e.g., /app/static/files/myfile.pdf).</li><li><code>response.files</code>: a list of <code>.css</code>, <code>.js</code>, <code>.coffee</code>, and <code>.less</code> files required by the page. They will automatically be linked in the head of the standard "layout.html" via the included "web2py_ajax.html". To include a new CSS, JS, COFFEE, or LESS file, just append it to this list. It will handle duplicates. The order is important.</li><li><code>response.include_files()</code> generates html head tags to include all <code>response.files</code> (used in "views/web2py_ajax.html").</li><li><code>response.flash</code>: optional parameter that may be included in the views. Normally used to notify the user about something that happened.</li><li><code>response.headers</code>: a <code>dict</code> for HTTP response headers. Web2py sets some headers by default, including "Content-Length", "Content-Type", and "X-Powered-By" (set equal to web2py). Web2py also sets the "Cache-Control", "Expires", and "Pragma" headers to prevent client-side caching, except for static file requests, for which client-side caching is enabled. The headers that web2py sets can be overwritten or removed, and new headers can be added (e.g., <code>response.headers['Cache-Control'] = 'private'</code>). You can remove a header by removing its key from the response.headers dict, e.g. <code>del response.headers['Custom-Header']</code>, however web2py's default headers will be re-added just before returning the response. To avoid this behavior, just set the header value to None, e.g. to remove the default Content-Type header, <code>response.headers['Content-Type'] = None</code></li><li><code>response.menu</code>: optional parameter that may be included in the views, normally used to pass a navigation menu tree to the view. It can be rendered by the MENU helper.</li><li><code>response.meta</code>: a Storage object that contains optional <code>&lt;meta&gt;</code> information like <code>response.meta.author</code>, <code>.description</code>, and/or <code>.keywords</code>. The content of each meta variable is automatically placed in the proper <code>META</code> tag by the code in "views/web2py_ajax.html", which is included by default in "views/layout.html".</li><li><code>response.include_meta()</code> generates a string that includes all <code>response.meta</code> headers serialized (used in "views/web2py_ajax.html").</li><li><code>response.postprocessing</code>: this is a list of functions, empty by default. These functions are used to filter the response object at the output of an action, before the output is rendered by the view. It can be used to implement support for other template languages.</li><li><code>response.render(view, vars)</code>: a method used to call the view explicitly inside the controller. <code>view</code> is an optional parameter which is the name of the view file, <code>vars</code> is a dictionary of named values passed to the view.</li><li><code>response.session_file</code>: file stream containing the session.</li><li><code>response.session_file_name</code>: name of the file where the session will be saved.</li><li><code>response.session_id</code>: the id of the current session. It is determined automatically. NEVER CHANGE THIS VARIABLE.</li><li><code>response.session_id_name</code>: the name of the session cookie for this application. NEVER CHANGE THIS VARIABLE.</li><li><code>response.static_version</code>: a version number for the static asset management.</li><li><code>response.status</code>: the HTTP status code integer to be passed to the response. Default is 200 (OK).</li><li><code>response.stream(file, chunk_size, request=request, attachment=False, filename=None)</code>: when a controller returns it, web2py streams the file content back to the client in blocks of size <code>chunk_size</code>. The <code>request</code> parameter is required to use the chunk start in the HTTP header. <code>file</code> should be a file path (for backward compatibility, it can also be an open file object, but this is not recommended). As noted above, <code>response.download</code> should be used to retrieve files stored via an upload field. <code>response.stream</code> can be used in other cases, such as returning a temporary file or StringIO object created by the controller. If <code>attachment</code> is True, the Content-Disposition header will be set to "attachment", and if <code>filename</code> is also provided, it will be added to the Content-Disposition header as well (but only when <code>attachment</code> is True). If not already included in <code>response.headers</code>, the following response headers will be set automatically: Content-Type, Content-Length, Cache-Control, Pragma, and Last-Modified (the latter three are set to allow browser caching of the file). To override any of these automatic header settings, simply set them in <code>response.headers</code> before calling <code>response.stream</code>.</li><li><code>response.subtitle</code>: optional parameter that may be included in the views. It should contain the subtitle of the page.</li><li><code>response.title</code>: optional parameter that may be included in the views. It should contain the title of the page and should be rendered inside the html title tag in the header.</li><li><code>response.toolbar</code>: a function that allows you to embed a toolbar into page for debugging purposes <code>{{=response.toolbar()}}</code>. The toolbar displays request, response, session variables and database access time for each query.</li><li><code>response._vars</code>: this variable is accessible only in a view, not in the action. It contains the values returned by the action to the view.</li><li><code>response._caller</code>: this is a function that wraps all action calls. It defaults to the identity function, but it can be modified in order to catch special types of exception to do extra logging; <code>  response._caller = lambda f: f()
  </code></li><li><code>response.optimize_css</code>: can be set to "concat,minify,inline" to concatenate, minify and inline the CSS files included by web2py.</li><li><code>response.optimize_js</code>: can be set to "concat,minify,inline" to concatenate, minify and inline the JavaScript files included by web2py.</li><li><code>response.view</code>: the name of the view template that must render the page. This is set by default to: <code class="code">  "%s/%s.%s" % (request.controller, request.function, request.extension)
  </code> or, if the above file cannot be located, to <code class="code">  "generic.%s" % (request.extension)
  </code> Change the value of this variable to modify the view file associated with a particular action.</li><li><code>response.delimiters</code> defaults to <code>('{{','}}')</code>. It allows you to change the delimiter of code embedded in views.</li><li><code>response.xmlrpc(request, methods)</code>: when a controller returns it, this function exposes the methods via XML-RPC<sup>[<a href="/web2py_book/default/reference/29/xmlrpc" target="_blank">xmlrpc</a>]</sup> . This function is deprecated since a better mechanism is available and described in Chapter 10.</li><li><code>response.write(text)</code>: a method to write text into the output page body.</li><li><code>response.js</code> can contain Javascript code. This code will be executed if and only if the response is received by a web2py component as discussed in Chapter 12.</li><li><code>response.models_to_run</code> <span class="anchor" id="markmin_response_models_to_run"></span> contains a list of regexes that chooses what models to run.<ul><li>By default, this is set automatically to load /a/models/*.py, /a/models/c/*.py, and /a/models/c/f/*.py files when <code>/a/c/f</code> is requested. You can set, e.g., <code>response.models_to_run = ['myfolder/']</code> to force the execution only of the models inside your application's <code>models/myfolder</code> subfolder.</li><li>NB: <code>response.models_to_run</code> is a list of regex, not a list of filepaths. The regex are relative to the models/ folder, so any model file with a relative file path that matches one of the regexes will be executed. Note also that this can not affect any models which have already been evaluated because they were earlier in the alphabetic sort order. That is, if a conditional model for controller orange was orange/orange_model.py and it set the regex to [.*], that change does not affect any models previously rejected for loading such as the model apple/apple_model.py ; it matches the new regex, but it was evaluated and rejected before orange/orange_model.py changed the regex.</li><li>This means that if you want to use models_to_run to share conditional models between controllers, put the models in a sub-directory that will sort last such as zzz, and then use a regex 'zzz'.</li></ul><p></p></li></ul><p>Since <code>response</code> is a <code>gluon.storage.Storage</code> object, it can be used to store other attributes that you may want to pass to the view. While there is no technical restriction, our recommendation is to store only variables that are to be rendered by all pages in the overall layout ("layout.html").</p><p>Anyway, we strongly suggest to stick to the variables listed here:</p><pre><code class="code">response.title
response.subtitle
response.flash
response.menu
response.meta.author
response.meta.description
response.meta.keywords
response.meta.*</code></pre><p>because this will make it easier for you to replace the standard "layout.html" file that comes with web2py with another layout file, one that uses the same set of variables.</p><p>Old versions of web2py used <code>response.author</code> instead of <code>response.meta.author</code> and similar for the other meta attributes.</p><h3><code>session</code></h3><p><div class="inxx">session</div> <div class="inxx">session.connect</div> <div class="inxx">session.forget</div> <div class="inxx">session.secure</div> <code>session</code> is another instance of the <code>Storage</code> class. Whatever is stored into <code>session</code> for example:</p><pre><code class="code">session.myvariable = "hello"</code></pre><p>can be retrieved at a later time:</p><pre><code class="code">a = session.myvariable</code></pre><p>as long as the code is executed within the same session by the same user (provided the user has not deleted session cookies and the session has not expired). Because <code>session</code> is a <code>Storage</code> object, trying to access an attribute/key that has not been set does not raise an exception; it returns <code>None</code> instead.</p><p>The session object has three important methods. One is <code>forget</code>:</p><pre><code class="code">session.forget(response)</code></pre><p>It tells web2py not to save the session. This should be used in those controllers whose actions are called often and do not need to track user activity. <code>session.forget()</code> prevents the session file from being written, regardless of whether it has been modified. <code>session.forget(response)</code> additionally unlocks and closes the session file. You rarely need to call this method since sessions are not saved when they are not changed. However, if the page makes multiple simultaneous Ajax requests, it is a good idea for the actions called via Ajax to call <code>session.forget(response)</code> (assuming the session is not needed by the action). Otherwise, each Ajax action will have to wait for the previous one to complete (and unlock the session file) before proceeding, which will slow down the page loading. Notice that sessions are not locked when stored in the database.</p><p>Another method is:</p><pre><code class="code">session.secure()</code></pre><p>which tells web2py to set the session cookie to be a secure cookie. This should be set if the app is going over https. By setting the session cookie to be secure, the server is asking the browser not to send the session cookie back to the server unless over an https connection.</p><p>The other method is <code>connect</code>. By default sessions are stored on the filesystem and a session cookie is used to store and retrieve the <code>session.id</code>. Using the connect method it is possible to tell web2y to store sessions in the database or in the cookies thus eliminating need to access the filesystem for session management.</p><p>For example to <strong>store sessions in the database</strong>:</p><pre><code class="code">session.connect(request, response, db, masterapp=None)</code></pre><p>where <code>db</code> is the name of an open database connection (as returned by the DAL). It tells web2py that you want to store the sessions in the database and not on the filesystem. <code>session.connect</code> must come after <code>db=DAL(...)</code>, but before any other logic that requires session, for example, setting up <code>Auth</code>.</p><p>web2py creates a table:</p><pre><code class="code">db.define_table('web2py_session',
                 Field('locked', 'boolean', default=False),
                 Field('client_ip'),
                 Field('created_datetime', 'datetime', default=now),
                 Field('modified_datetime', 'datetime'),
                 Field('unique_key'),
                 Field('session_data', 'text'))</code></pre><p>and stores cPickled sessions in the <code>session_data</code> field.</p><p>The option <code>masterapp=None</code>, by default, tells web2py to try to retrieve an existing session for the application with name in <code>request.application</code>, in the running application.</p><p>If you want two or more applications to share sessions, set <code>masterapp</code> to the name of the master application.</p><p>To <strong>store sessions in cookies</strong> instead you can do:</p><pre><code class="code">session.connect(request,response,cookie_key='yoursecret',compression_level=None)</code></pre><p>Here <code>cookie_key</code> is a symmetric encryption key. <code>compression_level</code> is an optional <code>zlib</code> encryption level.</p><p>While sessions in cookie are often recommended for scalability reason they are limited in size. Large sessions will result in broken cookies.</p><p>You can check the state of your application at any time by printing the <code>request</code>, <code>session</code> and <code>response</code> system variables. One way to do it is to create a dedicated action:</p><pre><code class="code">def status():
    return dict(request=request, session=session, response=response)</code></pre><p>In the "generic.html" view this is done using <code>{{=response.toolbar()}}</code>.</p><h4>Don't store user-defined classes in session</h4><p>Variables stored in the session are preserved between requests by serialisation.</p><p>Sessions are retrieved before module code is executed and therefore before classes are defined. Therefore user defined classes cannot be pickled.</p><p>Classes defined in modules are also a grey area and they should not put in storage. Most of the time they work but they can break. This is because, for example, if you restart the web server and a user retrieves a session, this may happen before the module is imported. Same problem when the web server starts a new worker process. Same problem in a distributed environment.</p><h4>Separate sessions</h4><p>If you are storing sessions on the filesystem and you have lots of them, the file system access may become a bottle-neck. One solution is the following:</p><pre><code class="code">session.connect(request, response, separate=True)</code></pre><p>By setting <code>separate=True</code> web2py will store sessions not in the "sessions/" folder but in subfolders of the "sessions/" folder. The subfolder will be created automatically. Sessions with the same prefix will be in the same subfolder. Again, note that the above must be called before any logic that might require the session.</p><h3><code>cache</code></h3><p><div class="inxx">cache</div> <div class="inxx">cache.ram</div> <div class="inxx">cache.disk</div> <code>cache</code> a global object also available in the web2py execution environment. It has two attributes:</p><ul><li><code>cache.ram</code>: the application cache in main memory.</li><li><code>cache.disk</code>: the application cache on disk.</li></ul><p><code>cache</code> is callable, this allows it to be used as a decorator for caching actions and views.</p><p>The following example caches the <code>time.ctime()</code> function in RAM:</p><pre><code class="code">def cache_in_ram():
    import time
    t = cache.ram('time', lambda: time.ctime(), time_expire=5)
    return dict(time=t, link=A('click me', _href=request.url))</code></pre><p>The output of <code>lambda: time.ctime()</code> is cached in RAM for 5 seconds. The string <code>'time'</code> is used as cache key.</p><p>The following example caches the <code>time.ctime()</code> function on disk:</p><pre><code class="code">def cache_on_disk():
    import time
    t = cache.disk('time', lambda: time.ctime(), time_expire=5)
    return dict(time=t, link=A('click me', _href=request.url))</code></pre><p>The output of <code>lambda: time.ctime()</code> is cached on disk (using the shelve module) for 5 seconds.</p><p>Note, the second argument to <code>cache.ram</code> and <code>cache.disk</code> must be a function or callable object. If you want to cache an existing object rather than the output of a function, you can simply return it via a lambda function:</p><pre><code class="code">cache.ram('myobject', lambda: myobject, time_expire=60*60*24)</code></pre><p>The next example caches the <code>time.ctime()</code> function to both RAM and disk:</p><pre><code class="code">def cache_in_ram_and_disk():
    import time
    t = cache.ram('time', lambda: cache.disk('time',
                       lambda: time.ctime(), time_expire=5),
                       time_expire=5)
    return dict(time=t, link=A('click me', _href=request.url))</code></pre><p>The output of <code>lambda: time.ctime()</code> is cached on disk (using the shelve module) and then in RAM for 5 seconds. web2py looks in RAM first and if not there it looks on disk. If it is not in RAM or on disk, <code>lambda: time.ctime()</code> is executed and the cache is updated. This technique is useful in a multiprocessor environment. The two times do not have to be the same.</p><p>The following example is caching in RAM the output of the controller function (but not the view):</p><div class="inxx">cache controller</div><pre><code class="code">@cache(request.env.path_info, time_expire=5, cache_model=cache.ram)
def cache_controller_in_ram():
    import time
    t = time.ctime()
    return dict(time=t, link=A('click me', _href=request.url))</code></pre><p>The dictionary returned by <code>cache_controller_in_ram</code> is cached in RAM for 5 seconds. Note that the result of a database select cannot be cached without first being serialized. A better way is to cache the database select directly using the <code>select</code> method's <code>cache</code> argument.</p><p>The following example is caching the output of the controller function on disk (but not the view):</p><pre><code class="code">@cache(request.env.path_info, time_expire=5, cache_model=cache.disk)
def cache_controller_on_disk():
    import time
    t = time.ctime()
    return dict(time=t, link=A('click to reload',
                              _href=request.url))</code></pre><p>The dictionary returned by <code>cache_controller_on_disk</code>  is cached on disk for 5 seconds. Remember that web2py cannot cache a dictionary that contains un-pickleable objects.</p><p>It is also possible to cache the view. The trick is to render the view in the controller function, so that the controller returns a string. This is done by returning <code>response.render(d)</code> where <code>d</code> is the dictionary we intended to pass to the view. The following example caches the output of the controller function in RAM (including the rendered view):</p><div class="inxx">cache view</div><pre><code class="code">@cache(request.env.path_info, time_expire=5, cache_model=cache.ram)
def cache_controller_and_view():
    import time
    t = time.ctime()
    d = dict(time=t, link=A('click to reload', _href=request.url))
    return response.render(d)</code></pre><p><code>response.render(d)</code> returns the rendered view as a string, which is now cached for 5 seconds. This is the best and fastest way of caching.</p><blockquote>We recommend to use @cache.action starting from web2py &gt; 2.4.6 </blockquote><p>Note, <code>time_expire</code> is used to compare the current time with the time the requested object was last saved in the cache. It does not affect future requests. This enables <code>time_expire</code> to be set dynamically when an object is requested rather than being fixed when the object is saved. For example:</p><pre><code class="code">message = cache.ram('message', lambda: 'Hello', time_expire=5)</code></pre><p>Now, suppose the following call is made 10 seconds after the above call:</p><pre><code class="code">message = cache.ram('message', lambda: 'Goodbye', time_expire=20)</code></pre><p>Because <code>time_expire</code> is set to 20 seconds in the second call and only 10 seconds has elapsed since the message was first saved, the value "Hello" will be retrieved from the cache, and it will not be updated with "Goodbye". The <code>time_expire</code> value of 5 seconds in the first call has no impact on the second call.</p><p>Setting <code>time_expire=0</code> (or a negative value) forces the cached item to be refreshed (because the elapsed time since the last save will always be &gt; 0), and setting <code>time_expire=None</code> forces retrieval of the cached value, regardless of the time elapsed since it was saved (if <code>time_expire</code> is always <code>None</code>, the cached item will effectively never expire).</p><p>You can clear one or more cache variables with</p><div class="inxx">cache clear</div><pre><code class="code">cache.ram.clear(regex='...')</code></pre><p>where <code>regex</code> is a regular expression matching all the keys you want removed from the cache. You can also clear a single item with:</p><pre><code class="code">cache.ram(key, None)</code></pre><p>where <code>key</code> is the key of the cached item.</p><p>It is also possible to define other caching mechanisms such as memcache. Memcache is available via <code>gluon.contrib.memcache</code> and is discussed in more detail in Chapter 14.</p><blockquote>Be careful when caching to remeber that caching is usually at the app-level not at the user level. If you need, for example, to cache user specific content, choose a key that includes the user id.</blockquote><h4><code>cache.action</code></h4><p>Web2py by default assumes that the returned content is not going to be cached, as this reduces the shortcomings of an improper caching of the page client-side.</p><p>For example, when you show a form to the user, or a list of records, the web page should not be cached, as other users may have inserted new records on the table you are showing.</p><p>Instead, if you are showing to the user a wiki page whose content will never change (or it changes once a week), it is useful to store that page, but it is even more useful to tell the client that that page is not going to change.</p><p>This is accomplished sending out some specific headers along with the page: when the client's browser receives the content, it is stored in the browser's cache and it will not be requested again to your site. Of course this is a <strong>major</strong> speedup for public-facing sites.</p><p>Web2py &gt; 2.4.6 introduced a new <code>cache.action</code> decorator to allow a smarter handling of this situation. <code>cache.action</code> can be used:</p><ul><li>for setting smart cache headers</li><li>to cache the results accordingly</li></ul><blockquote>NB: it will do one or another or <strong>both</strong>.</blockquote><p>The main problem with caching a view with <code>@cache(request.env.path_info, time_expire=300, cache_model=cache.ram)</code> is that request.env.path_info as a key leads to several problems, e.g.</p><ol><li>URL vars are not considered<ul><li>you cached the result of <em>/app/default/index?<strong>search=foo</strong></em> : for the next 300 seconds <em>/app/default/index?<strong>search=bar</strong></em> will return the exact same thing of <em>/app/default/index?<strong>search=foo</strong></em></li></ul></li><li>User is not considered<ul><li>you user accesses often a page and you choose to cache it. However, you cached the result of <em>/app/default/index</em> using request.env.path_info as the key, so another user will see a page that was not meant for him</li><li>you cached a page for "Bill", but "Bill" accessed the page from the desktop. Now he tries to access it from its phone: if you prepared a template for mobile users that is different from the standard one, "Joe" will not see it</li></ul></li><li>Language is not considered<ul><li>when you cache the page, if you use T() for some elements, the page will be stored with a fixed translation</li></ul></li><li>Method is not considered<ul><li>When you cache a page, you should only cache it if it's a result of a GET operation</li></ul></li><li>Status code is not considered<ul><li>When you cached the page for the first time, something went wrong and you returned a nice 404 page. You don't want to cache errors ^_^</li></ul></li></ol><p>Instead of letting users write a lot of boilerplate code to take care of all those problems, <code>cache.action</code> was created. It will by default use smart cache headers to let the browser cache the result: if you pass a cache model to it, it will also figure out the best key automatically, so different versions of the same page can be stored and retrieved accordingly (e.g. one for English users and one for Spanish ones)</p><p>It takes several parameters, with smart defaults:</p><ul><li>time_expire : the usual, defaults to 300 seconds</li><li>cache_model : by default is None. This means that @cache.action will <strong>only</strong> alter the default headers to let the client's browser cache the content<ul><li>if you pass, e.g., <code>cache.ram</code>, the result will be stored in the cache as well</li></ul></li><li>prefix : if you want to prefix the auto-generated key (useful for clearing it later with, e.g. <code>cache.ram.clear(prefix*)</code>)</li><li>session : if you want to consider the session, defaults to False</li><li>vars : if you want to consider URL vars, defaults to True</li><li>lang : if you want to consider the language, defaults to True</li><li>user_agent : if you want to consider the user agent, defaults to False</li><li>public : if you want the same page for all the users that will ever access it, defaults to True</li><li>valid_statuses : defaults to None. cache.client will cache only pages requested with a GET method, whose status codes begin with 1,2 or 3. You can pass a list of status codes (when you want pages to be cached with those statuses, e.g. status_codes=[200] will cache only pages that resulted in a 200 status code)</li><li>quick : defaults to None, but you can pass a list of initials to set a particular feature:<ul><li><strong>S</strong>ession, <strong>V</strong>ars, <strong>L</strong>ang, <strong>U</strong>ser_agent, <strong>P</strong>ublic e.g. <code>@cache.action(time_expire=300, cache_model=cache.ram, quick='SVP')</code> is the same as <code>@cache.action(time_expire=300, cache_model=cache.ram, session=True, vars=True, public=True)</code></li></ul></li></ul><p>"Consider" means for e.g. <strong>vars</strong>, that you want to cache different pages if <strong>vars</strong> are different, so  <em>/app/default/index?<strong>search=foo</strong></em> will not be the same one for <em>/app/default/index?<strong>search=bar</strong></em> Some settings override others, so, e.g., if you set <code>session=True, public=True</code> the latter will be discarded. Use them wisely!</p><p><span class="anchor" id="markmin_URL"></span></p><h3><code>URL</code></h3><div class="inxx">URL</div><p>The <code>URL</code> function is one of the most important functions in web2py. It generates internal URL paths for the actions and the static files.</p><p>Here is an example:</p><pre><code class="code">URL('f')</code></pre><p>is mapped into</p><pre><code class="code">/[application]/[controller]/f</code></pre><p>Notice that the output of the <code>URL</code> function depends on the name of the current application, the calling controller, and other parameters. web2py supports URL mapping and reverse URL mapping. URL mapping allows you to redefine the format of external URLs. If you use the <code>URL</code> function to generate all the internal URLs, then additions or changes to URL mappings will prevent broken links within the web2py application.</p><p>You can pass additional parameters to the <code>URL</code> function, i.e., extra terms in the URL path (args) and URL query variables (vars):</p><pre><code class="code">URL('f', args=['x', 'y'], vars=dict(z='t'))</code></pre><p>is mapped into</p><pre><code class="code">/[application]/[controller]/f/x/y?z=t</code></pre><p>The <code>args</code> attributes are automatically parsed, decoded, and finally stored in <code>request.args</code> by web2py. Similarly, the <code>vars</code> are parsed, decoded, and then stored in <code>request.vars</code>. <code>args</code> and <code>vars</code> provide the basic mechanism by which web2py exchanges information with the client's browser.</p><p>If args contains only one element, there is no need to pass it in a list.</p><p>You can also use the <code>URL</code> function to generate URLs to actions in other controllers and other applications:</p><pre><code class="code">URL('a', 'c', 'f', args=['x', 'y'], vars=dict(z='t'))</code></pre><p>is mapped into</p><pre><code>/a/c/f/x/y?z=t</code></pre><p>It is also possible to specify application, controller and function using named arguments:</p><pre><code class="code">URL(a='a', c='c', f='f')</code></pre><p>If the application name <em>a</em> is missing the current app is assumed.</p><pre><code class="code">URL('c', 'f')</code></pre><p>If the controller name <em>c</em> is missing, the current one is assumed.</p><pre><code class="code">URL('f')</code></pre><p>Instead of passing the name of a controller function it is also possible to pass the function itself</p><pre><code class="code">URL(f)</code></pre><p>For the reasons mentioned above, you should always use the <code>URL</code> function to generate URLs of static files for your applications. Static files are stored in the application's <code>static</code> subfolder (that's where they go when uploaded using the administrative interface). web2py provides a virtual 'static' controller whose job is to retrieve files from the <code>static</code> subfolder, determine their content-type, and stream the file to the client. The following example generates the URL for the static file "image.png":</p><pre><code class="code">URL('static', 'image.png')</code></pre><p>is mapped into</p><pre><code class="code">/[application]/static/image.png</code></pre><p>If the static file is in a subfolder within the <code>static</code> folder, you can include the subfolder(s) as part of the filename. For example, to generate:</p><pre><code>/[application]/static/images/icons/arrow.png</code></pre><p>one should use:</p><pre><code class="code">URL('static', 'images/icons/arrow.png')</code></pre><p>You do not need to encode/escape the <code>args</code> and <code>vars</code> arguments; this is done automatically for you.</p><p>By default, the extension corresponding to the current request (which can be found in <code>request.extension</code>) is appended to the function, unless request.extension is html, the default. This can be overridden by explicitly including an extension as part of the function name <code>URL(f='name.ext')</code> or with the extension argument:</p><pre><code class="code">URL(..., extension='css')</code></pre><p>The current extension can be explicitly suppressed:</p><pre><code class="code">URL(..., extension=False)</code></pre><h4>Absolute urls</h4><p>By default, <code>URL</code> generates relative URLs. However, you can also generate absolute URLs by specifying the <code>scheme</code> and <code>host</code> arguments (this is useful, for example, when inserting URLs in email messages):</p><pre><code class="code">URL(..., scheme='http', host='www.mysite.com')</code></pre><p>You can automatically include the scheme and host of the current request by simply setting the arguments to <code>True</code>.</p><pre><code class="code">URL(..., scheme=True, host=True)</code></pre><p>The <code>URL</code> function also accepts a <code>port</code> argument to specify the server port if necessary.</p><h4>Digitally signed urls</h4><div class="inxx">digitally signed URL</div><p>When generating a URL, you have the option to digitally sign it. This will append a <code>_signature</code> GET variable that can be verified by the server. This can be done in two ways.</p><p>You can pass to the URL function the following arguments:</p><ul><li><code>hmac_key</code>: the key for signing the URL (a string)</li><li><code>salt</code>: an optional string to salt the data before signing</li><li><code>hash_vars</code>: an optional list of names of variables from the URL query string (i.e., GET variables) to be included in the signature. It can also be set to <code>True</code> (the default) to include all variables, or <code>False</code> to include none of the variables.</li></ul><p>Here is an example of usage:</p><pre><code class="code">KEY = 'mykey'

def one():
    return dict(link=URL('two', vars=dict(a=123), hmac_key=KEY))

def two():
    if not URL.verify(request, hmac_key=KEY): raise HTTP(403)
    # do something
    return locals()</code></pre><p>This makes the action <code>two</code> accessible only via a digitally signed URL. A digitally signed URL looks like this:</p><pre><code>'/welcome/default/two?a=123&amp;_signature=4981bc70e13866bb60e52a09073560ae822224e9'</code></pre><p>Note, the digital signature is verified via the <code>URL.verify</code> function. <code>URL.verify</code> also takes the <code>hmac_key</code>, <code>salt</code>, and <code>hash_vars</code> arguments described above, and their values must match the values that were passed to the <code>URL</code> function when the digital signature was created in order to verify the URL.</p><p>A second and more sophisticated but more common use of digitally signed URLs is in conjunction with Auth. This is best explained with an example:</p><pre><code class="code">@auth.requires_login()
def one():
    return dict(link=URL('two', vars=dict(a=123), user_signature=True)

@auth.requires_signature()
def two():
    # do something
    return locals()</code></pre><p>In this case the <code>hmac_key</code> is automatically generated and shared within the session. This allows action <code>two</code> to delegate any access control to action <code>one</code>. If the link is generated and signed, it is valid; else it is not. If the link is stolen by another user, the link will be invalid.</p><p>It is good practice to always digitally sign Ajax callbacks. If you use the web2py <code>LOAD</code> function, it has a <code>user_signature</code> argument too that can be used for this purpose:</p><pre><code>{{=LOAD('default', 'two', vars=dict(a=123), ajax=True, user_signature=True)}}</code></pre><h3><code>HTTP</code> and <code>redirect</code></h3><p><div class="inxx">HTTP</div> <div class="inxx">redirect</div></p><p>web2py defines only one new exception called <code>HTTP</code>. This exception can be raised anywhere in a model, a controller, or a view with the command:</p><pre><code class="code">raise HTTP(400, "my message")</code></pre><p>It causes the control flow to jump away from the user's code, back to web2py, and return an HTTP response like:</p><pre><code class="code">HTTP/1.1 400 BAD REQUEST
Date: Sat, 05 Jul 2008 19:36:22 GMT
Server: Rocket WSGI Server
Content-Type: text/html
Via: 1.1 127.0.0.1:8000
Connection: close
Transfer-Encoding: chunked

my message</code></pre><p>The first argument of <code>HTTP</code> is the HTTP status code. The second argument is the string that will be returned as the body of the response. Additional optional named arguments are used to build the response HTTP header. For example:</p><pre><code class="code">raise HTTP(400, 'my message', test='hello')</code></pre><p>generates:</p><pre><code class="code">HTTP/1.1 400 BAD REQUEST
Date: Sat, 05 Jul 2008 19:36:22 GMT
Server: Rocket WSGI Server
Content-Type: text/html
Via: 1.1 127.0.0.1:8000
Connection: close
Transfer-Encoding: chunked
test: hello

my message</code></pre><p>If you do not want to commit the open database transaction, rollback before raising the exception.</p><p>Any exception other than <code>HTTP</code> causes web2py to roll back any open database transaction, log the error traceback, issue a ticket to the visitor, and return a standard error page.</p><p>This means that only <code>HTTP</code> can be used for cross-page control flow. Other exceptions must be caught by the application, otherwise they are ticketed by web2py.</p><p>The command:</p><pre><code class="code">redirect('http://www.web2py.com')</code></pre><p>is simply a shortcut for:</p><pre><code class="code">raise HTTP(303,
           'You are being redirected &lt;a href="%s"&gt;here&lt;/a&gt;' % location,
           Location='http://www.web2py.com')</code></pre><p>The named arguments of the <code>HTTP</code> initializer method are translated into HTTP header directives, in this case, the redirection target location. <code>redirect</code> takes an optional second argument, which is the HTTP status code for the redirection (303 by default). Change this number to 307 for a temporary redirect or to 301 for a permanent redirect.</p><p>The most common way to use redirect is to redirect to other pages in the same app and (optionally) pass parameters:</p><pre><code class="code">redirect(URL('index', args=(1,2,3), vars=dict(a='b')))</code></pre><p>In chapter 12 we discuss web2py components. They make Ajax requests to web2py actions. If the called action performs a redirect, you may want the Ajax request to follow the redirect or you may want the entire page performing the Ajax request redirecting. In this latter case you can set:</p><pre><code class="code">redirect(...,client_side=True)</code></pre><h3>Internationalization, and Pluralization with <code>T</code></h3><p><div class="inxx">T</div> <div class="inxx">internationalization</div></p><p>The object <code>T</code> is the language translator. It constitutes a single global instance of the web2py class <code>gluon.language.translator</code>. All string constants (and only string constants) should be marked by <code>T</code>, for example:</p><pre><code class="code">a = T("hello world")</code></pre><p>Strings that are marked with <code>T</code> are identified by web2py as needing language translation and they will be translated when the code (in the model, controller, or view) is executed. If the string to be translated is not a constant but a variable, it will be added to the translation file at runtime (except on GAE) to be translated later.</p><p>The <code>T</code> object can also contain interpolated variables and supports multiple equivalent syntaxes:</p><pre><code class="code">a = T("hello %s", ('Tim',))
a = T("hello %(name)s", dict(name='Tim'))
a = T("hello %s") % ('Tim',)
a = T("hello %(name)s") % dict(name='Tim')</code></pre><p>The latter syntax is recommended because it makes translation easier. The first string is translated according to the requested language file and the <code>name</code> variable is replaced independently of the language.</p><p>You can concatenate translated strings and normal strings:</p><pre><code class="code">T("blah ") + name + T(" blah")</code></pre><p>The following code is also allowed and often preferable:</p><pre><code class="code">T("blah %(name)s blah", dict(name='Tim'))</code></pre><p>or the alternative syntax</p><pre><code class="code">T("blah %(name)s blah") % dict(name='Tim')</code></pre><p>In both cases the translation occurs before the variable name is substituted in the "%(name)s" slot. The following alternative should NOT BE USED:</p><pre><code class="code">T("blah %(name)s blah" % dict(name='Tim'))</code></pre><p>because translation would occur after substitution.</p><h4>Determining the language</h4><p>The requested language is determined by the "Accept-Language" field in the HTTP header, but this selection can be overwritten programmatically by requesting a specific file, for example:</p><pre><code class="code">T.force('it-it')</code></pre><p>which reads the "languages/it-it.py" language file. Language files can be created and edited via the administrative interface.</p><p>You can also force a per-string language:</p><pre><code class="code">T("Hello World", language="it-it")</code></pre><blockquote>In the case multiple languages are requested, for example "it-it, fr-ft", web2py tries to locate "it-it.py" and "fr-fr.py" translation files. If none of the requested files is present, it tries to fall back on "it.py" and "fr.py". If these files are not present it defaults to "default.py". If this is not present either, it default to no-translation. The more general rule is that web2py tries "xx-xy-yy.py", "xx-xy.py", "xx.py", "default.py" for each of the "xx-xy-yy" accepted languages trying to find the closest match to the visitor's preferences.</blockquote><p>You can turn off translations completely via</p><pre><code class="code">T.force(None)</code></pre><p>Normally, string translation is evaluated lazily when the view is rendered; hence, the translator <code>force</code> method should not be called inside a view.</p><p>It is possible to disable lazy evaluation via</p><pre><code class="code">T.lazy = False</code></pre><p>In this way, strings are translated inmediately by the <code>T</code> operator based on the currently accepted or forced language.</p><p>It is also possible to disable lazy evaluation for individual strings:</p><pre><code class="code">T("Hello World", lazy=False)</code></pre><p>A common issue is the following. The original application is in English. Suppose that there is a translation file (for example Italian, "it-it.py") and the HTTP client declares that it accepts both English (en) and Italian (it-it) in that order. The following unwanted situation occurs: web2py does not know the default is written in English (en). Therefore, it prefers translating everything into Italian (it-it) because it only found the Italian translation file. If it had not found the "it-it.py" file, it would have used the default language strings (English).</p><p>There are two solutions for this problem: create a translation language for English, which would be redundant and unnecessary, or better, tell web2py which languages should use the default language strings (the strings coded into the application). This can be done with:</p><pre><code class="code">T.set_current_languages('en', 'en-en')</code></pre><p>It stores in  <code>T.current_languages</code> a list of languages that do not require translation and forces a reload of the language files.</p><p>Notice that "it" and "it-it" are different languages from the point of view of web2py. To support both of them, one would need two translation files, always lower case. The same is true for all other languages.</p><p>The currently accepted language is stored in</p><pre><code class="code">T.accepted_language</code></pre><h4>Translating variables</h4><p>T(...) does not only translate strings but it can also transate values stored in variables:</p><pre><code class="code">&gt;&gt;&gt; a="test"
&gt;&gt;&gt; print T(a)</code></pre><p>In this case the word "test" is translated but, if not found and if the filesystem is writable, it will add it to the list of words to be translated in the language file.</p><p>Notice that this can result in lots of file IO and you may want to disable it:</p><pre><code class="code">T.is_writable = False</code></pre><p>prevents T from dynamically updating language files.</p><h4>Comments and multiple translations</h4><p>It is possible that the same string appears in different contexts in the application and needs different translations based on context. In order to do this, one can add comments to the original string. The comments will not be rendered but will be used by web2py to determine the most appropriate translation. For example:</p><pre><code class="code">T("hello world ## first occurrence")
T("hello world ## second occurrence")</code></pre><p>The text following the <code>##</code>, including the double <code>##</code>, are comments.</p><h4>Pluralization engine</h4><p>Since version 2.0, web2py includes a powerful pluralization system (PS). This means that when text marked for translation depends on a numeric variable, it may be translated differently based on the numeric value. For example in English we may render:</p><pre><code>x book(s)</code></pre><p>with</p><pre><code>a book (x==1)
5 books (x==5)</code></pre><p>English has one singular form and one plural form. The plural form is constructed by adding a "-s" or "-es" or using an exceptional form. web2py provides a way to define pluralization rules for each languages, as well as exceptions to the default rules. In fact web2py already knows pluralization rules for many languages. It knows, for example, that Slovenian has one singular form and 3 plural forms (for x==1, x==3 or x==4 and x&gt;4). These rules are encoded in "gluon/contrib/plural_rules/*.py" files and new files can be created. Explicit pluralizations for words are created by editing pluralization files using the administrative interface.</p><p>By default the PS is not activated. It is triggered by the <code>symbol</code> argument of the <code>T</code> function. For example:</p><pre><code class="code">T("You have %s %%{book}", symbols=10)</code></pre><p>Now the PS is activated for the word "book" and for the number 10. The result in English will be: "You have 10 books". Notice that "book" has been pluralized into "books".</p><p>The PS consists of 3 parts:</p><ul><li>placeholders <code>%%{}</code> to mark words in the <code>T</code> input</li><li>rule to give a decision which word form to use ("rules/plural_rules/*.py")</li><li>dictionary with word plural forms ("app/languages/plural-*.py")</li></ul><p>The value of symbols can be a single variable, a list/tuple of variables, or a dictionary.</p><p>The placeholder <code>%%{}</code> consists of 3 parts:</p><pre><code>%%{[&lt;modifier&gt;]&lt;word&gt;[&lt;parameter&gt;]},</code></pre><p>where:</p><pre><code>&lt;modifier&gt;::= ! | !! | !!!
&lt;word&gt; ::= any word or phrase in singular in lower case (!)
&lt;parameter&gt; ::= [index] | (key) | (number)</code></pre><p>For example:</p><ul><li><code>%%{word}</code> is equivalent to <code>%%{word[0]}</code> (if no modifiers are used).</li><li><code>%%{word[index]}</code> is used when symbols is a tuple. symbols[index] gives us a number used to make a decision on which word form to choose.</li><li><code>%%{word(key)}</code> is used to get the numeric parameter from symbols[key]</li><li><code>%%{word(number)}</code> allows to set a <code>number</code> directly (e.g.: <code>%%{word(%i)}</code>)</li><li><code>%%{?word?number}</code> returns "word" if <code>number==1</code>, returns the <code>number</code> otherwise</li><li><code>%%{?number} or %%{??number}</code> returns <code>number</code> if <code>number!=1</code>, return nothing otherwise</li></ul><code>T("blabla %s %%{word}", symbols=var)</code><p><code>%%{word}</code> by default means <code>%%{word[0]}</code>, where <code>[0]</code> is an item index in symbols tuple.</p><code>T("blabla %s %s %%{word[1]}", (var1, var2))</code><p>PS is used for "word" and "var2" respectively.</p><p>You can use several <code>%%{}</code> placeholders with one index:</p><code>T("%%{this} %%{is} %s %%{book}", var)</code><p>or</p><code>T("%%{this[0]} %%{is[0]} %s %%{book[0]}", var)</code><p>They generate:</p><pre><code>var  output
------------------
 1   this is 1 book
 2   these are 2 books
 3   these are 2 books</code></pre><p>Similarly you can pass a dictionary to symbols:</p><pre><code>T("blabla %(var1)s %(wordcnt)s %%{word(wordcnt)}",
  dict(var1="tututu", wordcnt=20))</code></pre><p>which produces</p><pre><code>blabla tututu 20 words</code></pre><p>You can replace "1" with any word you wish by this placeholder <code>%%{?word?number}</code>. For example</p><code>T("%%{this} %%{is} %%{?a?%s} %%{book}", var)</code><p>produces:</p><pre><code>var  output
------------------
 1   this is a book
 2   these are 2 books
 3   these are 3 books
 ...</code></pre><p>Inside <code>%%{...}</code> you can also use the following modifiers:</p><ul><li><code>!</code> to capitalize the text (equivalent to <code>string.capitalize</code>)</li><li><code>!!</code> to capitalize every word (equivalent to <code>string.title</code>)</li><li><code>!!!</code> to capitalize every character (equivalent to <code>string.upper</code>)</li></ul><p>Notice you can use \ to escape <code>!</code> and <code>?</code>.</p><h4>Translations, pluralization, and MARKMIN</h4><p>You can also use the powerful MARKMIN syntax inside translation strings by replacing</p><pre><code class="code">T("hello world")</code></pre><p>with</p><pre><code>T.M("hello world")</code></pre><p>Now the string accepts MARKMIN markup as described in <a href="../05#markmin_markmin_syntax">Chapter 5</a></p><h3>Cookies</h3><div class="inxx">cookies</div><p>web2py uses the Python cookies modules for handling cookies.</p><p>Cookies from the browser are in <code>request.cookies</code> and cookies sent by the server are in <code>response.cookies</code>.</p><p>You can set a cookie as follows:</p><pre><code class="code">response.cookies['mycookie'] = 'somevalue'
response.cookies['mycookie']['expires'] = 24 * 3600
response.cookies['mycookie']['path'] = '/'</code></pre><p>The second line tells the browser to keep the cookie for 24 hours. The third line tells the browser to send the cookie back to any application (URL path) at the current domain. Note, if you do not specify a path for the cookie, the browser will assume the path of the URL that was requested, so the cookie will only be returned to the server when that same URL path is requested.</p><p>The cookie can be made secure with:</p><pre><code class="code">response.cookies['mycookie']['secure'] = True</code></pre><p>This tells the browser only to send the cookie back over HTTPS and not over HTTP.</p><p>The cookie can be retrieved with:</p><pre><code class="code">if request.cookies.has_key('mycookie'):
    value = request.cookies['mycookie'].value</code></pre><p>Unless sessions are disabled, web2py, under the hood, sets the following cookie and uses it to handle sessions:</p><pre><code class="code">response.cookies[response.session_id_name] = response.session_id
response.cookies[response.session_id_name]['path'] = "/"</code></pre><p>Note, if a single application includes multiple subdomains, and you want to share the session across those subdomains (e.g., sub1.yourdomain.com, sub2.yourdomain.com, etc.), you must explicitly set the domain of the session cookie as follows:</p><pre><code class="code">if not request.env.remote_addr in ['127.0.0.1', 'localhost']:
    response.cookies[response.session_id_name]['domain'] = ".yourdomain.com"</code></pre><p>The above can be useful if, for example, you want to allow the user to remain logged in across subdomains.</p><h3>Application <strong>init</strong></h3><div class="inxx">init</div><p>When you deploy web2py, you will want to set a default application, i.e., the application that starts when there is an empty path in the URL, as in:</p><pre><code class="code">http://127.0.0.1:8000</code></pre><p>By default, when confronted with an empty path, web2py looks for an application called <strong>init</strong>. If there is no init application it looks for an application called <strong>welcome</strong>.</p><div class="inxx">default_application</div><p>The name of the default application can be changed from <strong>init</strong> to another name by setting <code>default_application</code> in routes.py:</p><pre><code class="code">default_application = "myapp"</code></pre><p>Note: <code>default_application</code> first appeared in web2py version 1.83.</p><p>Here are four ways to set the default application:</p><ul><li>Call your default application "init".</li><li>Set <code>default_application</code> to your application's name in routes.py</li><li>Make a symbolic link from "applications/init" to your application's folder.</li><li>Use URL rewrite as discussed in the next section.</li></ul><h3>URL rewrite</h3><div class="inxx">url rewrite</div><div class="inxx">routes_in</div><div class="inxx">routes_out</div><p>web2py has the ability to rewrite the URL path of incoming requests prior to calling the controller action (URL mapping), and conversely, web2py can rewrite the URL path generated by the <code>URL</code> function (reverse URL mapping). One reason to do this is for handling legacy URLs, another is to simplify paths and make them shorter.</p><p>web2py includes two distinct URL rewrite systems: an easy-to-use <em>parameter-based</em> system for most use cases, and a flexible <em>pattern-based</em> system for more complex cases. To specify the URL rewrite rules, create a new file in the "web2py" folder called <code>routes.py</code> (the contents of <code>routes.py</code> will depend on which of the two rewrite systems you choose, as described in the next two sections). The two systems cannot be mixed.</p><blockquote>Notice that if you edit routes.py, you must reload it. This can be done in two ways: by restarting the web server or by clicking on the routes reload button in admin. If there is a bug in routes, they will not reload.</blockquote><h4>Parameter-based system</h4><p>The parameter-based (parametric) router provides easy access to several "canned" URL-rewrite methods. Its capabilities include:</p><ul><li>Omitting default application, controller and function names from externally-visible URLs (those created by the URL() function)</li><li>Mapping domains (and/or ports) to applications or controllers</li><li>Embedding a language selector in the URL</li><li>Removing a fixed prefix from incoming URLs and adding it back to outgoing URLs</li><li>Mapping root files such as /robots.txt to an applications static directory</li></ul><p>The parametric router also provides somewhat more flexible validation of incoming URLs.</p><p>Suppose you've written an application called <code>myapp</code> and wish to make it the default, so that the application name is no longer part of the URL as seen by the user. Your default controller is still <code>default</code>, and you want to remove its name from user-visible URLs as well. Here's what you put in <code>routes.py</code>:</p><pre><code class="code">routers = dict(
  BASE  = dict(default_application='myapp'),
)</code></pre><p>That's it. The parametric router is smart enough to know how to do the right thing with URLs such as:</p><pre><code class="code">http://domain.com/myapp/default/myapp</code></pre><p>or</p><pre><code class="code">http://domain.com/myapp/myapp/index</code></pre><p>where normal shortening would be ambiguous. If you have two applications, <code>myapp</code> and <code>myapp2</code>, you'll get the same effect, and additionally <code>myapp2</code>'s default controller will be stripped from the URL whenever it's safe (which is mostly all the time).</p><p>Here is another case: suppose you want to support URL-based languages, where your URLs look like this:</p><pre><code class="code">http://myapp/en/some/path</code></pre><p>or (rewritten)</p><pre><code class="code">http://en/some/path</code></pre><p>Here's how:</p><pre><code class="code">routers = dict(
  BASE  = dict(default_application='myapp'),
  myapp = dict(languages=['en', 'it', 'jp'], default_language='en'),
)</code></pre><p>Now an incoming URL like this:</p><pre><code class="code">http:/domain.com/it/some/path</code></pre><p>will be routed to <code>/myapp/some/path</code>, and request.uri_language will be set to 'it', so you can force the translation. You can also have language-specific static files.</p><pre><code class="code">http://domain.com/it/static/filename</code></pre><p>will be mapped to:</p><pre><code class="code">applications/myapp/static/it/filename</code></pre><p>if that file exists. If it doesn't, then URLs like:</p><pre><code class="code">http://domain.com/it/static/base.css</code></pre><p>will still map to:</p><pre><code class="code">applications/myapp/static/base.css</code></pre><p>(because there is no <code>static/it/base.css</code>).</p><p>So you can now have language-specific static files, including images, if you need to.  Domain mapping is supported as well:</p><pre><code class="code">routers = dict(
  BASE  = dict(
      domains = {
          'domain1.com' : 'app1',
          'domain2.com' : 'app2',
      }
  ),
)</code></pre><p>does what you'd expect.</p><pre><code class="code">routers = dict(
  BASE  = dict(
      domains = {
          'domain.com:80'  : 'app/insecure',
          'domain.com:443' : 'app/secure',
      }
  ),
)</code></pre><p>maps <code>http://domain.com</code> accesses to the controller named <code>insecure</code>, while <code>HTTPS</code> accesses go to the <code>secure</code> controller. Alternatively, you can map different ports to different apps, in the obvious way.</p><p>For further information, please consult the file <a href="https://github.com/web2py/web2py/blob/master/examples/routes.parametric.example.py">"routes.parametric.example.py"</a> provided in the "examples" folder of the standard web2py distribution.</p><p>Note: The <em>parameter-based</em> system first appeared in web2py version 1.92.1.</p><h4>Pattern-based system</h4><p>Although the <em>parameter-based</em> system just described should be sufficient for most use cases, the alternative <em>pattern-based</em> system provides some additional flexibility for more complex cases. To use the pattern-based system, instead of defining routers as dictionaries of routing parameters, you define two lists (or tuples) of 2-tuples, <code>routes_in</code> and <code>routes_out</code>. Each tuple contains two elements: the pattern to be replaced and the string that replaces it. For example:</p><pre><code class="code">routes_in = (
  ('/testme', '/examples/default/index'),
)
routes_out = (
  ('/examples/default/index', '/testme'),
)</code></pre><p>With these routes, the URL:</p><pre><code class="code">http://127.0.0.1:8000/testme</code></pre><p>is mapped into:</p><pre><code class="code">http://127.0.0.1:8000/examples/default/index</code></pre><p>To the visitor, all links to the page URL looks like <code>/testme</code>.</p><p>The patterns have the same syntax as Python regular expressions. For example:</p><pre><code class="code">  ('.*.php', '/init/default/index'),</code></pre><p>maps all URLs ending in ".php" to the index page.</p><p>The second term of a rule can also be a redirection to another page:</p><pre><code class="code">  ('.*.php', '303-&gt;http://example.com/newpage'),</code></pre><p>Here 303 is the HTTP code for the redirect response.</p><p>Sometimes you want to get rid of the application prefix from the URLs because you plan to expose only one application. This can be achieved with:</p><pre><code class="code">routes_in = (
  ('/(?P&lt;any&gt;.*)', '/init/\g&lt;any&gt;'),
)
routes_out = (
  ('/init/(?P&lt;any&gt;.*)', '/\g&lt;any&gt;'),
)</code></pre><p>There is also an alternative syntax that can be mixed with the regular expression notation above. It consists of using <code>$name</code> instead of <code>(?P&lt;name&gt;\w+)</code> or <code>\g&lt;name&gt;</code>. For example:</p><pre><code class="code">routes_in = (
  ('/$c/$f', '/init/$c/$f'),
)

routes_out = (
  ('/init/$c/$f', '/$c/$f'),
)</code></pre><p>would also eliminate the "/example" application prefix in all URLs.</p><p>Using the <code>$name</code> notation, you can automatically map <code>routes_in</code> to <code>routes_out</code>, provided you don't use any regular expressions. For example:</p><pre><code class="code">routes_in = (
  ('/$c/$f', '/init/$c/$f'),
)

routes_out = [(x, y) for (y, x) in routes_in]</code></pre><p>If there are multiple routes, the first to match the URL is executed. If no pattern matches, the path is left unchanged.</p><p>You can use <code>$anything</code> to match anything (<code>.*</code>) until the end of the line.</p><p>Here is a minimal "routes.py" for handling favicon and robots requests:</p><p><div class="inxx">favicon</div> <div class="inxx">robots</div></p><pre><code class="code">routes_in = (
  ('/favicon.ico', '/examples/static/favicon.ico'),
  ('/robots.txt', '/examples/static/robots.txt'),
)
routes_out = ()</code></pre><p>Here is a more complex example that exposes a single app "myapp" without unnecessary prefixes but also exposes <strong>admin</strong>, <strong>appadmin</strong> and static:</p><pre><code class="code">routes_in = (
  ('/admin/$anything', '/admin/$anything'),
  ('/static/$anything', '/myapp/static/$anything'),
  ('/appadmin/$anything', '/myapp/appadmin/$anything'),
  ('/favicon.ico', '/myapp/static/favicon.ico'),
  ('/robots.txt', '/myapp/static/robots.txt'),
)
routes_out = [(x, y) for (y, x) in routes_in[:-2]]</code></pre><p>The general syntax for routes is more complex than the simple examples we have seen so far. Here is a more general and representative example:</p><pre><code class="code">routes_in = (
 ('140.191.\d+.\d+:https?://www.web2py.com:post /(?P&lt;any&gt;.*).php',
  '/test/default/index?vars=\g&lt;any&gt;'),
)</code></pre><p>It maps <code>http</code> or <code>https</code> <code>POST</code> requests (note lower case "post") to host <code>www.web2py.com</code> from a remote IP matching the regular expression</p><pre><code class="code">'140.191.\d+.\d+'</code></pre><p>requesting a page matching the regular expression</p><pre><code class="code">'/(?P&lt;any&gt;.*).php'</code></pre><p>into</p><pre><code class="code">'/test/default/index?vars=\g&lt;any&gt;'</code></pre><p>where <code>\g&lt;any&gt;</code> is replaced by the matching regular expression.</p><p>The general syntax is</p><pre><code class="code">'[remote address]:[protocol]://[host]:[method] [path]'</code></pre><p>If the first section of the pattern (all but <code>[path]</code>) is missing, web2py provides a default:</p><pre><code class="code">'.*?:https?://[^:/]+:[a-z]+'</code></pre><p>The entire expression is matched as a regular expression, so "." must be escaped and any matching subexpression can be captured using <code>(?P&lt;...&gt;...)</code> using Python regex syntax. The request method (typically GET or POST) must be lower case. The URL being matched has had any <code>%xx</code> escapes unquoted.</p><p>This allows to reroute requests based on the client IP address or domain, based on the type of the request, on the method, and the path. It also allows web2py to map different virtual hosts into different applications. Any matched subexpression can be used to build the target URL and, eventually, passed as a GET variable.</p><p>All major web servers, such as Apache and lighttpd, also have the ability to rewrite URLs. In a production environment that may be an option instead of <code>routes.py</code>. Whatever you decide to do we strongly suggest that you do not hardcode internal URLs in your app and use the URL function to generate them. This will make your application more portable in case routes should change.</p><h5>Application-Specific URL rewrite</h5><div class="inxx">routes_app</div><p>When using the pattern-based system, an application can set its own routes in an application-specific routes.py file located in the applications base folder. This is enabled by configuring <code>routes_app</code> in the base routes.py to determine from an incoming URL the name of the application to be selected. When this happens, the application-specific routes.py is used in place of the base routes.py.</p><p>The format of <code>routes_app</code> is identical to <code>routes_in</code>, except that the replacement pattern is simply the application name. If applying <code>routes_app</code> to the incoming URL does not result in an application name, or the resulting application-specific routes.py is not found, the base routes.py is used as usual.</p><p>Note: <code>routes_app</code> first appeared in web2py version 1.83.</p><h5>Default application, controller, and function</h5><div class="inxx">default_application</div><div class="inxx">default_controller</div><div class="inxx">default_function</div><p>When using the pattern-based system, the name of the default application, controller, and function can be changed from <strong>init</strong>, <strong>default</strong>, and <strong>index</strong> respectively to another name by setting the appropriate value in routes.py:</p><pre><code class="code">default_application = "myapp"
default_controller = "admin"
default_function = "start"</code></pre><p>Note: These items first appeared in web2py version 1.83.</p><h4>Routes on error</h4><div class="inxx">routes_onerror</div><p>You can also use <code>routes.py</code> to re-route requests to special actions in case there is an error on the server. You can specify this mapping globally, for each app, for each error code, or for each app and error code. Here is an example:</p><pre><code class="code">routes_onerror = [
  ('init/400', '/init/default/login'),
  ('init/*', '/init/static/fail.html'),
  ('*/404', '/init/static/cantfind.html'),
  ('*/*', '/init/error/index')
]</code></pre><p>For each tuple, the first string is matched against "[app name]/[error code]". If a match is found, the failed request is re-routed to the URL in the second string of the matching tuple. If the error handling URL is a not a static file, the following GET variables will be passed to the error action:</p><ul><li><code>code</code>: the HTTP status code (e.g., 404, 500)</li><li><code>ticket</code>: in the form of "[app name]/[ticket number]" (or "None" if no ticket)</li><li><code>requested_uri</code>: equivalent to <code>request.env.request_uri</code></li><li><code>request_url</code>: equivalent to <code>request.url</code></li></ul><p>These variables will be accessible to the error handling action via <code>request.vars</code> and can be used in generating the error response. In particular, it is a good idea for the error action to return the original HTTP error code instead of the default 200 (OK) status code. This can be done by setting <code>response.status = request.vars.code</code>. It is also possible to have the error action send (or queue) an email to an administrator, including a link to the ticket in <code>admin</code>.</p><p>Unmatched errors display a default error page. This default error page can also be customized here (see "routes.parametric.example.py" and "routes.patterns.example.py" in the "examples" folder):</p><pre><code class="code">error_message = '&lt;html&gt;&lt;body&gt;&lt;h1&gt;%s&lt;/h1&gt;&lt;/body&gt;&lt;/html&gt;'
error_message_ticket = '''&lt;html&gt;&lt;body&gt;&lt;h1&gt;Internal error&lt;/h1&gt;
     Ticket issued: &lt;a href="/admin/default/ticket/%(ticket)s"
     target="_blank"&gt;%(ticket)s&lt;/a&gt;&lt;/body&gt;&lt;/html&gt;'''</code></pre><p>The first variable contains the error message when an invalid application or function is requested. The second variable contains the error message when a ticket is issued.</p><p><code>routes_onerror</code> work with both routing mechanisms.</p><div class="inxx">error_handler</div><p>In "routes.py" you can also specify an action in charge of error handling:</p><pre><code class="code">error_handler = dict(application='error',
                      controller='default',
                      function='index')</code></pre><p>If the <code>error_handler</code> is specified the action is called without user redirection and the handler action will be in charge of dealing with the error. In the event that the error-handling page itself returns an error, web2py will fall back to its old static responses.</p><h4>Static asset management</h4><p>Since version 2.1.0, web2py has the ability to manage static assets.</p><p>When an application is in development, static file can change often, therefore web2py sends static files with no cache headers. This has the side-effect of "forcing" the browser to request static files at every request. This results in low performance when loading the page.</p><p>In a "production" site, you may want to serve static files with <code>cache</code> headers to prevent un-necessary downloads since static files do not change.</p><p><code>cache</code> headers allow the browser to fetch each file only once, thus saving bandwidth and reducing loading time.</p><p>Yet there is a problem: What should the cache headers declare? When should the files expire? When the files are first served, the server cannot forecast when they will be changed.</p><p>A manual approach consists of creating subfolders for different versions of static files. For example an early version of "layout.css" can be made available at the URL "/myapp/static/css/1.2.3/layout.css". When you change the file, you create a new subfolder and you link it as "/myapp/static/css/1.2.4/layout.css".</p><p>This procedure works but it is pedantic since every time you update the css file, you must remember to move it to another folder, change the URL of the file in your layout.html and deploy.</p><p>Static asset management solves the problem by allowing the developer to declare a version for a group of static files and they will be requested again only when the version number changes. The asset version number is made part of the file url as in the previous example. The difference from the previous approach is that the version number only appears in the URL, not in the file system.</p><p>If you want to serve "/myapp/static/layout.css" with the cache headers, you just need to include the file with a modified URL that includes a version number:</p><pre><code>/myapp/static/_1.2.3/layout.css</code></pre><p>(notice the URL defines a version number, it does not appear anywhere else).</p><p>Notice that the URL starts with "/myapp/static/", followed by a version number composed by an underscore and 3 integers separated by a period (as described in <a href="http://semver.org/">SemVer</a>), then followed by the filename. Also notice that you do not have to create a "_1.2.3/" folder.</p><p>Every time the static file is requested with a version in the url, it will be served with "far in the future" cache headers, specifically:</p><pre><code>Cache-Control : max-age=315360000
Expires: Thu, 31 Dec 2037 23:59:59 GMT</code></pre><p>This means that the browser will fetch those files only once, and they will be saved "forever" in the browser's cache.</p><p>Every time the "_1.2.3/filename" is requested, web2py will remove the version part from the path and serve your file with far in the future headers so they will be cached forever. If you changed the version number in the URL, this tricks the browser into thinking it is requesting a different file, and the file is fetched again.</p><p>You can use "_1.2.3", "_0.0.0", "_999.888.888", as long as the version starts with underscore followed by three numbers separated by period.</p><p>When in development, you can use <code>response.files.append(...)</code> to link the static URLs of static files. In this case you can include the "_1.2.3/" part manually, or you take advantage of a new parameter of the response object: <code>response.static_version</code>. Just include the files the way you used to, for example</p><pre><code>{{response.files.append(URL('static','layout.css'))}}</code></pre><p>and in models set</p><pre><code class="code">response.static_version = '1.2.3'</code></pre><p>This will rewrite automatically every "/myapp/static/layout.css" url as "/myapp/static/_1.2.3/layout.css", for every file included in <code>response.files</code>.</p><p>Often in production you let the webserver (apache, nginx, etc.) serve the static files. You need to adjust your configuration in such a way that it will "skip" the "_1.2.3/" part.</p><p>For example, in Apache, change this:</p><pre><code>AliasMatch ^/([^/]+)/static/(.*)    /home/www-data/web2py/applications/$1/static/$2</code></pre><p>into this:</p><pre><code>AliasMatch ^/([^/]+)/static/(?:_[\d]+.[\d]+.[\d]+/)?(.*)    /home/www-data/web2py/applications/$1/static/$2</code></pre><p>Similarly, in Nginx change this:</p><pre><code>location ~* /(\w+)/static/ {
    root /home/www-data/web2py/applications/;
    expires max;
}</code></pre><p>into this:</p><pre><code>location ~* /(\w+)/static(?:/_[\d]+.[\d]+.[\d]+)?/(.*)$ {
   alias /home/www-data/web2py/applications/$1/static/$2;
   expires max;
}</code></pre><h3>Running tasks in the background</h3><p>In web2py, every HTTP request is served in its own thread. Threads are recycled for efficiency and managed by the web server. For security, the web server sets a time-out on each request. This means that actions should not run tasks that take too long, should not create new threads, and should not fork processes (it is possible but not recommended).</p><p>The proper way to run time-consuming tasks is doing it in the background. There is not a single way of doing it, but here we describe three mechanisms that are built into web2py: <strong>cron</strong>, <strong>homemade task queues</strong>, and <strong>scheduler</strong>.</p><p>By <strong>cron</strong> we refer to a web2py functionality not to the Unix Cron mechanism. The web2py cron works on windows too.</p><p>web2py cron is the way to go if you need tasks in the background at scheduled times and these tasks take a relatively short time compared to the time interval between two calls. Each task runs in its own process, and multiple tasks can run concurrently, but you have no control over how many tasks run. If accidentally one task overlaps with itself, it can cause a database lock and a spike in memory usage.</p><p>web2py scheduler takes a different approach. The number of running processes is fixed, and they can run on different machines. Each process is called a worker. Each worker picks a task when available and executes it as soon as possible after the time when it is scheduled to run, but not necessarily at that exact time. There cannot be more processes running than the number of scheduled tasks and therefore no memory spikes. Scheduler tasks can be defined in models and are stored in the database. The web2py scheduler does not implement a distributed queue since it assumes that the time to distribute tasks is negligible compared with the time to run the tasks. Workers pick up the task from the database.</p><p>Homemade tasks queues can be a simpler alternative to the web2py scheduler in some cases.</p><h4>Cron</h4><div class="inxx">cron</div><p>The web2py cron provides the ability for applications to execute tasks at preset times, in a platform-independent manner.</p><p>For each application, cron functionality is defined by a crontab file:</p><pre><code>app/cron/crontab</code></pre><p>It follows the syntax defined in ref. <sup>[<a href="/web2py_book/default/reference/29/cron" target="_blank">cron</a>]</sup> (with some extensions that are specific to web2py).</p><blockquote>Before web2py 2.1.1, cron was enabled by default and could be disabled with the <code>-N</code> command line option. Since 2.1.1, cron is disabled by default and can be enabled by the <code>-Y</code> option. This change was motivated by the desire to push users toward using the new scheduler (which is superior to the cron mechanism) and also because cron may impact on performance.</blockquote><p>This means that every application can have a separate cron configuration and that cron config can be changed from within web2py without affecting the host OS itself.</p><p>Here is an example:</p><pre><code class="code">0-59/1  *  *  *  *  root python /path/to/python/script.py
30      3  *  *  *  root *applications/admin/cron/db_vacuum.py
*/30    *  *  *  *  root **applications/admin/cron/something.py
@reboot root    *mycontroller/myfunction
@hourly root    *applications/admin/cron/expire_sessions.py</code></pre><p>The last two lines in this example use extensions to regular cron syntax to provide additional web2py functionality.</p><blockquote>The file "applications/admin/cron/expire_sessions.py" actually exists and ships with the <strong>admin</strong> app. It checks for expired sessions and deletes them. "applications/admin/cron/crontab" runs this task hourly.</blockquote><p>If the task/script is prefixed with an asterisk (<code>*</code>) and ends with <code>.py</code>, it will be executed in the web2py environment. This means you will have all the controllers and models at your disposal. If you use two asterisks (<code>**</code>), the models will not be executed. This is the recommended way of calling, as it has less overhead and avoids potential locking problems.</p><p>Notice that scripts/functions executed in the web2py environment require a manual <code>db.commit()</code> at the end of the function or the transaction will be reverted.</p><p>web2py does not generate tickets or meaningful tracebacks in shell mode, which is how cron is run, so make sure that your web2py code runs without errors before you set it up as a cron task as you will likely not be able to see those errors when run from cron. Moreover, be careful how you use models: while the execution happens in a separate process, database locks have to be taken into account in order to avoid pages waiting for cron tasks that may be blocking the database. Use the <code>**</code> syntax if you don't need to use the database in your cron task.</p><p>You can also call a controller function, in which case there is no need to specify a path. The controller and function will be that of the invoking application. Take special care about the caveats listed above. Example:</p><pre><code class="code">*/30  *  *  *  *  root *mycontroller/myfunction</code></pre><p>If you specify <code>@reboot</code> in the first field in the crontab file, the given task will be executed only once, at web2py startup. You can use this feature if you want to pre-cache, check, or initialize data for an application on web2py startup. Note that cron tasks are executed in parallel with the application --- if the application is not ready to serve requests until the cron task is finished, you should implement checks to reflect this. Example:</p><pre><code class="code">@reboot  root *mycontroller/myfunction</code></pre><p>Depending on how you are invoking web2py, there are four modes of operation for web2py cron.</p><ul><li><em>soft cron</em>: available under all execution modes</li><li><em>hard cron</em>: available if using the built-in web server (either directly or via Apache mod_proxy)</li><li><em>external cron</em>: available if you have access to the system's own cron service</li><li>No cron</li></ul><p>The default is hard cron if you are using the built-in web server; in all other cases, the default is soft cron.  Soft cron is the default method if you are using CGI, FASTCGI or WSGI (but note that soft cron is not <code>enabled</code> by default in the standard <code>wsgihandler.py</code> file provided with web2py).</p><p>Your tasks will be executed on the first call (page load) to web2py after the time specified in crontab; but only after processing the page, so no delay will be observed by the user. Obviously, there is some uncertainty regarding precisely when the task will be executed, depending on the traffic the site receives. Also, the cron task may get interrupted if the web server has a page load timeout set. If these limitations are not acceptable, see <em>external cron</em>. Soft cron is a reasonable last resort, but if your web server allows other cron methods, they should be preferred over soft cron.</p><p>Hard cron is the default if you are using the built-in web server (either directly or via Apache mod_proxy). Hard cron is executed in a parallel thread, so unlike soft cron, there are no limitations with regard to run time or execution time precision.</p><p>External cron is not default in any scenario, but requires you to have access to the system cron facilities. It runs in a parallel process, so none of the limitations of soft cron apply. This is the recommended way of using cron under WSGI or FASTCGI.</p><p>Example of line to add to the system crontab, (usually /etc/crontab):</p><pre><code class="code">0-59/1 * * * * web2py cd /var/www/web2py/ &amp;&amp; python web2py.py -J -C -D 1 &gt;&gt; /tmp/cron.output 2&gt;&amp;1</code></pre><p>With external <code>cron</code>, make sure to add either <code>-J</code> (or <code>--cronjob</code>, which is the same) as indicated above so that web2py knows that task is executed by cron. Web2py sets this internally with soft and hard <code>cron</code>.</p><h4>Homemade task queues</h4><p>While cron is useful to run tasks at regular time intervals, it is not always the best solution to run a background task. For this purpose web2py provides the ability to run any python script as if it were inside a controller:</p><pre><code class="code">python web2py.py -S app -M -R applications/app/private/myscript.py -A a b c</code></pre><p>where <code>-S app</code> tells web2py to run "myscript.py" as "app", <code>-M</code> tells web2py to execute models, and <code>-A a b c</code> passes optional command line arguments <code>sys.args=['a','b','c']</code> to "myscript.py".</p><p>This type of background process should not be executed via cron (except perhaps for cron @reboot) because you need to be sure that no more than one instance is running at the same time. With cron it is possible that a process starts at cron iteration 1 and is not completed by cron iteration 2, so cron starts it again, and again, and again - thus jamming the mail server.</p><p>In chapter 8, we will provide an example of how to use the above method to send emails.</p><h4>Scheduler</h4><p>Prior to version 2.6.0 the scheduler was considered experimental. From v2.6.0 the documented API is stable. The stable API consists of these functions:</p><ul><li>disable()</li><li>resume()</li><li>terminate()</li><li>kill()</li><li>queue_task(),</li><li>task_status()</li><li>stop_task()</li></ul><p>The web2py scheduler works very much like the task queue described in the previous sub-section with some differences:</p><ul><li>It provides a standard mechanism for creating, scheduling, and monitoring tasks.</li><li>There is not a single background process but a set of workers processes.</li><li>The job of worker nodes can be monitored because their state, as well as the state of the tasks, is stored in the database.</li><li>It works without web2py but that is not documented here.</li></ul><p>The scheduler does not use cron, although one can use cron @reboot to start the worker nodes.</p><p>More information about deploying the scheduler under Linux and Windows is in the Deployment recipes chapter.</p><p>In the scheduler, a task is simply a function defined in a model (or in a module and imported by a model). For example:</p><pre><code class="code">def task_add(a,b):
    return a+b</code></pre><p>Tasks will always be called in the same environment seen by controllers and therefore they see all the global variables defined in models, including database connections (<code>db</code>). Tasks differ from a controller action because they are not associated with an HTTP request and therefore there is no <code>request.env</code>. Also, tasks can access another environmental variable that is not present in normal requests: <code>W2P_TASK</code>. <code>W2P_TASK.id</code> holds the <code>scheduler_task.id</code> and <code>W2P_TASK.uuid</code> the <code>scheduler_task.uuid</code> field of the task that is running.</p><blockquote>Remember to call <code>db.commit()</code> at the end of every task if it involves inserts/updates to the database. web2py commits by default at the end of a successful action but the scheduler tasks are not actions.</blockquote><p>To enable the scheduler you must instantiate the Scheduler class in a model. The recommended way to enable the scheduler to your app is to create a model file named <code>scheduler.py</code> and define your function there. After the functions, you can put the following code into the model:</p><pre><code class="code">from gluon.scheduler import Scheduler
scheduler = Scheduler(db)</code></pre><p>If your tasks are defined in a module (as opposed to a model) you may have to restart the workers.</p><p>The task is scheduled with</p><pre><code class="code">scheduler.queue_task(task_add,pvars=dict(a=1,b=2))</code></pre><h5>Parameters</h5><p>The first argument of the <code>Scheduler</code> class must be the database to be used by the scheduler to communicate with the workers. This can be the <code>db</code> of the app or another dedicated <code>db</code>, perhaps one shared by multiple apps. If you use SQLite it's recommended to use a separate db from the one used by your app in order to keep the app responsive. Once the tasks are defined and the <code>Scheduler</code> is instantiated, all that is needed to do is to start the workers. You can do that in several ways:</p><pre><code>python web2py.py -K myapp</code></pre><p>starts a worker for the app <code>myapp</code>. If you want start multiple workers for the same app, you can do so just passing <code>myapp,myapp</code>. You can pass also the <code>group_names</code> (overriding the one set in your model) with</p><pre><code>python web2py.py -K myapp:group1:group2,myotherapp:group1</code></pre><p>If you have a model called <code>scheduler.py</code> you can start/stop the workers from web2py's default window (the one you use to set the ip address and the port).</p><h5>Scheduler Deployment</h5><p>One last nice addition: if you use the embedded webserver, you can start the webserver and the scheduler with just one line of code (this assumes you don't want the web2py window popping up, else you can use the "Schedulers" menu instead)</p><pre><code>python web2py.py -a yourpass -K myapp -X</code></pre><p>You can pass the usual parameters (-i, -p, here -a prevents the window from showing up), pass whatever app in the -K parameter and append a -X. The scheduler will run alongside the webserver!</p><p>Windows users looking to create a service should see the Deployment Recipes chapter.</p><h5>Complete Scheduler signature</h5><p>Scheduler's complete signature is:</p><pre><code class="code">Scheduler(
    db,
    tasks=None,
    migrate=True,
    worker_name=None,
    group_names=None,
    heartbeat=HEARTBEAT,
    max_empty_runs=0,
    discard_results=False,
    utc_time=False
)</code></pre><p>Let's see them in order:</p><ul><li><code>db</code> is the database DAL instance where you want the scheduler tables be placed.</li><li><code>tasks</code> is a dictionary that maps task names into functions. If you do not pass this parameter, function will be searched in the app environment.</li><li><code>worker_name</code> is None by default. As soon as the worker is started, a worker name is generated as hostname-uuid. If you want to specify that, be sure that it's unique.</li><li><code>group_names</code> is by default set to <strong>[main]</strong>. All tasks have a <code>group_name</code> parameter, set to <strong>main</strong> by default. Workers can only pick up tasks of their assigned group.</li></ul><blockquote>NB: This is useful if you have different workers instances (e.g. on different machines) and you want to assign tasks to a specific worker.

NB2: It's possible to assign a worker more groups, and they can be also all the same, as <code>['mygroup','mygroup']</code>. Tasks will be distributed taking into consideration that a worker with group_names <code>['mygroup','mygroup']</code> is able to process the double of the tasks a worker with group_names <code>['mygroup']</code> is.</blockquote><ul><li><code>heartbeat</code> is by default set to 3 seconds. This parameter is the one controlling how often a scheduler will check its status on the <code>scheduler_worker</code> table and see if there are any <strong>ASSIGNED</strong> tasks to itself to process.</li><li><code>max_empty_runs</code> is 0 by default, that means that the worker will continue to process tasks as soon as they are <strong>ASSIGNED</strong>. If you set this to a value of, let's say, 10, a worker will die automatically if it's <strong>ACTIVE</strong> and no tasks are <strong>ASSIGNED</strong> to it for 10 loops. A loop is when a worker searches for tasks, every 3 seconds (or the set <code>heartbeat</code>)</li><li><code>discard_results</code> is False by default. If set to True, no scheduler_run records will be created.</li></ul><blockquote>NB: scheduler_run records will be created as before for <strong>FAILED</strong>, <strong>TIMEOUT</strong> and <strong>STOPPED</strong> tasks's statuses.</blockquote><ul><li><code>utc_time</code> is False by default. If you need to coordinate with workers living in different timezones, or don't have problems with solar/DST times, supplying datetimes from different countries, etc, you can set this to True. The scheduler will honor the UTC time and work leaving the local time aside. Caveat: you need to schedule tasks with UTC times (for start_time, stop_time, and so on.)</li></ul><p>Now we have the infrastructure in place: defined the tasks, told the scheduler about them, started the worker(s). What remains is to actually schedule the tasks</p><h5>Tasks</h5><p>Tasks can be scheduled programmatically or via appadmin. In fact, a task is scheduled simply by adding an entry in the table "scheduler_task", which you can access via appadmin:</p><pre><code>http://127.0.0.1:8000/myapp/appadmin/insert/db/scheduler_task</code></pre><p>The meaning of the fields in this table is obvious. The "args" and "vars"" fields are the values to be passed to the task in JSON format. In the case of the "task_add" above, an example of "args" and "vars" could be:</p><pre><code class="code">args = [3, 4]
vars = {}</code></pre><p>or</p><pre><code class="code">args = []
vars = {'a':3, 'b':4}</code></pre><p>The <code>scheduler_task</code> table is the one where tasks are organized.</p><p>To add tasks via the API, use</p><pre><code>scheduler.queue_task('mytask',...)</code></pre><p>which is documented <a href="#markmin_queue_task_sig">below</a> .</p><h5>Task Lifecycle</h5><p>All tasks follow a lifecycle</p><p><p style="text-align:center"><img src="http://127.0.0.1:8000/web2py_book/default/image/29/ce8edcc3.png" alt="scheduler tasks" /></p></p><p>By default, when you send a task to the scheduler, it is in the <strong>QUEUED</strong> status. If you need it to be executed later, use the <code>start_time</code> parameter (default = now). If for some reason you need to be sure that the task does not get executed after a certain point in time (maybe a request to a web service that shuts down at 1AM, a mail that needs to be sent not after the working hours, etc...) you can set a <code>stop_time</code> (default = None) for it. If your task is NOT picked up by a worker before <code>stop_time</code>, it will be set as <strong>EXPIRED</strong>. Tasks with no <code>stop_time</code> set or picked up <strong>BEFORE</strong> stop_time are <strong>ASSIGNED</strong> to a worker. When a workers picks up a task, its status is set to <strong>RUNNING</strong>.</p><p><strong>RUNNING</strong> tasks may end up:</p><ul><li><strong>TIMEOUT</strong> when more than <code>n</code> seconds passed with <code>timeout</code> parameter (default = 60 seconds).</li><li><strong>FAILED</strong> when an exception is detected,</li><li><strong>COMPLETED</strong> when they successfully complete.</li></ul><p>Values for <code>start_time</code> and <code>stop_time</code> should be datetime objects. To schedule "mytask" to run at 30 seconds from the current time, for example, you would do the following:</p><pre><code class="code">from datetime import timedelta as timed
scheduler.queue_task('mytask',
    start_time=request.now + timed(seconds=30))</code></pre><p>Additionally, you can control how many times a task should be repeated (i.e. you need to aggregate some data at specified intervals). To do so, set the <code>repeats</code> parameter (default = 1 time only, 0 = unlimited). You can influence how many seconds should pass between executions with the <code>period</code> parameter (default = 60 seconds).</p><blockquote>Default behavior: The time period is not calculated between the END of the first round and the START of the next, but from the START time of the first round to the START time of the next cycle). 
This can cause accumulating 'drift' in the start time of a job.
After v 2.8.2, a new parameter <code>prevent_drift</code> was added, defaulting to False. If set to True when queing a task, the start_time parameter will take precedence over the period, preventing drift.</blockquote><p>You can also set how many times the function can raise an exception (i.e. requesting data from a slow web service) and be queued again instead of stopping in <strong>FAILED</strong>  status using the parameter <code>retry_failed</code> (default = 0, -1 = unlimited).</p><p><p style="text-align:center"><img src="http://127.0.0.1:8000/web2py_book/default/image/29/7d8b85e4.png" alt="task repeats" /></p></p><p>Summary: you have</p><ul><li><code>period</code> and <code>repeats</code> to get an automatically rescheduled function</li><li><code>timeout</code> to be sure that a function doesn't exceed a certain amount of time</li><li><code>retry_failed</code> to control how many times the task can "fail"</li><li><code>start_time</code> and <code>stop_time</code> to schedule a function in a restricted timeframe</li></ul><h5><code>queue_task</code> and <code>task_status</code> <span class="anchor" id="markmin_queue_task_sig"></span></h5><p>The method:</p><pre><code class="code">scheduler.queue_task(
    function,
    pargs=[],
    pvars={},
    start_time=now, 		#datetime
    stop_time = None,		#datetime
    timeout = 60,               #seconds
    prevent_drift=False,
    period=60,                  #seconds
    immediate=False,
    repeats = 1
)</code></pre><p>allows you to queue tasks to be executed by workers. It returns a row (see <a href="#markmin_queue_task_return">here</a>), and it takes the following parameters:</p><ul><li><code>function</code> (required): It can be a task name or a reference to an actual function.</li><li><code>pargs</code>: are the arguments to be passed to the task, stored as a Python list.</li><li><code>pvars</code> : are the named arguments to be passed to the task, stored as a Python dictionary.</li><li>all other scheduler_task columns can be passed as keyword arguments; the most important are shown.</li></ul><p>For example:</p><pre><code>scheduler.queue_task('demo1', [1,2])</code></pre><p>does the exact same thing as</p><pre><code class="code">scheduler.queue_task('demo1', pvars={'a':1, 'b':2})</code></pre><p>as</p><pre><code class="code">st.validate_and_insert(function_name='demo1', args=json.dumps([1,2]))</code></pre><p>and as:</p><pre><code class="code">st.validate_and_insert(function_name='demo1', vars=json.dumps({'a':1,'b':2}))</code></pre><p>Here is a more complex complete example:</p><pre><code class="code">def task_add(a,b):
    return a+b

scheduler = Scheduler(db, tasks=dict(demo1=task_add))

scheduler.queue_task('demo1', pvars=dict(a=1,b=2),
                     repeats = 0, period = 180)</code></pre><p>Since version 2.4.1 if you pass an additional parameter <code>immediate=True</code> it will force the main worker to reassign tasks. Until 2.4.1, the worker checks for new tasks every 5 cycles (so, <code>5*heartbeats</code> seconds). If you had an app that needed to check frequently for new tasks, to get a <em>snappy</em> behaviour you were forced to lower the <code>heartbeat</code> parameter, putting the db under pressure for no reason. With <code>immediate=True</code> you can force the check for new tasks: it will happen at most as <code>heartbeat</code> seconds are passed</p><p>A call to <code>scheduler.queue_task</code> returns the task <code>id</code> and <code>uuid</code> of the task you queued (can be the one you passed or the auto-generated one), and possible <code>errors</code>: <span class="anchor" id="markmin_queue_task_return"></span></p><pre><code>&lt;Row {'errors': {}, 'id': 1, 'uuid': '08e6433a-cf07-4cea-a4cb-01f16ae5f414'}&gt;</code></pre><p>If there are errors (usually syntax error or input validation errors), you get the result of the validation, and id and uuid will be None</p><pre><code>&lt;Row {'errors': {'period': 'enter an integer greater than or equal to 0'}, 'id': None, 'uuid': None}&gt;</code></pre><h5>Results and output</h5><p>The table "scheduler_run" stores the status of all running tasks. Each record references a task that has been picked up by a worker.  One task can have multiple runs. For example, a task scheduled to repeat 10 times an hour will probably have 10 runs (unless one fails or they take longer than 1 hour). Beware that if the task has no return values, it is removed from the scheduler_run table as soon as it is finished.</p><p>Possible run statuses are:</p><pre><code>RUNNING, COMPLETED, FAILED, TIMEOUT</code></pre><p>If the run is completed, no exceptions are thrown, and there is no task timeout, the run is marked as <code>COMPLETED</code> and the task is marked as <code>QUEUED</code> or <code>COMPLETED</code> depending on whether it is supposed to run again at a later time. The output of the task is serialized in JSON and stored in the run record.</p><p>When a <code>RUNNING</code> task throws an exception, the run is mark as <code>FAILED</code> and the task is marked as <code>FAILED</code>. The traceback is stored in the run record.</p><p>Similarly, when a run exceeds the timeout, it is stopped and marked as <code>TIMEOUT</code>, and the task is marked as <code>TIMEOUT</code>.</p><p>In any case, the stdout is captured and also logged into the run record.</p><p>Using appadmin, one can check all <code>RUNNING</code> tasks, the output of <code>COMPLETED</code> tasks, the error of <code>FAILED</code> tasks, etc.</p><p>The scheduler also creates one more table called "scheduler_worker", which stores the workers' heartbeat and their status.</p><h5>Managing processes</h5><p>Worker fine management is hard. This module tries not to leave behind any platform (Mac, Win, Linux) .</p><p>When you start a worker, you may later want to:</p><ul><li>kill it "no matter what it's doing"</li><li>kill it only if it is not processing tasks</li><li>put it to sleep</li></ul><p>Maybe you have yet some tasks queued, and you want to save some resources. You know you want them processed every hour, so, you'll want to:</p><ul><li>process all queued tasks and die automatically</li></ul><p>All of these things are possible managing <code>Scheduler</code> parameters or the <code>scheduler_worker</code> table. To be more precise, for started workers you can change the <code>status</code> value of any worker to influence its behavior. As for tasks, workers can be in one of the following statuses: ACTIVE, DISABLED, TERMINATE or KILLED.</p><p><strong>ACTIVE</strong> and <strong>DISABLED</strong> are "persistent", while <strong>TERMINATE</strong> or <strong>KILL</strong>, as statuses name suggest, are more "commands" than real statuses. Hitting ctrl+c is equal to set a worker to <strong>KILL</strong></p><p><p style="text-align:center"><img src="http://127.0.0.1:8000/web2py_book/default/image/29/bd891eed.png" alt="workers statuses" /></p></p><p>There are a few commodity functions since version 2.4.1 (self-explanatory)</p><pre><code class="code">scheduler.disable()
scheduler.resume()
scheduler.terminate()
scheduler.kill()</code></pre><p>each function take an optional parameter, that can be a string or a list, to manage workers based on their <code>group_names</code>. It defaults to the <code>group_names</code> defined in the scheduler istantiation.</p><p>An example is better than a thousand words: <code>scheduler.terminate('high_prio')</code> will TERMINATE all the workers that are processing the <code>high_prio</code> tasks, while <code>scheduler.terminate(['high_prio', 'low_prio'])</code> will terminate all <code>high_prio</code> and <code>low_prio</code> workers.</p><blockquote>Watch out: if you have a worker processing <code>high_prio</code> and <code>low_prio</code>, <code>scheduler.terminate('high_prio')</code> will terminate the worker alltogether, even if you didn't want to terminate <code>low_prio</code> too.</blockquote><p>Everything that one can do via appadmin one can do programmatically by inserting and updating records in these tables.</p><p>Anyway, one should not update records relative to <code>RUNNING</code> tasks as this may create an un-expected behavior. The best practice is to queue tasks using the "queue_task" method.</p><p>For example:</p><pre><code class="code">scheduler.queue_task(
    function_name='task_add',
    pargs=[],
    pvars={'a':3,'b':4},
    repeats = 10, # run 10 times
    period = 3600, # every 1h
    timeout = 120, # should take less than 120 seconds
    )</code></pre><p>Notice that fields "times_run", "last_run_time" and "assigned_worker_name" are not provided at schedule time but are filled automatically by the workers.</p><p>You can also retrieve the output of completed tasks:</p><pre><code class="code">completed_runs = db(db.scheduler_run.run_status='COMPLETED').select()</code></pre><blockquote>The scheduler is considered experimental because it needs more extensive testing and because the table structure may change as more features are added.</blockquote><h5>Reporting percentages</h5><p>A special "word" encountered in the print statements of your functions clear all the previous output. That word is <code>!clear!</code>. This, coupled with the <code>sync_output</code> parameter, allows to report percentages.</p><p>Here is an example:</p><pre><code>def reporting_percentages():
    time.sleep(5)
    print '50%'
    time.sleep(5)
    print '!clear!100%'
    return 1</code></pre><p>The function <code>reporting_percentages</code> sleeps for 5 seconds, outputs <code>50%</code>. Then, it sleeps other 5 seconds and outputs <code>100%</code>. Note that the output in the scheduler_run table is synced every 2 seconds and that the second print statement that contains <code>!clear!100%</code> gets the <code>50%</code> output cleared and replaced by <code>100%</code> only.</p><pre><code class="code">scheduler.queue_task(reporting_percentages,
                     sync_output=2)</code></pre><h3>Third party modules</h3><div class="inxx">import</div><p>web2py is written in Python, so it can import and use any Python module, including third party modules. It just needs to be able to find them. As with any Python application, modules can be installed in the official Python "site-packages" directory, and they can then be imported from anywhere inside your code.</p><p>Modules in the "site-packages" directory are, as the name suggests, site-level packages. Applications requiring site-packages are not portable unless these modules are installed separately. The advantage of having modules in "site-packages" is that multiple applications can share them. Let's consider, for example, the plotting package called "matplotlib". You can install it from the shell using the PEAK <code>easy_install</code> command <sup>[<a href="/web2py_book/default/reference/29/easy-install" target="_blank">easy-install</a>]</sup> (or its modern replacement <code>pip</code> <sup>[<a href="/web2py_book/default/reference/29/PIP" target="_blank">PIP</a>]</sup> ):</p><pre><code class="code">easy_install py-matplotlib</code></pre><p>and then you can import it into any model/controller/view with:</p><pre><code class="code">import matplotlib</code></pre><p>The web2py source distribution, and the Windows binary distribution has a site-packages in the top-level folder. The Mac binary distribution has a site-packages folder in the folder:</p><code class="code">web2py.app/Contents/Resources/site-packages</code><p>The problem with using site-packages is that it becomes difficult to use different versions of a single module at the same time, for example there could be two applications but each one uses a different version of the same file.  In this example, <code>sys.path</code> cannot be altered because it would affect both applications.</p><p>For this kind of situation, web2py provides another way to import modules in such a way that the global <code>sys.path</code> is not altered: by placing them in the "modules" folder of an application. One side benefit is that the module will be automatically copied and distributed with the application.</p><blockquote>Once a module "mymodule.py" is placed into an app "modules/" folder, it can be imported from anywhere inside a web2py application (without need to alter <code>sys.path</code> with):
<pre><code>import mymodule</code></pre></blockquote><h3>Execution environment</h3><div class="inxx">exec_environment</div><blockquote>While everything discussed here works fine, we recommend instead building your application using components, as described in chapter 12.</blockquote><p>web2py model and controller files are not Python modules in that they cannot be imported using the Python <code>import</code> statement. The reason for this is that models and controllers are designed to be executed in a prepared environment that has been pre-populated with web2py global objects (request, response, session, cache and T) and helper functions. This is necessary because Python is a statically (lexically) scoped language, whereas the web2py environment is created dynamically.</p><p>web2py provides the <code>exec_environment</code> function to allow you to access models and controllers directly. <code>exec_environment</code> creates a web2py execution environment, loads the file into it and then returns a Storage object containing the environment. The Storage object also serves as a namespace mechanism. Any Python file designed to be executed in the execution environment can be loaded using <code>exec_environment</code>. Uses for <code>exec_environment</code> include:</p><ul><li>Accessing data (models) from other applications.</li><li>Accessing global objects from other models or controllers.</li><li>Executing controller functions from other controllers.</li><li>Loading site-wide helper libraries.</li></ul><p>This example reads rows from the <code>user</code> table in the <code>cas</code> application:</p><pre><code class="code">from gluon.shell import exec_environment
cas = exec_environment('applications/cas/models/db.py')
rows = cas.db().select(cas.db.user.ALL)</code></pre><p>Another example: suppose you have a controller "other.py" that contains:</p><pre><code class="code">def some_action():
    return dict(remote_addr=request.env.remote_addr)</code></pre><p>Here is how you can call this action from another controller (or from the web2py shell):</p><pre><code class="code">from gluon.shell import exec_environment
other = exec_environment('applications/app/controllers/other.py', request=request)
result = other.some_action()</code></pre><p>In line 2, <code>request=request</code> is optional. It has the effect of passing the current request to the environment of "other". Without this argument, the environment would contain a new and empty (apart from <code>request.folder</code>) request object. It is also possible to pass a response and a session object to <code>exec_environment</code>. Be careful when passing request, response and session objects --- modification by the called action or coding dependencies in the called action could lead to unexpected side effects.</p><p>The function call in line 3 does not execute the view; it simply returns the dictionary unless <code>response.render</code> is called explicitly by "some_action".</p><p>One final caution: don't use <code>exec_environment</code> inappropriately. If you want the results of actions in another application, you probably should implement an XML-RPC API (implementing an XML-RPC API with web2py is almost trivial). Don't use <code>exec_environment</code> as a redirection mechanism; use the <code>redirect</code> helper.</p><h3>Cooperation</h3><div class="inxx">cooperation</div><p>There are many ways applications can cooperate:</p><ul><li>Applications can connect to the same database and thus share tables. It is not necessary that all tables in the database are defined by all applications, but they must be defined by those applications that use them. All applications that use the same table, but one, must define the table with <code>migrate=False</code>.</li><li>Applications can embed components from other applications using the LOAD helper (described in Chapter 12).</li><li>Applications can share sessions.</li><li>Applications can call each other's actions remotely via XML-RPC.</li><li>Applications can access each other's files via the filesystem (assuming they share the same filesystem).</li><li>Applications can call each other's actions locally using <code>exec_environment</code> as discussed above.</li><li>Applications can import each other's modules using the syntax:</li></ul><pre><code class="code">from applications.otherapp.modules import mymodule</code></pre><p>or</p><pre><code class="code">import applications.otherapp.modules.othermodule</code></pre><ul><li>Applications can import any module in the <code>PYTHONPATH</code> search path, <code>sys.path</code>.</li></ul><p>One app can load the session of another app using the command:</p><pre><code class="code">session.connect(request, response, masterapp='appname', db=db)</code></pre><p>Here "appname" is the name of the master application, the one that sets the initial session_id in the cookie. <code>db</code> is a database connection to the database that contains the session table (<code>web2py_session</code>). All apps that share sessions must use the same database for session storage.</p><h3>Logging</h3><p>Python provides logging APIs. Web2py provides a mechanism to configure it so that apps can use it.</p><p>In your application, you can create a logger, for example in a model:</p><pre><code class="code">import logging
logger = logging.getLogger("web2py.app.myapp")
logger.setLevel(logging.DEBUG)</code></pre><p>and you can use it to log messages of various importance</p><pre><code class="code">logger.debug("Just checking that %s" % details)
logger.info("You ought to know that %s" % details)
logger.warn("Mind that %s" % details)
logger.error("Oops, something bad happened %s" % details)</code></pre><p><code>logging</code> is a standard python module described here:</p><pre><code>http://docs.python.org/library/logging.html</code></pre><p>The string "web2py.app.myapp" defines an app-level logger.</p><p>For this to work properly, you need a configuration file for the logger. One is provided by web2py in the "examples" folder "logging.example.conf". You need to copy the file to web2py's directory and rename the file to "logging.conf" and customize it as necessary.</p><p>This file is self documenting, so you should open it and read it.</p><p>To create a configurable logger for application "myapp", you must add myapp to the [loggers] keys list:</p><pre><code class="code">[loggers]
keys=root,rocket,markdown,web2py,rewrite,app,welcome,myapp</code></pre><p>and you must add a [logger_myapp] section, using [logger_welcome] as a starting point.</p><pre><code class="code">[logger_myapp]
level=WARNING
qualname=web2py.app.myapp
handlers=consoleHandler
propagate=0</code></pre><p>The "handlers" directive specifies the type of logging and here it is logging "myapp" to the console.</p><h3>WSGI</h3><div class="inxx">WSGI</div><p>web2py and WSGI have a love-hate relationship. Our perspective is that WSGI was developed as a protocol to connect web servers to web applications in a portable way, and we use it for that purpose. web2py at its core is a WSGI application: <code>gluon.main.wsgibase</code>. Some developers have pushed WSGI to its limits as a protocol for middleware communications and develop web applications as an onion with many layers (each layer being a WSGI middleware developed independently of the entire framework). web2py does not adopt this structure internally. This is because we feel the core functionality of a frameworks (handling cookies, session, errors, transactions, dispatching) can be better optimized for speed and security if they are handled by a single comprehensive layer.</p><p>Yet web2py allows you to use third party WSGI applications and middleware in three ways (and their combinations):</p><ul><li>You can edit the file "wsgihandler.py" and include any third party WSGI middleware.</li><li>You can connect third party WSGI middleware to any specific action in your apps.</li><li>You can call a third party WSGI app from your actions.</li></ul><p>The only limitation is that you cannot use third party middleware to replace core web2py functions.</p><h4>External middleware</h4><p>Consider the file "wsgibase.py":</p><pre><code class="code">#...
LOGGING = False
#...
if LOGGING:
    application = gluon.main.appfactory(wsgiapp=gluon.main.wsgibase,
                                        logfilename='httpserver.log',
                                        profilerfilename=None)
else:
    application = gluon.main.wsgibase</code></pre><p>When <code>LOGGING</code> is set to <code>True</code>, <code>gluon.main.wsgibase</code> is wrapped by the middleware function <code>gluon.main.appfactory</code>. It provides logging to the "httpserver.log" file. In a similar fashion you can add any third party middleware. We refer to the official WSGI documentation for more details.</p><h4>Internal middleware</h4><p>Given any action in your controllers (for example <code>index</code>) and any third party middleware application (for example <code>MyMiddleware</code>, which converts output to upper case), you can use a web2py decorator to apply the middleware to that action. Here is an example:</p><pre><code class="code">class MyMiddleware:
    """converts output to upper case"""
    def __init__(self,app):
        self.app = app
    def __call__(self, environ, start_response):
        items = self.app(environ, start_response)
        return [item.upper() for item in items]

@request.wsgi.middleware(MyMiddleware)
def index():
    return 'hello world'</code></pre><p>We cannot promise that all third party middleware will work with this mechanism.</p><h4>Calling <em>WSGI</em> applications</h4><p>It is easy to call WSGI app from a web2py action. Here is an example:</p><pre><code class="code">def test_wsgi_app(environ, start_response):
    """this is a test WSGI app"""
    status = '200 OK'
    response_headers = [('Content-type','text/plain'),
                        ('Content-Length','13')]
    start_response(status, response_headers)
    return ['hello world!\n']

def index():
    """a test action that calls the previous app and escapes output"""
    items = test_wsgi_app(request.wsgi.environ,
                          request.wsgi.start_response)
    for item in items:
        response.write(item,escape=False)
    return response.body.getvalue()</code></pre><p>In this case, the <code>index</code> action calls <code>test_wsgi_app</code> and escapes the returned value before returning it. Notice that <code>index</code> is not itself a WSGI app and it must use the normal web2py API (such as <code>response.write</code> to write to the socket).</p>