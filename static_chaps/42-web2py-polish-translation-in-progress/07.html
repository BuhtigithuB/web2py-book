<h2>Formularze i walidatory</h2><p>W web2py istnieją cztery różne sposoby budowania formularzy:</p><ul><li><code>FORM</code> zapewnia implementację niskiego poziomu w zakresie helperów HTML. Obiekt <code>FORM</code> może być serializowany do kodu HTML i jest mu znana zawartość pól. Wie, jak sprawdzać zgłoszone formularze.</li><li><code>SQLFORM</code> dostarcza API wysokiego poziomu do budowania funkcjonalności tworzenia, aktualizowania i usuwania formularzy powiązanych z istniejącymi tabelami bazy danych.</li><li><code>SQLFORM.factory</code> jest abstrakcyjną warstwą na szczycie <code>SQLFORM</code> w celu wykorzystania funkcjonalności generowania formularzy, nawet jeśli nie jest dostępna baza danych. Generuje to formularze bardzo podobnie do <code>SQLFORM</code>, z opisem tabeli, ale bez potrzeby tworzenia tabeli bazy danych.</li><li>Metody obiektu <code>CRUD</code>. Są one funkcjonalnym równoważnikiem SQLFORM i są oparte na SQLFORM, ale dostarczają bardziej zwartą notację.</li></ul><p>Wszystkie te formularze są samoinformujące się i jeśli dane wejściowe nie przechodzą walidacji, mogą zostać dodane komunikaty błędów. Formularze można wypytywać o zmienne walidacyjne i o komunikaty błędów generowanych podczas walidacji.</p><p>Dowolny kod HTML może być wstawiany do lub ekstrahowany z formularza przy użyciu helperów.</p><p><code>FORM</code> i <code>SQLFORM</code> są helperami, którymi można manipulować w podobny sposób jak z <code>DIV</code>. Na przykład można ustawić styl formularza:</p><pre><code class="code">form = SQLFORM(..)
form['_style']='border:1px solid black'</code></pre><h3><code>FORM</code></h3><p><div class="inxx">formularz</div> <div class="inxx">akceptacje</div> <div class="inxx">nazwa formularza</div></p><p>Rozważmy dla przykładu aplikację <strong>test</strong> z nastęþującym kontrolerem "default.py":</p><pre><code class="code">def display_form():
    return dict()</code></pre><p>i związananym widokiem "default/display_form.html":</p><pre><code class="code">{{extend 'layout.html'}}
&lt;h2&gt;Input form&lt;/h2&gt;
&lt;form enctype="multipart/form-data"
      action="{{=URL()}}" method="post"&gt;
Your name:
&lt;input name="name" /&gt;
&lt;input type="submit" /&gt;
&lt;/form&gt;
&lt;h2&gt;Submitted variables&lt;/h2&gt;
{{=BEAUTIFY(request.vars)}}</code></pre><p>Jest to zwykły formularz HTML, który pyta o nazwę użytkownika. Gdy wypełni się ten formularz i kliknie przycisk zatwierdzający, nastąpi samozgłoszenie formularza i zmienna <code>request.vars.name</code> wraz z wartoscią zostanie wyświetlona na przycisku.</p><p>Można wygenerować taki sam formularz używając helperów. Można to zrobić w widoku lub w akcji. Ponieważ web2py przetwarza formularz w akcji, lepiej jest też zdefiniować formularza w akcji.</p><p>Oto nowy kontroler:</p><pre><code class="code">def display_form():
   form=FORM('Your name:', INPUT(_name='name'), INPUT(_type='submit'))
   return dict(form=form)</code></pre><p>i związany z nim widok "default/display_form.html":</p><pre><code class="code">{{extend 'layout.html'}}
&lt;h2&gt;Input form&lt;/h2&gt;
{{=form}}
&lt;h2&gt;Submitted variables&lt;/h2&gt;
{{=BEAUTIFY(request.vars)}}</code></pre><p>Kod ten, jak do tej pory, jest równoważny poprzedniemu kodowi, ale formularz jest generowany przez wyrażenie <code>{{=form}}</code>, które serializuje obiekt <code>FORM</code>.</p><p>Teraz dodamy jeden poziom złożoności, dodając walidację formularza i przetwarzanie.</p><p>Zmieńmy kontroler następujaco:</p><pre><code class="code">def display_form():
    form=FORM('Your name:',
              INPUT(_name='name', requires=IS_NOT_EMPTY()),
              INPUT(_type='submit'))
    if form.accepts(request,session):
        response.flash = 'form accepted'
    elif form.errors:
        response.flash = 'form has errors'
    else:
        response.flash = 'please fill the form'
    return dict(form=form)</code></pre><p>oraz związany widok "default/display_form.html":</p><pre><code class="code">{{extend 'layout.html'}}
&lt;h2&gt;Input form&lt;/h2&gt;
{{=form}}
&lt;h2&gt;Submitted variables&lt;/h2&gt;
{{=BEAUTIFY(request.vars)}}
&lt;h2&gt;Accepted variables&lt;/h2&gt;
{{=BEAUTIFY(form.vars)}}
&lt;h2&gt;Errors in form&lt;/h2&gt;
{{=BEAUTIFY(form.errors)}}</code></pre><p>Proszę zauważyć, że:</p><ul><li>W akcji dodaliśmy walidator <code>requires=IS_NOT_EMPTY()</code> dla pola input "name".</li><li>W akcji dodaliśmy wywołanie <code>form.accepts(..)</code></li><li>W widoku drukujemy <code>form.vars</code> i <code>form.errors</code> jak również formularz i <code>request.vars</code>.</li></ul><p>Cała praca wykonywana jest przez metodę <code>accepts</code> obiektu <code>form</code>. Filtruje ona <code>request.vars</code> zgodnie z deklarowanymi wymaganiami (wyrażonymi przez walidatory). Metoda <code>accepts</code> przechowuje zmienne, które przechodzą walidację, w <code>form.vars</code>. Jeśli wartość pola nie spełnia wymagań, wykorzystywany walidator zwraca błąd, który zostaje przechowany w <code>form.errors</code>. Zarówno <code>form.vars</code> jak i <code>form.errors</code> są obiektami <code>gluon.storage.Storage</code> podobnymi do <code>request.vars</code>. Pierwszy z nich zawiera wartości, które przeszły walidację, na przykład:</p><pre><code class="code">form.vars.name = "Max"</code></pre><p>Ten drugi obiekt zawiera błędy, na przykład:</p><pre><code class="code">form.errors.name = "Cannot be empty!"</code></pre><p>Pełna sygnatura metody <code>accepts</code> jest następująca:</p><div class="inxx">onvalidation</div><pre><code class="code">form.accepts(vars, session=None, formname='default',
             keepvalues=False, onvalidation=None,
             dbio=True, hideerror=False):</code></pre><p>Znaczenie parametrów opcjonalnych jest wyjaśnione w następnych podrozdziałach.</p><p>Pierwszym argumentem może być <code>request.vars</code> lub <code>request.get_vars</code> lub <code>request.post_vars</code> lub po prostu <code>request</code>. Ten ostatni parametr jest równoznaczny z zaakceptowaniem jako wejścia zmiennej <code>request.post_vars</code>.</p><p>Funkcja <code>accepts</code> zwraca <code>True</code> jeśli formularz został zaakceptowany a w przeciwnym razie <code>False</code>. Formularz nie zostanie zaakceptowany, jeśli ma błędy lub gdy nie został zgłoszony (na przykład, za pierwszym razem jest pokazywany).</p><p>Oto jak wygląda ta strona, gdy formularz jest wyświetlany za pierwszym razem:</p><p><p style="text-align:center"><img src="http://localhost:8000/book/default/image/42/pl5800.png" alt="image" style="width:300px" /></p></p><p>To jest jego wygląd, po nieprawidłowym zgłoszeniu:</p><p><p style="text-align:center"><img src="http://localhost:8000/book/default/image/42/pl5900.png" alt="image" style="width:300px" /></p></p><p>Po prawidłowym zgłoszeniu nasz formularz będzie wyglądać tak:</p><p><p style="text-align:center"><img src="http://localhost:8000/book/default/image/42/pl6000.png" alt="image" style="width:300px" /></p></p><h4>Metody <code>process</code> i <code>validate</code></h4><p>Skrótem dla</p><pre><code class="code">form.accepts(request.post_vars,session,...)</code></pre><p>jest</p><pre><code class="code">form.process(...).accepted</code></pre><p>Skrót nie potrzebuje argumentów <code>request</code> i <code>session</code> (choć ewentualnie można je określić). Różni się on również tym od <code>accepts</code>, ponieważ sam zwraca formularz. Wewnętrznie <code>process</code> akceptuje i przekazuje do niego swoje argumenty. Wartości zwracane przez <code>accepts</code> są zapisywane w zmiennej <code>form.accepted</code>.</p><p>Funkcja process pobiera kilka dodatkowych argumentów, który nie pobiera <code>accepts</code>:</p><ul><li><code>message_onsuccess</code>;</li><li><code>onsuccess</code>: jeśli równe 'flash' (domyślnie) i formularz został zaakceptowany, to pojawi się o tym komunikat <code>message_onsuccess</code> ;</li><li><code>message_onfailure</code> ;</li><li><code>onfailure</code>: jeśli równe 'flash' (domyślnie) i walidacja formularza nie powiodła się, to pojawi się o tym komunikat <code>message_onfailure</code> ;</li><li><code>next</code> wskazuje gdzie przekierować użytkownika po zaakceptowaniu formularza.</li></ul><p>Argumenty <code>onsuccess</code> i <code>onfailure</code> mogą być funkcjami takimi jak <code>lambda form: do_something(form)</code>.</p><p>Skrót</p><pre><code class="code">form.validate(...)</code></pre><p>równoważny jest wyrażeniu</p><pre><code class="code">form.process(...,dbio=False).accepted</code></pre><h4>Pola warunkowe</h4><p>Czasem zachodzi potrzeba pokazania pola, jeśli spełniony jest jakiś warunek. Rozważmy następujący model:</p><pre><code>db.define_table('purchase', Field('have_coupon','boolean'),Field('coupon_code'))</code></pre><p>Przyjmijmy, że chcemy wyświetlić pole <code>coupon_code</code>, wtedy i tylko wtedy, gdy sprawdzane jest pole <code>have_coupon</code>. Można to wykonać w JavaScript. W web2py, odpowiedni kod JavaScript może zostać wygenerowany automatycznie. Wystarczy zadeklarować, że to pole jest zależne od wyrażenia. Wykorzystując atrybut <code>show_if</code> pola:</p><pre><code>def index():
    db.purchase.coupon_code.show_if = (db.purchase.have_coupon==True)
    form = SQLFORM(db.purchase).process()
    return dict(form = form)</code></pre><p>Wartość <code>show_if</code> jest zapytaniem i wykorzystuje tą samą składnię DAL, którą używa się w zapytaniach do bazy danych. Różnica polega na tym, że to zapytanie nie jest wysyłane do bazy danych, ale jest konwertowane do kodu JavaScript i wysyłane do przeglądarki, gdzie kod ten jest wykonywany, gdy użytkownik edytuje formularz.</p><h4>Pola ukryte</h4><p>Po zserializowaniu powyższego obiektu formularza przez <code>{{=form}}</code>i ponieważ wywołana została metodę <code>accepts</code>, kod HTML formularza będzie wyglądać tak:</p><pre><code class="code">&lt;form enctype="multipart/form-data" action="" method="post"&gt;
your name:
&lt;input name="name" /&gt;
&lt;input type="submit" /&gt;
&lt;input value="783531473471" type="hidden" name="_formkey" /&gt;
&lt;input value="default" type="hidden" name="_formname" /&gt;
&lt;/form&gt;</code></pre><p>Proszę zwrócić uwagę na obecność dwóch ukrytych pól: "_formkey" i "_formname". Ich obecność jest wyzwalana przez wywołanie <code>accepts</code>. Odgrywają one dwie ważne role:</p><ul><li>Ukryte pole o nazwie "_formkey" jest jednorazowym tokenem, który jest używany do zabezpieczenia przed podwójnym złożeniem formularza. Wartość tego klucza jest generowana podczas serializowania formularza i przechowywana w <code>session</code>. Gdy formularz zostaje złożony, wartość ta musi pasować, w przeciwnym przypadku metoda <code>accepts</code> zwraca <code>False</code> bez błędów, tak jakby formularz w ogóle nie został złożony. Dzieje się tak dlatego, że web2py nie może ustalić, czy formularz został złożony poprawnie.</li><li>Ukryte pole o nazwie "_formname" jest generowane przez web2py jako jako nazwa dla formularza, ale nazwa ta może zostać nadpisana. Pole to jest niezbędne, aby umożliwić strony, które zawierają i przetwarzają wiele formularzy. web2py rozróżnia różne złożone formularze po ich nazwach.</li><li>Opcjonalnie, ukryte pola określić można przez <code>FORM(..,hidden=dict(...))</code>.</li></ul><p>Rola tych ukrytych pól i ich wykorzystanie w niestandardowych formularzach i stronach z wieloma formularzami jest omówione szczegółowo w dalszej części rozdziału.</p><p>Jeśli rozpatrywany formularz został złożony z pustym polem "name", nie przejdzie walidacji. Gdy formularz jest ponownie serializowany, to pojawi się jako:</p><pre><code class="code">&lt;form enctype="multipart/form-data" action="" method="post"&gt;
your name:
&lt;input value="" name="name" /&gt;
&lt;div class="error"&gt;cannot be empty!&lt;/div&gt;
&lt;input type="submit" /&gt;
&lt;input value="783531473471" type="hidden" name="_formkey" /&gt;
&lt;input value="default" type="hidden" name="_formname" /&gt;
&lt;/form&gt;</code></pre><p>Proszę zwrócić uwagę na występowanie DIV klasy "error" w serializowanym formularzu. web2py wstawia ten komunikat błędu w formularzu, aby powiadomić odwiedzającego o polu, które nie przeszło walidacji. Po złożeniu formularza, metoda <code>accepts</code> określa, ze formularz został złożony, sprawdza czy pole "name" jest puste i czy wartość tego pola jest obowiązkowa i ewentualnie umieszcza w formularzu komunikat błędu z walidatora.</p><p>Bazowy widok "layout.html" przewiduje obsługę bloków DIV z klasa "error". Domyślny szablon układu wykorzystuje efekty jQuery do pokazywania komunikatów błędów z efektem zsuwania na czerwonym tle. Proszę zapoznać się ze szczegółami w rozdziale 11.</p><h4><code>keepvalues</code></h4><div class="inxx">keepvalues</div><p>Opcjonalny argument <code>keepvalues</code> powiadamia web2py, co zrobić gdy formularz został zaakceptowany i nie ma przekierowania, tak więc ten sam formularz będzie wyświetlony ponownie. Domyślnie w takim przypadku formularz jest czyszczony. Jeśli <code>keepvalues</code> jest ustawione na <code>True</code>, formularz jest wstępnie wypełniany poprzednio wprowadzonymi danymi. Jest to pomocne, gdy ten sam formularz ma być używany wielokrotnie do wstawiania podobnych rekordów. Jeśli argument <code>dbio</code> jest ustawiony na <code>False</code>, web2py nie będzie wykonywał jakichkolwiek operacji wstawiania lub aktualizowania rekordów w bazie danych po zaakceptowaniu formularza. Jeśli <code>hideerror</code> zostanie ustawiony na <code>True</code> a formularz zawiera błędy, nie będą one wyświetlane podczas renderowania formularza (będzie rolą programisty wyświetlenie jakoś tych błędów ze zmiennej <code>form.errors</code>). Argument <code>onvalidation</code> jest omówiony poniżej.</p><h4><code>onvalidation</code></h4><p>Wartością argumentu <code>onvalidation</code> może być <code>None</code> lub funkcja, która pobiera formularz i zwraca nothing. Taka funkcja może być wywołana i przekazana do formularza, niezwłocznie po pozytywnej walidacji i przed czymkolwiek co się stanie po tej walidacji. Funkcja ta ma wiele zastosowań. Na przykład, wykonanie dodatkowego sprawdzenia formularza i ewentualnie dodanie do formularza błędów lub obliczenie wartości jakichś pol na podstawie wartości innych pól lub wyzwolenie jakiejś akcji (jak na przykład wysłanie wiadomości email) przed utworzeniem lub zaktualizowaniem rekordu.</p><p>Oto przykład:</p><pre><code class="code">db.define_table('numbers',
    Field('a', 'integer'),
    Field('b', 'integer'),
    Field('c', 'integer', readable=False, writable=False))

def my_form_processing(form):
    c = form.vars.a * form.vars.b
    if c &lt; 0:
       form.errors.b = 'a*b cannot be negative'
    else:
       form.vars.c = c

def insert_numbers():
   form = SQLFORM(db.numbers)
   if form.process(onvalidation=my_form_processing).accepted:
       session.flash = 'record inserted'
       redirect(URL())
   return dict(form=form)</code></pre><h4>Wykrywanie zmian rekordu</h4><p>Podczas wypełniania formularza podczas edycji istnieje pewne prawdopodobieństwo, że inny użytkownik może jednocześnie edytować ten sam rekord. Więc w czasie zapisywania rekordu dobrze jest sprawdzić, czy nie uległ on w międzyczasie zmianie, w celu uniknięcia konfliktów. Można to zrobić tak:</p><pre><code class="code">db.define_table('dog',Field('name'))

def edit_dog():
    dog = db.dog(request.args(0)) or redirect(URL('error'))
    form=SQLFORM(db.dog,dog)
    form.process(detect_record_change=True)
    if form.record_changed:
        # do something
    elif form.accepted:
        # do something else
    else:
        # do nothing
    return dict(form=form)</code></pre><h4>Formularze a przekierowanie</h4><p>Najczęstszym sposobem wykorzystania formularzy jest tzw. samozgłoszenie, co oznacza, że zgłoszone zmienne pól są przetwarzane w tej samej akcji, w której wygenerowano formularz. Po zaakceptowaniu formularza, niezwykła rzeczą jest jego ponowne wyświetlenie na bieżącej stronie. Bardziej rozpowszechnione jest przekierowanie odwiedzającego do "następnej" strony.</p><p>Oto nowy przykład kontrolera:</p><pre><code class="code">def display_form():
    form = FORM('Your name:',
              INPUT(_name='name', requires=IS_NOT_EMPTY()),
              INPUT(_type='submit'))
    if form.process().accepted:
        session.flash = 'form accepted'
        redirect(URL('next'))
    elif form.errors:
        response.flash = 'form has errors'
    else:
        response.flash = 'please fill the form'
    return dict(form=form)

def next():
    return dict()</code></pre><p>W celu ustawienia komunikatu fleszowego na następnej stronie a nie na bieżącej, trzeba zastosować <code>session.flash</code> zamiast <code>response.flash</code>. web2py przeniesie to pierwsze wyrażenie na następną stronę po przekierowaniu. Trzeba mieć na uwadze, że używanie <code>session.flash</code> wymaga nie stosowania <code>session.forget()</code>.</p><h4>Wiele formularzy na jednej stronie</h4><p>Treść tego rozdziału dotyczy zarówno klasy <code>FORM</code> jak i <code>SQLFORM</code>. Jest możliwe posiadanie wielu formularzy na stronie, ale trzeba umożliwić ich rozróżnianie przez web2py. Jeśli formularze są uzyskiwane z <code>SQLFORM</code> z różnych tabel, to web2py automatycznie przydziela im różne nazwy. W przeciwnym razie zachodzi potrzeba jawnego określenia nazw dla poszczególnych formularzy. Oto przykład:</p><pre><code class="code">def two_forms():
    form1 = FORM(INPUT(_name='name', requires=IS_NOT_EMPTY()),
               INPUT(_type='submit'))
    form2 = FORM(INPUT(_name='name', requires=IS_NOT_EMPTY()),
               INPUT(_type='submit'))
    if form1.process(formname='form_one').accepted:
        response.flash = 'form one accepted'
    if form2.process(formname='form_two').accepted:
        response.flash = 'form two accepted'
    return dict(form1=form1, form2=form2)</code></pre><p>a to jest wyprodukowane wyjście:</p><p><p style="text-align:center"><img src="http://localhost:8000/book/default/image/42/pl6100.png" alt="image" style="width:300px" /></p></p><p>Gdy użytkownik zgłasza pusty form1, to tylko w form1 wyświetlany jest błąd, jeśli odwiedzający zgłosi pusty form2, to błąd będzie wyświetlony tylko w form2.</p><h4>Udostępnianie formularzy</h4><p>Treść tego rozdziału dotyczy klasy <code>FORM</code> oraz <code>SQLFORM</code>. To co tu omówimy jest możliwe, ale nie zalecane, ponieważ zawsze jest dobrą praktyką, aby tworzyć formularz samozgłaszający się. Czasami jednak nie ma się wyboru, gdy akcja wysyłająca formularz i akcja odbierająca należą do różnych aplikacji.</p><p>Jest możliwe wygenerowanie formularza, który zgłaszany jest do różnych akcji. Realizuje się to przez określenie adresu URL akcji przetwarzającej w atrybucie obiektów <code>FORM</code> lub <code>SQLFORM</code>. Na przykład:</p><pre><code class="code">form = FORM(INPUT(_name='name', requires=IS_NOT_EMPTY()),
        INPUT(_type='submit'), _action=URL('page_two'))

def page_one():
    return dict(form=form)

def page_two():
    if form.process(session=None, formname=None).accepted:
         response.flash = 'form accepted'
    else:
         response.flash = 'there was an error in the form'
    return dict()</code></pre><p>Proszę zauważyć, że ponieważ "page_one" oraz "page_two" używają ten sam obiekt <code>form</code>, zdefiniowaliśmy go tylko raz, umieszczając na zewnątrz wszystkich akcji, aby się nie powtarzać. Wspólna część kodu na początku kontrolera zostaje wykonana za każdym razem przed przekazaniem sterowania do wywoływanej akcji.</p><p>Ponieważ "page_one" nie wywołuje <code>process</code> (ani <code>accepts</code>), formularz nie ma nazwy ani klucza, więc trzeba przekazać <code>session=None</code> i ustawić <code>formname=None</code> w <code>process</code> lub formularz nie będzie walidowany, gdy otrzyma go "page_two".</p><h4>Dodawanie przycisków do obiektów FORM</h4><p>Zazwyczaj formularz zawiera jeden przycisk zgłaszający „Prześlij”. Często chce się dodać przycisk "Wstecz" zamiast przycisku „Prześlij”, przekierowujący odwiedzającego do innej strony.</p><div class="inxx">add_button</div><p>Można to zrobić przy wykorzystując metodę <code>add_button</code>:</p><pre><code class="code">form.add_button('Wstecz', URL('other_page'))</code></pre><p>Do formularza można dodawać więcej niż jeden przycisk. Argumentami metody <code>add_button</code> są wartość przycisku (jego tekst) i adres url przekierowania. Proszę zapoznać się też z argumentem buttons dla SQLFORM, który dostarcza bardziej zaawansowane rozwiązanie.</p><h4>Więcej o manipulowaniu obiektami FORM</h4><p>Tak jak opisano to w rozdziale poświęconemu widokom, klasa FORM jest helperem HTML. Helpery mogą być manipulowane jak listy Pythona i jak słowniki, które można tworzyć i manipulować nimi w czasie wykonania.</p><h3><code>SQLFORM</code></h3><p>Przejdźmy teraz do następnego poziomu i stwórzmy aplikacje z plikiem takiego modelu:</p><pre><code class="code">db = DAL('sqlite://storage.sqlite')
db.define_table('person', Field('name', requires=IS_NOT_EMPTY()))</code></pre><p>Zmodyfikujmy kontroler następująco:</p><pre><code class="code">def display_form():
   form = SQLFORM(db.person)
   if form.process().accepted:
       response.flash = 'form accepted'
   elif form.errors:
       response.flash = 'form has errors'
   else:
       response.flash = 'please fill out the form'
   return dict(form=form)</code></pre><p>Widoku nie potrzebujemy zmieniać.</p><p>W nowym kontrolerze nie potrzebujemy budowania <code>FORM</code>, ponieważ konstruktor <code>SQLFORM</code> zbudował jeden formularz z danymi z tabeli <code>db.person</code>, zdefiniowany w modelu. Jest to nowy formularz, który po zserializowaniu do kodu HTML będzie wyglądał następująco:</p><pre><code class="code">&lt;form enctype="multipart/form-data" action="" method="post"&gt;
  &lt;table&gt;
    &lt;tr id="person_name__row"&gt;
       &lt;td&gt;&lt;label id="person_name__label"
                  for="person_name"&gt;Your name: &lt;/label&gt;&lt;/td&gt;
       &lt;td&gt;&lt;input type="text" class="string"
                  name="name" value="" id="person_name" /&gt;&lt;/td&gt;
       &lt;td&gt;&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr id="submit_record__row"&gt;
       &lt;td&gt;&lt;/td&gt;
       &lt;td&gt;&lt;input value="Submit" type="submit" /&gt;&lt;/td&gt;
       &lt;td&gt;&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/table&gt;
  &lt;input value="9038845529" type="hidden" name="_formkey" /&gt;
  &lt;input value="person" type="hidden" name="_formname" /&gt;
&lt;/form&gt;</code></pre><p>Ten automatycznie wygenerowany formularz jest bardziej złożony niż poprzedni formularz niskiego poziomu. Przede wszystkim zawiera wiersze tabeli i każdy wiersza posiada trzy kolumny. Pierwsza kolumna zawiera etykiety pól (tak jak określono to w <code>db.person</code>), druga kolumna zawiera pola wejściowe (input) i ewentualnie komunikaty błedów, a trzecia kolumna jest opcjonalna i dlatego pusta (może zostać wypełniona z pól w konstruktorze <code>SQLFORM</code>).</p><p>Wszystkie znaczniki w formularzu mają nazwy pochodzące z tabeli i nazwy pól. Pozwala to na łatwe dostosowanie formularza przy użyciu CSS i JavaScript. Możliwości te są szczegółowiej opisane w rozdziale 11.</p><p>Bardziej istotne jest to, że teraz nowa metoda <code>accepts</code> ma dużo więcej pracy. Podobnie jak w poprzednim przypadku wykonuje walidację danych wejściowych, ale dodatkowo, jeśli dane wejściowe przechodzą walidację, to również wykonuję wstawienie nowych rekordów i zapisanie w <code>form.vars.id</code> unikalnego "id" nowego rekordu.</p><p>Obiekt <code>SQLFORM</code> również automatycznie zajmuje się polami "upload" dokonując zapisu przesyłanych plików w folderze "uploads" (po zmianie nazwy pliku w celach uniknięcia konfliktów i zabezpieczenia przed atakami „directory traversal”) i przechowując ich nazwy (nowe nazwy) w odpowiednim polu w bazie danych. Nowa nazwa pliku zostaje udostępniona, po przetworzeniu formularza, w <code>form.vars.fieldname</code> (czyli zastępuje obiekt <code>cgi.FieldStorage</code> w <code>request.vars.fieldname</code>), więc można łatwo odwoływać się do nowej nazwy.</p><p><code>SQLFORM</code> wyświetla wartości "logiczne" w polach wyboru (checkbox), wartości "tekstowe" w obszarach tekstowych (textarea), natomiast wartości, które muszą się znajdować w określonym zestawie lub bazie danych w listach rozwijanych (drop-downs) a pola "przesyłanych danych" w odnośnikach umożliwiających użytkownikom pobieranie plików. Ukrywa on pola "blob", ponieważ muszą być obsługiwane inaczej, co omówione jest dalej.</p><p>Na przykład, przeanalizujmy następujący model:</p><pre><code class="code">db.define_table('person',
    Field('name', requires=IS_NOT_EMPTY()),
    Field('married', 'boolean'),
    Field('gender', requires=IS_IN_SET(['Male', 'Female', 'Other'])),
    Field('profile', 'text'),
    Field('image', 'upload'))</code></pre><p>W tym przypadku, <code>SQLFORM(db.person)</code> wygeneruje następujący formularz:</p><p><p style="text-align:center"><img src="http://localhost:8000/book/default/image/42/pl6200.png" alt="image" style="width:300px" /></p></p><p>Konstruktor <code>SQLFORM</code> umożliwia różnorakie przystosowywania formularza, takie jak wyświetlanie tylko podzestawu pól, zmianę etykiet, dodawanie wartości do opcjonalnej trzeciej kolumny lub tworzenie formularzy UPDATE i DELETE, a nie standardowych formularzy INSERT. <code>SQLFORM</code> jest obiektem, który na tle innych obiektów web2py, potrafi najbardziej oszczędzić czas programisty.</p><p>Klasa <code>SQLFORM</code> została zdefiniowana w "gluon/sqlhtml.py". Można ją łatwo rozszerzyć nadpisując jej metodę <code>xml</code> serializującą obiekty, tak aby zmienić jej wyjście.</p><p><div class="inxx">pola</div> <div class="inxx">etykiety</div> Sygnatura konstruktora <code>SQLFORM</code> jest następująca:</p><pre><code class="code">SQLFORM(table, record = None,
        deletable = False, linkto = None,
        upload = None, fields = None, labels = None,
        col3 = {}, submit_button = 'Submit',
        delete_label = 'Check to delete:',
        showid = True, readonly = False,
        comments = True, keepopts = [],
        ignore_rw = False, record_id = None,
        formstyle = 'table3cols',
        buttons = ['submit'], separator = ': ',
        **attributes)
</code></pre><ul><li>Opcjonalny drugi argument zamienia formularz INSERT na formularz UPDATE dla określonego rekordu (patrz nastęþny podrozdział). <div class="inxx">showid</div> <div class="inxx">delete_label</div> <div class="inxx">id_label</div> <div class="inxx">submit_button</div></li><li>Jeśli <code>deletable</code> jest ustawiony na <code>True</code>, formularz UPDATE wyświetla pole wyboru "Zaznacz aby skasować". Wartość etykiety tego pola jest ustawiana w argumencie <code>delete_label</code>.</li><li><code>submit_button</code> wartość przycisku zatwierdzania.</li><li><code>id_label</code> ustawia etykietę "id" rekordu.</li><li>"Id" rekordu nie jest pokazywany, jeśli argument <code>showid</code> jest ustawiony na <code>False</code>.</li><li><code>fields</code> jest opcjonalną listą nazw pól, które chce się wyświetlić. Jeśli lista zostaje dostarczona, to wyświetlane będą tylko pola z tej listy. Na przykład:</li></ul><pre><code class="code">fields = ['name']</code></pre><ul><li><code>labels</code> jest słownikiem etykiet pól. Kluczami słownika są nazwy pól a wartościami, to co ma być wyświetlone jako etykieta pola. Jeśli etykieta nie jest określona, web2py wywodzi etykietę z nazwy pola (nazwa pola jest kapitalizowana a znaki podkreślenia są zamieniane na spacje). Na przykład:</li></ul><pre><code class="code">labels = {'name':'Your Full Name:'}</code></pre><ul><li><code>col3</code> jest słownikiem wartości dla trzeciej kolumny. Na przykład:</li></ul><pre><code class="code">col3 = {'name':A('what is this?',
      _href='http://www.google.com/search?q=define:name')}</code></pre><ul><li><code>linkto</code> i <code>upload</code> są opcjonalnymi ścieżkami URL do kontrolerów zdefiniowanych przez użytkownika, które umożliwiają, aby formularz radził sobie z polami referencyjnymi. Jest to omówione w dalszej części rozdziału.</li><li><code>readonly</code>. Jeśli ustawiony na True, formularz jest wyświetlany jako tylko do odczytu.</li><li><code>comments</code>. Jeśli ustawiony na False, nie będą wyświetlane komentarze w col3.</li><li><code>ignore_rw</code>. Zwykle, w formularzu tworzącym i aktualizującym wyświetlane są tylko pola oznaczone jako <code>writable=True</code> a w formularzu tylko do odczytu pola oznaczone jako <code>readable=True</code>. Ustawienie <code>ignore_rw=True</code> spowoduje, że ograniczenia te będą ignorowane i wyświetlone zostaną wszystkie pola. Jest to stosowane głównie w interfejsie appadmin do wyświetlenia wszystkich pól każdego tabeli, przesłaniając to co wskazuje model.</li><li><div class="inxx">formstyle</div> <code>formstyle</code> określa styl jaki będzie użyty podczas serializowania formularza do kodu HTML. Może to być "table3cols" (domyślnie), "table2cols" (jeden wiersz dla etykiety i komentarza i jeden wiersz dla pola wejściowego), "ul" (wytwarza nieuporządkowana listę pól wejsciowych), "divs" (reprezentuje formularz wykorzystujący przyjazne bloki div CSS, dla dowolnego dostosowania), "bootstrap" wykorzystujący klasę bootstrap formularza o wartości "form-horizontal". Argument <code>formstyle</code> może również być funkcją generującą wszystko wewnątrz znacznika FORM. Można przekazać do konstruktora funkcję z dwoma argumentami, form i fields. Wskazówki można znaleźć w pliku kodu źródłowego sqlhtml.py (proszę zobaczyć do funkcji o nazwie formstyle_).</li><li><div class="inxx">buttons</div> <code>buttons</code> jest listą helperów <code>INPUT</code> lub <code>TAG.button</code> (choć teoretycznie może być dowolna kombinacją helperów), które mają być dodane do DIV w którym znajduje się przycisk zatwierdzający. Na przykład, dodanie przycisku powrotnego opartego na URL (dla formularza wielostronicowego) i zmiana nazwy przycisku zatwierdzającego:</li></ul><blockquote><pre><code class="code">buttons = [TAG.button('Back',_type="button",_onClick = "parent.location='%s' " % URL(...),
             TAG.button('Next',_type="submit")]</code></pre>
  lub przycisku, który łączy do innej strony:
<pre><code class="code">buttons = [..., A("Go to another page",_class='btn',_href=URL("default","anotherpage"))]</code></pre></blockquote><ul><li><div class="inxx">separator</div> <code>separator</code> ustawia ciąg znakowy, który oddziela etykiety formularza od pól wejściowych.</li><li>Opcjonalnie <code>attributes</code> są argumentami rozpoczynającymi się od znaku podkreślenia, które przekazuje się do znacznika <code>FORM</code> w celu odpowiedniego renderowania obiektu <code>SQLFORM</code>. Oto przykład:</li></ul><pre><code class="code">_action = '.'
_method = 'POST'</code></pre><p>Istnieje specjalny atrybut <code>hidden</code>. Gdy słownik jest przekazywany jako <code>hidden</code>, jego elementy są tłumaczone na ukryte pole INPUT (zobacz przykład helpera <code>FORM</code> w rozdziale 5):</p><pre><code class="code">form = SQLFORM(...,hidden=...)</code></pre><p>co powoduje, że ukryte pola są przekazywane w zgłoszeniu, nic więcej, nic mniej. Argumenty <code>form.accepts(...)</code> nie są przeznaczone do odczytywania odebranych ukrytych pól i trzeba przenieść je do form.vars. Powodem tego jest bezpieczeństwo. Ukryte pola mogą być naruszane, więc trzeba jawnie przenieść ukryte pola z żądania do formularza:</p><pre><code class="code">form.vars.a = request.vars.a
form = SQLFORM(..., hidden=dict(a='b'))</code></pre><h4>Metoda <code>process</code></h4><p>SQLFORM używa metodę process (podobnie jak forms).</p><p>Jeśli w SQLFORM  chce się wykorzystać argument keepvalues, trzeba przekazać go w metodzie process:</p><code class="code">if form.process(keepvalues=True).accepted:</code><h4><code>SQLFORM</code> a <code>insert</code>/<code>update</code>/<code>delete</code></h4><p>Gdy formularz jest akceptowany, <code>SQLFORM</code> tworzy nowy rekord. Zakładając, że <code>form=SQLFORM(db.test)</code>, to identyfikator ostatnio utworzonegi rekordu będzie dostępny w <code>myform.vars.id</code>.</p><div class="inxx">delete record</div><p>Jeśli przekaże się rekord jako drugi argument konstruktora <code>SQLFORM</code>, formularz stanie się formularzem UPDATE dla tego rekordu. Oznacza to, że podczas składania formularza aktualizowany jest istniejący rekord a nowy rekord jest wstawiany. Jeśli ustawi się <code>deletable=True</code>, formularz UPDATE wyświetla pole wyboru "zaznacz aby usunąć". jeśli zaznaczysz, rekord zostanie usuniety.</p><blockquote>Przy składaniu formularza, jeśli zaznaczone jest pole wyboru usuwania, atrybut
<code>form.deleted</code> zostaje ustawiany na <code>True</code>.</blockquote><p>Zmodyfikujmy kontroler z poprzedniego przykładu, tak aby przekazywał dodatkowy argumentu całkowitoliczbowy w ścieżce URL, na przykład:</p><pre><code class="code">/test/default/display_form/2</code></pre><p>i jeśli istnieje rekord z odpowiednim identyfikatorem, to <code>SQLFORM</code> generuje dla tego rekordu formularz UPDATE/DELETE:</p><pre><code class="code">def display_form():
   record = db.person(request.args(0)) or redirect(URL('index'))
   form = SQLFORM(db.person, record)
   if form.process().accepted:
       response.flash = 'form accepted'
   elif form.errors:
       response.flash = 'form has errors'
   return dict(form=form)</code></pre><p>Linia w odnajduje rekord a linia 3 wykonuje formularz UPDATE/DELETE form. Linia 4 realizuje całe przetwarzanie odpowiedniego formularza.</p><blockquote>Formularz aktualizujący jest bardzo podobny do utworzonego formularza z tym, że
jest on wstępnie wypełniony danymi bieżącego rekordu oraz do podgladu obrazów.
Mamy domyślnie ustawione <code>deletable = True</code> co oznacza, że formularz aktualizujący
będzie  wyświetlał opcję "delete record".</blockquote><p>Formularze edycyjne zawierają również ukryte pole INPUT z <code>name="id"</code>, które jest używane do identyfikacji rekordu. Identyfikator ten jest również przechowywany po stronie serwera dla dodatkowego bezpieczeństwa i jeśli odwiedzajacy będzie coś "majstrował" z wartością tego pola, UPDATE nie zostanie wykonane a web2py zgłosi SyntaxError, "user is tampering with form".</p><p>Gdy pole jest oznaczone z <code>writable=False</code>, nie będzie pokazywane w tworzonym formularzu a w formularzach aktualizujących będzie wyświetlane jako pole tylko do odczytu. Jeśli pole jest oznaczone jako <code>writable=False</code> i <code>readable=False</code>, to nie będzie wyświetlane w ogóle, nawet w formularzach aktualizujących.</p><p>Formularze tworzone przez</p><pre><code class="code">form = SQLFORM(...,ignore_rw=True)</code></pre><p>ignorują atrybuty <code>readable</code> i <code>writable</code> oraz zawsze pokazują wszystkie pola. Formularze w <code>appadmin</code> ignoruja domślnie ta zachowanie.</p><p>Formularze tworzone przez</p><pre><code class="code">form = SQLFORM(table,record_id,readonly=True)</code></pre><p>wyświetlają wszystkie pola w trybie tylko do odczytu i nie moga być akceptowane.</p><p>Oznakowanie pola przez <code>writable=False</code> zapobiega włączeniu tego pola w strukturę formularza i powoduje przetwarzanie formularza z pominięciem wartości <code>request.vars.field</code>. Jednakże, jeśli przypisze się wartość <code>form.vars.field</code>, to ta wartość <em>stanie </em> się częścią polecenia wstawiającego lub aktualizującego podczas przetwarzania formularza. Umożliwia to zmianę wartości pól, które z jakichś powodów nie chcemy umieszczać w formularzu.</p><h4><code>SQLFORM</code> w HTML</h4><p>Czasem chce się użyć <code>SQLFORM</code>, aby wykorzystać jego generator formularzy i prztwarzanie, ale potrzebny jest wielkszy poziom dostosowania kodu HTML formularza, który nie można osiągnąć z parametrami obiektu <code>SQLFORM</code>, wieć trzeba zaprojektować formularz używając HTML.</p><p>Edytujmy teraz poprzedni kontroler i dodajmy nową akcję:</p><pre><code class="code">def display_manual_form():
    form = SQLFORM(db.person)
    if form.process(session=None, formname='test').accepted:
        response.flash = 'form accepted'
    elif form.errors:
        response.flash = 'form has errors'
    else:
        response.flash = 'please fill the form'
    # Note: no form instance is passed to the view
    return dict()</code></pre><p>oraz wstawmy formularz w związany widok "default/display_manual_form.html":</p><pre><code class="code">{{extend 'layout.html'}}
&lt;form action="#" enctype="multipart/form-data" method="post"&gt;
&lt;ul&gt;
  &lt;li&gt;Your name is &lt;input name="name" /&gt;&lt;/li&gt;
&lt;/ul&gt;
  &lt;input type="submit" /&gt;
  &lt;input type="hidden" name="_formname" value="test" /&gt;
&lt;/form&gt;</code></pre><p>Proszę zauważyć, że ta akcja nie zwraca formularza, ponieważ nie trzeba przekazywać go do widoku. Widok zawiera formularz utworzony ręcznie w HTML. Formularz zawiera ukryte pole "_formname", którego wartość musi być taka sama jak <code>formname</code> określonego jako argument <code>accepts</code> w akcji. web2py uzywa tej nazwy formularza w przypadku, gdy istnieje wiele formularzy na tej samej stronie, do określenia, który z nich został zgłoszony. Jeśli strona zawiera tylko pojedynczy formularz, można ustawić <code>formname=None</code> i pominąc w widoku ukryte pole.</p><p>Metoda <code>form.accepts</code> będzie wyszukiwać wewnątrz <code>response.vars</code> danych odpowiadających polom w tabeli <code>db.person</code>.  Pola te są deklarowane w formacie HTML</p><code class="code">&lt;input name="field_name_goes_here" /&gt;</code><p>Proszę zauważyć, że w podanym przykładzie, zmienne formularza bedą przekazywane jako argumenty w adresie URL. Jeśli nie jest to pożądane, musi się określić protokół <code>POST</code>. Proszę ponadto mieć na uwadze, że jeśli określi się pola <em>upload</em>, formularz będzie musiał być ustawiony na zezwolenie tych pól. Tutaj są pokazane obie opcje:</p><pre><code class="code">&lt;form enctype="multipart/form-data" method="post"&gt;</code></pre><h4><code>SQLFORM</code> a pola <em>upload</em></h4><p>Pola typu <em>upload</em> są specjalne. Są renderowane jako pola INPUT <code>type="file"</code>. Jeśli nie określi sie tego inaczej, przesyłany na serwer plik jest strumieniowany do używanej pamięci podręcznej i przechowywany w folderze "uploads" aplikacji z użyciem nowej bezpiecznej nazwy, przypisywanej automatycznie. Nazwa tego pliku jest następnie zapisywana do pól typu <em>upload</em>.</p><p>Dla przykładu rozważmy następujący model:</p><pre><code class="code">db.define_table('person',
    Field('name', requires=IS_NOT_EMPTY()),
    Field('image', 'upload'))</code></pre><p>Użyjemy tej samej akcji kontrolera, "display_form", pokazanej powyżej.</p><p>Po wstawieniu nowego rekrdu, formularz pozwoli na przegladanie pliku. Wybierz, na przykład, obraz jpg. Plik ten zostanie pobrany i zapisany jako:</p><pre><code class="code">applications/test/uploads/person.image.XXXXX.jpg</code></pre><p>"XXXXXX" jest losowym identyfikatorem przypisywanym plikowi przez web2py.</p><div class="inxx">content-disposition</div><blockquote>Proszę zauważyć, że domyślnie, oryginalna nazwa przesłanego pliku, to <code>b16encoded</code>
i jest ona użyta do budowania nowej nazwy pliku. Nazwa ta jest pobierana przez
domyślną akcję "download" i używana jest do ustawienia zawartości nagłówka
<code>disposition</code> na oryginalną nazwę pliku.</blockquote><p>Tylko rozszerzenie pliku jest zachowywane. Jest to wymóg bezpieczeństwa, ponieważ nazwa pliku może zawierać znaki specjalne, które mogą posłużyć odwiedzającym do przeprowdzenie ataków z przeglądaniem katalogów lub do wykonania innych szkodliwych operacje.</p><p>Nowa nazwa pliku zostaje zapisana w <code>form.vars.image</code>.</p><p>Podczas edytowania rekordu przy użyciu formulara UPDATE, pożądane jest udostępnienie odnośnika do przesłanego pliku i web2py oferuje na to sposób.</p><p>Jeśli przekaże się adres URL do konstruktora <code>SQLFORM</code> poprzez argument <code>upload</code>, web2py użyje akcji określonej w tym adresie URL do pobrania pliku. Przyjrzyjmi się następujacej akcji:</p><pre><code class="code">def display_form():
   record = db.person(request.args(0))
   form = SQLFORM(db.person, record, deletable=True,
                  upload=URL('download'))
   if form.process().accepted:
       response.flash = 'form accepted'
   elif form.errors:
       response.flash = 'form has errors'
   return dict(form=form)

def download():
    return response.download(request, db)</code></pre><p>Wstaw teraz nowy rekord do adresu URL:</p><pre><code class="code">http://127.0.0.1:8000/test/default/display_form</code></pre><p>Prześlij zdjęcie, zatwierdź formularz i następnie edytuj nowo utworzony rekord, odwiedzając:</p><pre><code class="code">http://127.0.0.1:8000/test/default/display_form/3</code></pre><p>(zakładamy tu, że ostatani rekord ma id=3). Formularz wyświetli podgląd obrazu, tak jak pokazano niżej:</p><p><p style="text-align:center"><img src="http://localhost:8000/book/default/image/42/pl6300.png" alt="image" style="width:300px" /></p></p><p>Formularz ten, po serializacji, wygeneruje następujący kod HTML:</p><pre><code class="code">&lt;td&gt;&lt;label id="person_image__label" for="person_image"&gt;Image: &lt;/label&gt;&lt;/td&gt;
&lt;td&gt;&lt;div&gt;&lt;input type="file" id="person_image" class="upload" name="image"
/&gt;[&lt;a href="/test/default/download/person.image.0246683463831.jpg"&gt;file&lt;/a&gt;|
&lt;input type="checkbox" name="image__delete" /&gt;delete]&lt;/div&gt;&lt;/td&gt;&lt;td&gt;&lt;/td&gt;&lt;/tr&gt;
&lt;tr id="delete_record__row"&gt;&lt;td&gt;&lt;label id="delete_record__label" for="delete_record"
&gt;Check to delete:&lt;/label&gt;&lt;/td&gt;&lt;td&gt;&lt;input type="checkbox" id="delete_record"
class="delete" name="delete_this_record" /&gt;&lt;/td&gt;</code></pre><p>Zawiera on odnośnik umożliwiający pobieranie załadowanego pliku z serwera oraz pole wyboru do usuwania pliku z rekordu bazy danych (i tym samym przechowywaniu NULL w polu "image").</p><p>Dlaczego ten mechanizm jest udostępniany? Dlaczego trzeba napisać samemu funkcję pobierania? Bo można wymusić jakiś machanizm autoryzacji w funkcji pobierającej. Rozdział 9 zawiera przykład.</p><p>Normalnie przesyłane pliki są przechowywane a katalogu "app/uploads", ale można określić inną lokalizację:</p><pre><code>Field('image', 'upload', uploadfolder='...')</code></pre><p>W większości systemów operacyjnych, dostęp do systemu plików może być wolny, gdy w fplderze znajduje się wiele plików. Gdy planuje się przesyłanie więcej niż 1000 plików, można poprosić web2py o przesyłanie plików do podfolderów:</p><pre><code>Field('image', 'upload', uploadseparate=True)</code></pre><h4>Przechowywanie oryginalnych nazw plików</h4><p>Web2py automatycznie zapsisuje oryginalna nazwę pliku wewnątrz nowej nazwy UUID pliku i pobiera ją, gdy plik jest pobierany z serwera. Po pobraniu pliku z serwera, oryginalna nazwa pliku jest zapisywana w nagłówku <em>content-disposition</em> odpowiedzi HTTP. Dzieje się to w sposób przejrzysty, bez konieczności programowania.</p><p>Czasami zachodzi konieczność zapisania oryginalnej nazwy pliku w bazie danych. W takim przypadku trzeba zmodyfikować model i dodać pole do przechowywania tej nazwy:</p><pre><code class="code">db.define_table('person',
    Field('name', requires=IS_NOT_EMPTY()),
    Field('image_filename'),
    Field('image', 'upload'))</code></pre><p>Potem trzeba zmodyfikować kontroler, tak aby to obsługiwał:</p><pre><code class="code">def display_form():
    record = db.person(request.args(0)) or redirect(URL('index'))
    url = URL('download')
    form = SQLFORM(db.person, record, deletable=True,
                   upload=url, fields=['name', 'image'])
    if request.vars.image!=None:
        form.vars.image_filename = request.vars.image.filename
    if form.process().accepted:
        response.flash = 'form accepted'
    elif form.errors:
        response.flash = 'form has errors'
    return dict(form=form)</code></pre><p>Proszę zauważyć, że <code>SQLFORM</code> nie wyświetla pola "image_filename". Akcja "display_form" przenosi nazwę pliku <code>request.vars.image</code> do <code>form.vars.image_filename</code>, aby można ją było przetworzyć przez <code>accepts</code> i zapisać w bazie danych. Zanim funkcja pobierajaca prześle plik, sprawdzi w bazie danych oryginalną nazwę pliku i użyje ją w nagłówku <em>content-disposition</em>.</p><h4>Atrybut <code>autodelete</code></h4><div class="inxx">autodelete</div><p><code>SQLFORM</code>, przy usuwaniu rekordu, nie usuwa fizycznie przesłanych na serwer plików do których odnosi się ten rekord. Jest to spowodowane tym, że web2py nie wie czy ten sam plik nie jest używany (zlinkowany) z innym tabelami lub używany w innych celach. Jeśli wie się, że dany plik mozna bezpiecznie usunąć podczas usuwania związanego z nim rekordu, można wykonać co następuje:</p><pre><code class="code">db.define_table('image',
    Field('name', requires=IS_NOT_EMPTY()),
    Field('source','upload',autodelete=True))</code></pre><p>Atrybut <code>autodelete</code> jest ustawiany domyślnie na <code>False</code>. Gdy ustawi się go na <code>True</code>, plik zostanie usunięty przy usuwaniu rekordu.</p><h4>Odnośniki do rekordów</h4><p>Rozważmy teraz przypadek dwóch tabel połączonych przez odnoszące się pole. Na przykład:</p><pre><code class="code">db.define_table('person',
    Field('name', requires=IS_NOT_EMPTY()))
db.define_table('dog',
    Field('owner', 'reference person'),
    Field('name', requires=IS_NOT_EMPTY()))
db.dog.owner.requires = IS_IN_DB(db,db.person.id,'%(name)s')</code></pre><p>Osoba ma psy a każdy pies należy do jakiegoś właściciela, który jest osobą. Właściciel psa jest zobowiazany do odniesienia prawidłowego pola <code>db.person.id</code> przez nazwę <code>'%(name)s'</code>.</p><p>Wykorzystajmy interfejs <strong>appadmin</strong> naszej aplikacji do dodania kilku osób i ich psów.</p><p>Podczas edytowania istniejącej osoby, formularz UPDATE <strong>appadmin</strong> pokazuje odnośnik do strony z wykazem psów należących do tej osoby. Zachowanie takie może być replikowane przy pomocy argumentu <code>linkto</code>. Argument <code>linkto</code> musi wskazywać na lokalizator URL nowej akcji, która otrzymuje ciąg zapytania z <code>SQLFORM</code> oraz listy odpowiednich rekordów. Oto przykład:</p><pre><code class="code">def display_form():
   record = db.person(request.args(0)) or redirect(URL('index'))
   url = URL('download')
   link = URL('list_records', args='db')
   form = SQLFORM(db.person, record, deletable=True,
                  upload=url, linkto=link)
   if form.process().accepted:
       response.flash = 'form accepted'
   elif form.errors:
       response.flash = 'form has errors'
   return dict(form=form)</code></pre><p>a to strona:</p><p><p style="text-align:center"><img src="http://localhost:8000/book/default/image/42/pl6400.png" alt="image" style="width:300px" /></p></p><p>Jest tu odnośnik "dog.owner". Nazwa tego odnośnika może być zmieniona poprzez argument <code>labels</code>, na przykład:</p><pre><code class="code">labels = {'dog.owner':"This person's dogs"}</code></pre><p>Kliknięcie na ten odnośnik spowoduje przekierowanie na:</p><pre><code class="code">/test/default/list_records/dog?query=db.dog.owner%3D%3D5</code></pre><p>"list_records" jest określoną akcją, gdzie <code>request.args(0)</code> ustawia nazwę przywoływanej tabeli a <code>request.vars.query</code> ustawia ciąg zapytania SQL. Ciag zapytania zawiera w lokalizatorze URL odpowiednio zakodowaną wartość "dog.owner=5" (web2py rozkodowuje to automatycznie podczas parsowania URL).</p><p>Można łatwo zaimplementować bardzo ogólną akcję "list_records" w następujacy sposób:</p><pre><code class="code">def list_records():
    import re
    REGEX = re.compile('^(\w+).(\w+).(\w+)\=\=(\d+)$')
    match = REGEX.match(request.vars.query)
    if not match:
        redirect(URL('error'))
    table, field, id = match.group(2), match.group(3), match.group(4)
    records = db(db[table][field]==id).select()
    return dict(records=records)</code></pre><p>ze związanym widokiem "default/list_records.html":</p><pre><code class="code">{{extend 'layout.html'}}
{{=records}}</code></pre><p>Gdy zwracany jest przez *select* zestaw rekordów i serializowany w widoku, to najpierw jest on konwertowany do obiektu SQLTABLE (nie tego samego co Table) i następnie jest serializowany do tabeli HTML, gdzie każde pole odpowiada kolumnie tabeli.</p><h4>Wstępne wypełnianie formularzy</h4><p>Można zawsze wstępnie wypełnić formularz posługujac sie składnią:</p><pre><code class="code">form.vars.name = 'fieldvalue'</code></pre><p>Wyrażenia podobne do powyższego muszą być wstawiane po deklaracji formularza ale przed zakceptowaniem tego formularza, niezaleznie od tego, czy pole ("name" w naszym przykładzie) jest jawnie wizualizowane w formularzu, czy nie.</p><h4>Dodawanie dodatkowych elementów formularza do <code>SQLFORM</code></h4><p>Czasem po utworzeniu formularza zachodzi potrzeba dodania do formularza dodatkowego elementu. Na przykład, mozna chcieć dodać pole wyboru z potwierdzeniem, ze użytkownik akceptuje regulamin strony internetowej:</p><pre><code class="code">form = SQLFORM(db.yourtable)
my_extra_element = TR(LABEL('I agree to the terms and conditions'),                       INPUT(_name='agree',value=True,_type='checkbox'))
form[0].insert(-1,my_extra_element)</code></pre><p>Zmienna <code>my_extra_element</code> powinna być dostosowana do *formstyle*. W naszym przykładzie domyślnie przyjęto <code>formstyle='table3cols'</code>.</p><p>Po złożeniu formularza <code>form.vars.agree</code> bedzie zawierał stan pola wyboru, co może być wykorzystane, na przykład, w funkcji <code>onvalidation</code>.</p><h4><code>SQLFORM</code> bez IO bazy danych</h4><p>Czasem zachodzi potrzeba wygenerowania formularza z tabeli bazy danych przy użyciu <code>SQLFORM</code> i odpowiedniego sprawdzenia zgłoszonego formularza, ale bez jakichkolwiek automatycznych działań INSERT/UPDATE/DELETE na bazie danych. Jest to przypadek występujacy, na przykład, gdy trzeba przetworzyć pola z uwzglednieniem wartości innych pól wejściowych. Przypadek ten występuje również, gdy potrzeba wykonać dodatkową walidację wprowadzonych danych, czego nie można wykonać stosując standardowe walidatory.</p><p>Można to łatwo zrobić poprzez przerwanie:</p><pre><code class="code">form = SQLFORM(db.person)
if form.process().accepted:
    response.flash = 'record inserted'</code></pre><p>into:</p><pre><code class="code">form = SQLFORM(db.person)
if form.validate():
    ### deal with uploads explicitly
    form.vars.id = db.person.insert(**dict(form.vars))
    response.flash = 'record inserted'</code></pre><p>The same can be done for UPDATE/DELETE forms by breaking:</p><pre><code class="code">form = SQLFORM(db.person,record)
if form.process().accepted:
    response.flash = 'record updated'</code></pre><p>into:</p><pre><code class="code">form = SQLFORM(db.person,record)
if form.validate():
    if form.deleted:
        db(db.person.id==record.id).delete()
    else:
        record.update_record(**dict(form.vars))
    response.flash = 'record updated'</code></pre><p>In the case of a table including an "upload"-type field ("fieldname"), both <code>process(dbio=False)</code> and <code>validate()</code> deal with the storage of the uploaded file as if <code>process(dbio=True)</code>, the default behavior.</p><p>The name assigned by web2py to the uploaded file can be found in:</p><pre><code class="code">form.vars.fieldname</code></pre><h3>Other types of Forms</h3><h4><code>SQLFORM.factory</code></h4><p>There are cases when you want to generate forms <em>as if</em> you had a database table but you do not want the database table. You simply want to take advantage of the <code>SQLFORM</code> capability to generate a nice looking CSS-friendly form and perhaps perform file upload and renaming.</p><p>This can be done via a <code>form_factory</code>. Here is an example where you generate the form, perform validation, upload a file and store everything in the <code>session</code> :</p><pre><code class="code">def form_from_factory():
    form = SQLFORM.factory(
        Field('your_name', requires=IS_NOT_EMPTY()),
        Field('your_image', 'upload'))
    if form.process().accepted:
        response.flash = 'form accepted'
        session.your_name = form.vars.your_name
        session.your_image = form.vars.your_image
    elif form.errors:
        response.flash = 'form has errors'
    return dict(form=form)</code></pre><p>The Field object in the SQLFORM.factory() constructor is fully documented in the <a href="../06#markmin_field_constructor">DAL chapter</a>. A run-time construction technique for SQLFORM.factory() is</p><pre><code class="code">fields = []
fields.append(Field(...))
form=SQLFORM.factory(*fields)</code></pre><p>Here is the "default/form_from_factory.html" view:</p><pre><code class="code">{{extend 'layout.html'}}
{{=form}}</code></pre><p>You need to use an underscore instead of a space for field labels, or explicitly pass a dictionary of <code>labels</code> to <code>form_factory</code>, as you would for a <code>SQLFORM</code>. By default <code>SQLFORM.factory</code> generates the form using html "id" attributes generated as if the form was generated from a table called "no_table". To change this dummy table name, use the <code>table_name</code> attribute for the factory:</p><pre><code class="code">form = SQLFORM.factory(...,table_name='other_dummy_name')</code></pre><p>Changing the <code>table_name</code> is necessary if you need to place two factory generated forms in the same table and want to avoid CSS conflicts.</p><h5>Uploading files with SQLFORM.factory</h5><h4>One form for multiple tables</h4><p>It often happens that you have two tables (for example 'client' and 'address' which are linked together by a reference and you want to create a single form that allows to insert info about one client and its default address. Here is how:</p><p>model:</p><pre><code class="code">db.define_table('client',
     Field('name'))
db.define_table('address',
    Field('client','reference client',
          writable=False,readable=False),
    Field('street'),Field('city'))</code></pre><p>controller:</p><pre><code class="code">def register():
    form=SQLFORM.factory(db.client,db.address)
    if form.process().accepted:
        id = db.client.insert(**db.client._filter_fields(form.vars))
        form.vars.client=id
        id = db.address.insert(**db.address._filter_fields(form.vars))
        response.flash='Thanks for filling the form'
    return dict(form=form)</code></pre><p>Notice the SQLFORM.factory (it makes ONE form using public fields from both tables and inherits their validators too). On form accepts this does two inserts, some data in one table and some data in the other.</p><blockquote>This only works when the tables don't have field names in common.</blockquote><h4>Confirmation Forms</h4><div class="inxx">confirm</div><p>Often you need a form with a confirmation choice. The form should be accepted if the choice is accepted and none otherwise. The form may have additional options that link other web pages. web2py provides a simple way to do this:</p><pre><code class="code">form = FORM.confirm('Are you sure?')
if form.accepted: do_what_needs_to_be_done()</code></pre><p>Notice that the confirm form does not need and must not call <code>.accepts</code> or <code>.process</code> because this is done internally. You can add buttons with links to the confirmation form in the form of a dictionary of <code>{'value':'link'}</code>:</p><pre><code class="code">form = FORM.confirm('Are you sure?',{'Back':URL('other_page')})
if form.accepted: do_what_needs_to_be_done()</code></pre><h4>Form to edit a dictionary</h4><p>Imagine a system that stores configurations options in a dictionary,</p><pre><code class="code">config = dict(color='black', language='English')</code></pre><p>and you need a form to allow the visitor to modify this dictionary. This can be done with:</p><pre><code class="code">form = SQLFORM.dictform(config)
if form.process().accepted: config.update(form.vars)</code></pre><p>The form will display one INPUT field for each item in the dictionary. It will use dictionary keys as INPUT names and labels and current values to infer types (string, int, double, date, datetime, boolean).</p><p>This works great but leave to you the logic of making the config dictionary persistent. For example you may want to store the <code>config</code> in a session.</p><pre><code class="code">session.config or dict(color='black', language='English')
form = SQLFORM.dictform(session.config)
if form.process().accepted:
    session.config.update(form.vars)</code></pre><h3>CRUD</h3><p><div class="inxx">CRUD</div> <div class="inxx">crud.create</div> <div class="inxx">crud.update</div> <div class="inxx">crud.select</div> <div class="inxx">crud.search</div> <div class="inxx">crud.tables</div> <div class="inxx">crud.delete</div></p><p>One of the recent additions to web2py is the Create/Read/Update/Delete (CRUD) API on top of SQLFORM. CRUD creates an SQLFORM, but it simplifies the coding because it incorporates the creation of the form, the processing of the form, the notification, and the redirection, all in one single function.</p><p>The first thing to notice is that CRUD differs from the other web2py APIs we have used so far because it is not already exposed. It must be imported. It also must be linked to a specific database. For example:</p><pre><code class="code">from gluon.tools import Crud
crud = Crud(db)</code></pre><p>The <code>crud</code> object defined above provides the following API:</p><p><div class="inxx">crud.tables</div> <div class="inxx">crud.create</div> <div class="inxx">crud.read</div> <div class="inxx">crud.update</div> <div class="inxx">crud.delete</div> <div class="inxx">crud.select</div> .</p><ul><li><code>crud.tables()</code> returns a list of tables defined in the database.</li><li><code>crud.create(db.tablename)</code> returns a create form for table tablename.</li><li><code>crud.read(db.tablename, id)</code> returns a readonly form for tablename and record id.</li><li><code>crud.update(db.tablename, id)</code> returns an update form for tablename and record id.</li><li><code>crud.delete(db.tablename, id)</code> deletes the record.</li><li><code>crud.select(db.tablename, query)</code> returns a list of records selected from the table.</li><li><code>crud.search(db.tablename)</code> returns a tuple (form, records) where form is a search form and records is a list of records based on the submitted search form.</li><li><code>crud()</code> returns one of the above based on the <code>request.args()</code>.</li></ul><p>For example, the following action:</p><pre><code class="code">def data(): return dict(form=crud())</code></pre><p>would expose the following URLs:</p><pre><code class="code">http://.../[app]/[controller]/data/tables
http://.../[app]/[controller]/data/create/[tablename]
http://.../[app]/[controller]/data/read/[tablename]/[id]
http://.../[app]/[controller]/data/update/[tablename]/[id]
http://.../[app]/[controller]/data/delete/[tablename]/[id]
http://.../[app]/[controller]/data/select/[tablename]
http://.../[app]/[controller]/data/search/[tablename]</code></pre><p>However, the following action:</p><pre><code class="code">def create_tablename():
    return dict(form=crud.create(db.tablename))</code></pre><p>would only expose the create method</p><pre><code class="code">http://.../[app]/[controller]/create_tablename</code></pre><p>While the following action:</p><pre><code class="code">def update_tablename():
    return dict(form=crud.update(db.tablename, request.args(0)))</code></pre><p>would only expose the update method</p><pre><code class="code">http://.../[app]/[controller]/update_tablename/[id]</code></pre><p>and so on.</p><p>The behavior of CRUD can be customized in two ways: by setting some attributes of the <code>crud</code> object or by passing extra parameters to each of its methods.</p><h4>Settings</h4><p>Here is a complete list of current CRUD attributes, their default values, and meaning:</p><p>To enforce authentication on all crud forms:</p><pre><code class="code">crud.settings.auth = auth</code></pre><p>The use is explained in chapter 9.</p><p>To specify the controller that defines the <code>data</code> function which returns the <code>crud</code> object</p><pre><code class="code">crud.settings.controller = 'default'</code></pre><p>To specify the URL to redirect to after a successful "create" record:</p><pre><code class="code">crud.settings.create_next = URL('index')</code></pre><p>To specify the URL to redirect to after a successful "update" record:</p><pre><code class="code">crud.settings.update_next = URL('index')</code></pre><p>To specify the URL to redirect to after a successful "delete" record:</p><pre><code class="code">crud.settings.delete_next = URL('index')</code></pre><p>To specify the URL to be used for linking uploaded files:</p><pre><code class="code">crud.settings.download_url = URL('download')</code></pre><p>To specify extra functions to be executed after standard validation procedures for <code>crud.create</code> forms:</p><pre><code class="code">crud.settings.create_onvalidation = StorageList()</code></pre><p><code>StorageList</code> is the same as a <code>Storage</code> object, they are both defined in the file "gluon/storage.py", but it defaults to <code>[]</code> as opposed to <code>None</code>. It allows the following syntax:</p><pre><code class="code">crud.settings.create_onvalidation.mytablename.append(lambda form:....)</code></pre><p>To specify extra functions to be executed after        standard validation procedures for <code>crud.update</code> forms:</p><pre><code class="code">crud.settings.update_onvalidation = StorageList()</code></pre><p>To specify extra functions to be executed after completion of <code>crud.create</code> forms:</p><pre><code class="code">crud.settings.create_onaccept = StorageList()</code></pre><p>To specify extra functions to be executed after completion of <code>crud.update</code> forms:</p><pre><code class="code">crud.settings.update_onaccept = StorageList()</code></pre><p>To specify extra functions to be executed after completion of <code>crud.update</code> if record is deleted:</p><pre><code class="code">crud.settings.update_ondelete = StorageList()</code></pre><p>To specify extra functions to be executed after completion of <code>crud.delete</code>:</p><pre><code class="code">crud.settings.delete_onaccept = StorageList()</code></pre><p>To determine whether the "update" forms should have a "delete" button:</p><pre><code class="code">crud.settings.update_deletable = True</code></pre><p>To determine whether the "update" forms should show the id of the edited record:</p><pre><code class="code">crud.settings.showid = False</code></pre><p>To determine whether forms should keep the previously inserted values or reset to default after successful submission:</p><pre><code class="code">crud.settings.keepvalues = False</code></pre><p>Crud always detects whether a record being edited has been modified by a third party in the time between the time when the form is displayed and the time when it is submitted. This behavior is equivalent to</p><code>form.process(detect_record_change=True)</code><p>and it is set in:</p><pre><code class="code">crud.settings.detect_record_change = True</code></pre><p>and it can be changed/disabled by setting the variable to <code>False</code>.</p><p>You can change the form style by</p><pre><code class="code">crud.settings.formstyle = 'table3cols' or 'table2cols' or 'divs' or 'ul'</code></pre><p>You can set the separator in all crud forms:</p><pre><code class="code">crud.settings.label_separator = ':'</code></pre><h4>captcha</h4><p>You can add captcha to forms, using the same convention explained for auth, with:</p><pre><code class="code">crud.settings.create_captcha = None
crud.settings.update_captcha = None
crud.settings.captcha = None</code></pre><h4>Messages</h4><p>Here is a list of customizable messages:</p><pre><code class="code">crud.messages.submit_button = 'Submit'</code></pre><p>sets the text of the "submit" button for both create and update forms.</p><pre><code class="code">crud.messages.delete_label = 'Check to delete:'</code></pre><p>sets the label of the "delete" button in "update" forms.</p><pre><code class="code">crud.messages.record_created = 'Record Created'</code></pre><p>sets the flash message on successful record creation.</p><pre><code class="code">crud.messages.record_updated = 'Record Updated'</code></pre><p>sets the flash message on successful record update.</p><pre><code class="code">crud.messages.record_deleted = 'Record Deleted'</code></pre><p>sets the flash message on successful record deletion.</p><pre><code class="code">crud.messages.update_log = 'Record %(id)s updated'</code></pre><p>sets the log message on successful record update.</p><pre><code class="code">crud.messages.create_log = 'Record %(id)s created'</code></pre><p>sets the log message on successful record creation.</p><pre><code class="code">crud.messages.read_log = 'Record %(id)s read'</code></pre><p>sets the log message on successful record read access.</p><pre><code class="code">crud.messages.delete_log = 'Record %(id)s deleted'</code></pre><p>sets the log message on successful record deletion.</p><blockquote>Notice that <code>crud.messages</code> belongs to the class <code>gluon.storage.Message</code> which is similar to <code>gluon.storage.Storage</code> but it automatically translates its values, without need for the <code>T</code> operator.</blockquote><p>Log messages are used if and only if CRUD is connected to Auth as discussed in Chapter 9. The events are logged in the Auth table "auth_events".</p><h4>Methods</h4><p>The behavior of CRUD methods can also be customized on a per call basis. Here are their signatures:</p><pre><code class="code">crud.tables()
crud.create(table, next, onvalidation, onaccept, log, message)
crud.read(table, record)
crud.update(table, record, next, onvalidation, onaccept, ondelete, log, message, deletable)
crud.delete(table, record_id, next, message)
crud.select(table, query, fields, orderby, limitby, headers, **attr)
crud.search(table, query, queries, query_labels, fields, field_labels, zero, showall, chkall)</code></pre><ul><li><code>table</code> is a DAL table or a tablename the method should act on.</li><li><code>record</code> and <code>record_id</code> are the id of the record the method should act on.</li><li><code>next</code> is the URL to redirect to after success. If the URL contains the substring "[id]" this will be replaced by the id of the record currently created/updated.</li><li><code>onvalidation</code> has the same function as SQLFORM(..., onvalidation)</li><li><code>onaccept</code> is a function to be called after the form submission is accepted and acted upon, but before redirection.</li><li><code>log</code> is the log message. Log messages in CRUD see variables in the <code>form.vars</code> dictionary such as "%(id)s".</li><li><code>message</code> is the flash message upon form acceptance.</li><li><code>ondelete</code> is called in place of <code>onaccept</code> when a record is deleted via an "update" form.</li><li><code>deletable</code> determines whether the "update" form should have a delete option.</li><li><code>query</code> is the query to be used to select records.</li><li><code>fields</code> is a list of fields to be selected.</li><li><code>orderby</code> determines the order in which records should be selected (see <a href="../06#markmin_orderby">DAL chapter</a>).</li><li><code>limitby</code> determines the range of selected records that should be displayed (see Chapter 6).</li><li><code>headers</code> is a dictionary with the table header names.</li><li><code>queries</code> a list like <code>['equals', 'not equal', 'contains']</code> containing the allowed methods in the search form.</li><li><code>query_labels</code> a dictionary like <code>query_labels=dict(equals='Equals')</code> giving names to search methods.</li><li><code>fields</code> a list of fields to be listed in the search widget.</li><li><code>field_labels</code> a dictionary mapping field names into labels.</li><li><code>zero</code> defaults to "choose one" is used as default option for the drop-down in the search widget.</li><li><code>showall</code> set it to True if you want rows returned as per the query in the first call (added after 1.98.2).</li><li><code>chkall</code> set it to True to turn on all the checkboxes in the search form (added after 1.98.2).</li></ul><p>Here is an example of usage in a single controller function:</p><pre><code class="code">## assuming db.define_table('person', Field('name'))
def people():
    form = crud.create(db.person, next=URL('index'),
           message=T("record created"))
    persons = crud.select(db.person, fields=['name'],
           headers={'person.name': 'Name'})
    return dict(form=form, persons=persons)</code></pre><p>Here is another very generic controller function that lets you search, create and edit any records from any table where the tablename is passed request.args(0):</p><pre><code class="code">def manage():
    table=db[request.args(0)]
    form = crud.update(table,request.args(1))
    table.id.represent = lambda id, row:        A('edit:',id,_href=URL(args=(request.args(0),id)))
    search, rows = crud.search(table)
    return dict(form=form,search=search,rows=rows)</code></pre><p>Notice the line <code>table.id.represent=...</code> that tells web2py to change the representation of the id field and display a link instead to the page itself and passes the id as request.args(1) which turns the create page into an update page.</p><h4>Record versioning</h4><p>Both SQLFORM and CRUD provides a utility to version database records:</p><p>If you have a table (db.mytable) that needs full revision history you can just do:</p><pre><code class="code">form = SQLFORM(db.mytable, myrecord).process(onsuccess=auth.archive)</code></pre><pre><code class="code">form = crud.update(db.mytable, myrecord, onaccept=auth.archive)</code></pre><p><code>auth.archive</code> defines a new table called <strong>db.mytable_archive</strong> (the name is derived from the name of the table to which it refers) and on updating, it stores a copy of the record (as it was before the update) in the created archive table, including a reference to the current record.</p><p>Because the record is actually updated (only its previous state is archived), references are never broken.</p><p>This is all done under the hood.  Should you wish to access the archive table you should define it in a model:</p><pre><code class="code">db.define_table('mytable_archive',
   Field('current_record', 'reference mytable'),
   db.mytable)</code></pre><p>Notice the table extends <code>db.mytable</code> (including all its fields), and adds  a reference to the <code>current_record</code>.</p><p><code>auth.archive</code> does not timestamp the stored record unless your original table has timestamp fields, for example:</p><pre><code class="code">db.define_table('mytable',
    Field('created_on', 'datetime',
          default=request.now, update=request.now, writable=False),
    Field('created_by', 'reference auth_user',
          default=auth.user_id, update=auth.user_id, writable=False),</code></pre><p>There is nothing special about these fields and you may give them any name you like. They are filled before the record is archived and are archived with each copy of the record.  The archive table name and/or reference field name can be changed like this:</p><pre><code class="code">db.define_table('myhistory',
    Field('parent_record', 'reference mytable'),
    db.mytable)
## ...
form = SQLFORM(db.mytable,myrecord)
form.process(onsuccess = lambda form:auth.archive(form,
             archive_table=db.myhistory,
             current_record='parent_record'))</code></pre><h3>Custom forms</h3><p>If a form is created with SQLFORM, SQLFORM.factory or CRUD, there are multiple ways it can be embedded in a view allowing multiple degrees of customization. Consider for example the following model:</p><pre><code class="code">db.define_table('image',
    Field('name', requires=IS_NOT_EMPTY()),
    Field('source', 'upload'))</code></pre><p>and upload action</p><pre><code class="code">def upload_image():
    return dict(form=SQLFORM(db.image).process())</code></pre><p>The simplest way to embed the form in the view for <code>upload_image</code> is</p><pre><code class="code">{{=form}}</code></pre><p>This results in a standard table layout. If you wish to use a different layout, you can break the form into components</p><pre><code class="code">{{=form.custom.begin}}
Name: &lt;div&gt;{{=form.custom.widget.name}}&lt;/div&gt;
File: &lt;div&gt;{{=form.custom.widget.source}}&lt;/div&gt;
{{=form.custom.submit}}
{{=form.custom.end}}</code></pre><p>where <code>form.custom.widget[fieldname]</code> gets serialized into the proper widget for the field. If the form is submitted and it contains errors, they are appended below the widgets, as usual.</p><p>The above sample form is show in the image below.</p><p><p style="text-align:center"><img src="http://localhost:8000/book/default/image/42/en6500.png" alt="image" style="width:300px" /></p></p><p>A similar result could have been obtained without using a custom form:</p><pre><code class="code">SQLFORM(...,formstyle='table2cols')</code></pre><p>or in case of CRUD forms with the following parameter:</p><pre><code class="code">crud.settings.formstyle='table2cols'</code></pre><p>Other possible <code>formstyle</code>s are "table3cols" (the default), "divs" and "ul".</p><p>If you do not wish to use the widgets serialized by web2py, you can replace them with HTML. There are some variables that will be useful for this:</p><ul><li><code>form.custom.label[fieldname]</code> contains the label for the field.</li><li><code>form.custom.comment[fieldname]</code> contains the comment for the field.</li><li><code>form.custom.dspval[fieldname]</code> form-type and field-type dependent display representation of the field.</li><li><code>form.custom.inpval[fieldname]</code> form-type and field-type dependent values to be used in field code.</li></ul><p>If you form has <code>deletable=True</code> you should also insert</p><pre><code class="code">{{=form.custom.delete}}</code></pre><p>to display the delete checkbox.</p><p>It is important to follow the conventions described below.</p><h4>CSS conventions</h4><p>Tags in forms generated by SQLFORM, SQLFORM.factory and CRUD follow a strict CSS naming convention that can be used to further customize the forms.</p><p>Given a table "mytable", and a field "myfield" of type "string", it is rendered by default by a</p><pre><code class="code">SQLFORM.widgets.string.widget</code></pre><p>that looks like this:</p><pre><code class="code">&lt;input type="text" name="myfield" id="mytable_myfield"
       class="string" /&gt;</code></pre><p>Notice that:</p><ul><li>the class of the INPUT tag is the same as the type of the field. This is very important for the jQuery code in "web2py_ajax.html" to work. It makes sure that you can only have numbers in "integer" and "double" fields, and that "time", "date" and "datetime" fields display the popup calendar/datepicker.</li><li>the id is the name of the class plus the name of the field, joined by one underscore. This allows you to uniquely refer to the field via, for example, <code>jQuery('#mytable_myfield')</code> and manipulate the stylesheet of the field or bind actions associated to the field events (focus, blur, keyup, etc.).</li><li>the name is, as you would expect, the field name.</li></ul><h4>Hide errors</h4><div class="inxx">hideerror</div><p>Occasionally, you may want to disable the automatic error placement and display form error messages in some place other than the default. That can be done easily.</p><ul><li>In the case of FORM or SQLFORM, pass <code>hideerror=True</code> to the <code>accepts</code> method.</li><li>In the case of CRUD, set <code>crud.settings.hideerror=True</code></li></ul><p>You may also want to modify the views to display the error (since they are no longer displayed automatically).</p><p>Here is an example where the errors are displayed above the form and not in the form.</p><pre><code class="code">{{if form.errors:}}
  Your submitted form contains the following errors:
  &lt;ul&gt;
  {{for fieldname in form.errors:}}
    &lt;li&gt;{{=fieldname}} error: {{=form.errors[fieldname]}}&lt;/li&gt;
  {{pass}}
  &lt;/ul&gt;
  {{form.errors.clear()}}
{{pass}}
{{=form}}</code></pre><p>The errors will displayed as in the image shown below.</p><p><p style="text-align:center"><img src="http://localhost:8000/book/default/image/42/en6600.png" alt="image" style="width:300px" /></p></p><p>This mechanism also works for custom forms.</p><h3>Validators</h3><div class="inxx">validators</div><p>Validators are classes used to validate input fields (including forms generated from database tables). With the advanced forms derived from SQLFORM, validators create widgets such as drop-down menus and lookups from other tables.</p><p>Here is an example of using a validator with a <code>FORM</code>:</p><pre><code class="code">INPUT(_name='a', requires=IS_INT_IN_RANGE(0, 10))</code></pre><p>Here is an example of how to require a validator for a table field:</p><pre><code class="code">db.define_table('person', Field('name'))
db.person.name.requires = IS_NOT_EMPTY()</code></pre><p>Validators are always assigned using the <code>requires</code> attribute of a field. A field can have a single validator or multiple validators. Multiple validators are made part of a list:</p><pre><code class="code">db.person.name.requires = [IS_NOT_EMPTY(),
                           IS_NOT_IN_DB(db, 'person.name')]</code></pre><p>Normally validators are called automatically by the function <code>accepts</code> and <code>process</code> of a <code>FORM</code> or other HTML helper object that contains a form. They are called in the order in which they are listed.</p><p>One can also call validators explicitly for a field:</p><pre><code>db.person.name.validate(value)</code></pre><p>which returns a tuple <code>(value,error)</code> and <code>error</code> is <code>None</code> if no the value validates.</p><p>Built-in validators have constructors that take an optional argument:</p><pre><code class="code">IS_NOT_EMPTY(error_message='cannot be empty')</code></pre><p><code>error_message</code> allows you to override the default error message for any validator.</p><p>Here is an example of a validator on a database table:</p><pre><code class="code">db.person.name.requires = IS_NOT_EMPTY(error_message='fill this!')</code></pre><p>where we have used the translation operator <code>T</code> to allow for internationalization. Notice that default error messages are not translated.</p><p>Mind that the only validators that can be used with <code>list:</code> type fields are:</p><ul><li><code>IS_IN_DB(...,multiple=True)</code></li><li><code>IS_IN_SET(...,multiple=True)</code></li><li><code>IS_NOT_EMPTY()</code></li><li><code>IS_LIST_OF(...)</code></li></ul><p>The latter can be used to apply any validator to the individual items in the list. <code>multiple=(1,1000)</code> requires a selection of between 1 and 1000 items. This enforces selection of at least one choice.</p><h4>Text format validators</h4><h5><code>IS_ALPHANUMERIC</code></h5><div class="inxx">IS_ALPHANUMERIC</div><p>This validator checks that a field value contains only characters in the ranges a-z, A-Z, or 0-9.</p><pre><code class="code">requires = IS_ALPHANUMERIC(error_message='must be alphanumeric!')</code></pre><h5><code>IS_LOWER</code></h5><div class="inxx">IS_LOWER</div><p>This validator never returns an error. It just converts the value to lower case.</p><pre><code class="code">requires = IS_LOWER()</code></pre><h5><code>IS_UPPER</code></h5><div class="inxx">IS_UPPER</div><p>This validator never returns an error. It converts the value to upper case.</p><pre><code class="code">requires = IS_UPPER()</code></pre><h5><code>IS_EMAIL</code></h5><div class="inxx">IS_EMAIL</div><p>It checks that the field value looks like an email address. It does not try to send email to confirm.</p><pre><code class="code">requires = IS_EMAIL(error_message='invalid email!')</code></pre><h5><code>IS_MATCH</code></h5><div class="inxx">IS_MATCH</div><p>This validator matches the value against a regular expression and returns an error if it does not match. Here is an example of usage to validate a US zip code:</p><pre><code class="code">requires = IS_MATCH('^\d{5}(-\d{4})?$',
         error_message='not a zip code')</code></pre><p>Here is an example of usage to validate an IPv4 address (note: the IS_IPV4 validator is more appropriate for this purpose):</p><pre><code class="code">requires = IS_MATCH('^\d{1,3}(.\d{1,3}){3}$',
         error_message='not an IP address')</code></pre><p>Here is an example of usage to validate a US phone number:</p><pre><code class="code">requires = IS_MATCH('^1?((-)\d{3}-?|\(\d{3}\))\d{3}-?\d{4}$',
         error_message='not a phone number')</code></pre><p>For more information on Python regular expressions, refer to the official Python documentation.</p><p><code>IS_MATCH</code> takes an optional argument <code>strict</code> which defaults to <code>False</code>. When set to <code>True</code> it only matches the beginning of the string:</p><pre><code>&gt;&gt;&gt; IS_MATCH('ab', strict=False)('abc')
('abc', None)
&gt;&gt;&gt; IS_MATCH('ab', strict=True)('abc')
('abc', 'Invalid expression')
</code></pre><p><code>IS_MATCH</code> takes an other optional argument <code>search</code> which defaults to <code>False</code>. When set to <code>True</code>, it uses regex method <code>search</code> instead of method <code>match</code> to validate the string.</p><p><code>IS_MATCH('...', extract=True)</code> filters and extract only the first matching substring rather than the original value.</p><h5><code>IS_LENGTH</code></h5><div class="inxx">IS_LENGTH</div><p>Checks if length of field's value fits between given boundaries. Works for both text and file inputs.</p><p>Its arguments are:</p><ul><li>maxsize: the maximum allowed length / size (has default = 255)</li><li>minsize: the minimum allowed length / size</li></ul><p>Examples: Check if text string is shorter than 33 characters:</p><pre><code class="code">INPUT(_type='text', _name='name', requires=IS_LENGTH(32))</code></pre><p>Check if password string is longer than 5 characters:</p><pre><code class="code">INPUT(_type='password', _name='name', requires=IS_LENGTH(minsize=6))</code></pre><p>Check if uploaded file has size between 1KB and 1MB:</p><pre><code class="code">INPUT(_type='file', _name='name', requires=IS_LENGTH(1048576, 1024))</code></pre><p>For all field types except for files, it checks the length of the value. In the case of files, the value is a <code>cookie.FieldStorage</code>, so it validates the length of the data in the file, which is the behavior one might intuitively expect.</p><h5><code>IS_URL</code></h5><div class="inxx">IS_URL</div><p>Rejects a URL string if any of the following is true:</p><ul><li>The string is empty or None</li><li>The string uses characters that are not allowed in a URL</li><li>The string breaks any of the HTTP syntactic rules</li><li>The URL scheme specified (if one is specified) is not 'http' or 'https'</li><li>The top-level domain (if a host name is specified) does not exist</li></ul><p>(These rules are based on RFC 2616<sup>[<a href="/book/default/reference/42/RFC2616" target="_blank">RFC2616</a>]</sup> )</p><p>This function only checks the URL's syntax. It does not check that the URL points to a real document, for example, or that it otherwise makes semantic sense. This function does automatically prepend 'http://' in front of a URL in the case of an abbreviated URL (e.g. 'google.ca').</p><p>If the parameter mode='generic' is used, then this function's behavior changes. It then rejects a URL string if any of the following is true:</p><ul><li>The string is empty or None</li><li>The string uses characters that are not allowed in a URL</li><li>The URL scheme specified (if one is specified) is not valid</li></ul><p>(These rules are based on RFC 2396<sup>[<a href="/book/default/reference/42/RFC2396" target="_blank">RFC2396</a>]</sup> )</p><p>The list of allowed schemes is customizable with the allowed_schemes parameter. If you exclude None from the list, then abbreviated URLs (lacking a scheme such as 'http') will be rejected.</p><p>The default prepended scheme is customizable with the prepend_scheme parameter. If you set prepend_scheme to None, then prepending will be disabled. URLs that require prepending to parse will still be accepted, but the return value will not be modified.</p><p>IS_URL is compatible with the Internationalized Domain Name (IDN) standard specified in RFC 3490<sup>[<a href="/book/default/reference/42/RFC3490" target="_blank">RFC3490</a>]</sup> ). As a result, URLs can be regular strings or unicode strings. If the URL's domain component (e.g. google.ca) contains non-US-ASCII letters, then the domain will be converted into Punycode (defined in RFC 3492<sup>[<a href="/book/default/reference/42/RFC3492" target="_blank">RFC3492</a>]</sup> ). IS_URL goes a bit beyond the standards, and allows non-US-ASCII characters to be present in the path and query components of the URL as well. These non-US-ASCII characters will be encoded. For example, space will be encoded as'%20'. The unicode character with hex code 0x4e86 will become '%4e%86'.</p><p>Examples:</p><pre><code class="code">requires = IS_URL())
requires = IS_URL(mode='generic')
requires = IS_URL(allowed_schemes=['https'])
requires = IS_URL(prepend_scheme='https')
requires = IS_URL(mode='generic',
                  allowed_schemes=['ftps', 'https'],
                  prepend_scheme='https')</code></pre><h5><code>IS_SLUG</code></h5><div class="inxx">IS_SLUG</div><pre><code class="code">requires = IS_SLUG(maxlen=80, check=False, error_message='must be slug')</code></pre><p>If <code>check</code> is set to <code>True</code> it check whether the validated value is a slug (allowing only alphanumeric characters and non-repeated dashes).</p><p>If <code>check</code> is set to <code>False</code> (default) it converts the input value to a slug.</p><h4>Date and time validators</h4><h5><code>IS_TIME</code></h5><div class="inxx">IS_TIME</div><p>This validator checks that a field value contains a valid time in the specified format.</p><pre><code class="code">requires = IS_TIME(error_message='must be HH:MM:SS!')</code></pre><h5><code>IS_DATE</code></h5><div class="inxx">IS_DATE</div><p>This validator checks that a field value contains a valid date in the specified format. It is good practice to specify the format using the translation operator, in order to support different formats in different locales.</p><pre><code class="code">requires = IS_DATE(format=T('%Y-%m-%d'),
                   error_message='must be YYYY-MM-DD!')</code></pre><p>For the full description on % directives look under the IS_DATETIME validator.</p><p>For the full description on % directives look under the IS_DATETIME validator.</p><h5><code>IS_DATETIME</code></h5><div class="inxx">IS_DATETIME</div><p>This validator checks that a field value contains a valid datetime in the specified format. It is good practice to specify the format using the translation operator, in order to support different formats in different locales.</p><pre><code class="code">requires = IS_DATETIME(format=T('%Y-%m-%d %H:%M:%S'),
                       error_message='must be YYYY-MM-DD HH:MM:SS!')</code></pre><p>The following symbols can be used for the format string (this shows the symbol and an example string):</p><pre><code class="code">%Y  '1963'
%y  '63'
%d  '28'
%m  '08'
%b  'Aug'
%b  'August'
%H  '14'
%I  '02'
%p  'PM'
%M  '30'
%S  '59'</code></pre><h5><code>IS_DATE_IN_RANGE</code></h5><div class="inxx">IS_DATE_IN_RANGE</div><p>Works very much like the previous validator but allows to specify a range:</p><pre><code class="code">requires = IS_DATE_IN_RANGE(format=T('%Y-%m-%d'),
                   minimum=datetime.date(2008,1,1),
                   maximum=datetime.date(2009,12,31),
                   error_message='must be YYYY-MM-DD!')</code></pre><h5><code>IS_DATETIME_IN_RANGE</code></h5><div class="inxx">IS_DATETIME_IN_RANGE</div><p>Works very much like the previous validator but allows to specify a range:</p><pre><code class="code">requires = IS_DATETIME_IN_RANGE(format=T('%Y-%m-%d %H:%M:%S'),
                       minimum=datetime.datetime(2008,1,1,10,30),
                       maximum=datetime.datetime(2009,12,31,11,45),
                       error_message='must be YYYY-MM-DD HH:MM::SS!')</code></pre><p>For the full description on % directives look under the IS_DATETIME validator.</p><h4>Range, set and equality validators</h4><h5><code>IS_EQUAL_TO</code></h5><div class="inxx">IS_EQUEL_TO</div><p>Checks whether the validated value is equal to a given value (which can be a variable):</p><pre><code class="code">requires = IS_EQUAL_TO(request.vars.password,
                       error_message='passwords do not match')</code></pre><h5><code>IS_NOT_EMPTY</code></h5><div class="inxx">IS_NOT_EMPTY</div><p>This validator checks that the content of the field value is not an empty string.</p><pre><code class="code">requires = IS_NOT_EMPTY(error_message='cannot be empty!')</code></pre><h5><code>IS_NULL_OR</code></h5><div class="inxx">IS_NULL_OR</div><p>Deprecated, an alias for <code>IS_EMPTY_OR</code> described below.</p><h5><code>IS_EMPTY_OR</code></h5><div class="inxx">IS_EMPTY_OR</div><p>Sometimes you need to allow empty values on a field along with other requirements. For example a field may be a date but it can also be empty. The <code>IS_EMPTY_OR</code> validator allows this:</p><pre><code class="code">requires = IS_EMPTY_OR(IS_DATE())</code></pre><h5><code>IS_EXPR</code></h5><div class="inxx">IS_EXPR</div><p>Its first argument is a string containing a logical expression in terms of a variable value. It validates a field value if the expression evaluates to <code>True</code>. For example:</p><pre><code class="code">requires = IS_EXPR('int(value)%3==0',
                   error_message='not divisible by 3')</code></pre><p>One should first check that the value is an integer so that an exception will not occur.</p><pre><code class="code">requires = [IS_INT_IN_RANGE(0, 100), IS_EXPR('value%3==0')]</code></pre><h5><code>IS_DECIMAL_IN_RANGE</code></h5><div class="inxx">IS_DECIMAL_IN_RANGE</div><pre><code class="code">INPUT(_type='text', _name='name', requires=IS_DECIMAL_IN_RANGE(0, 10, dot="."))</code></pre><p>It converts the input into a Python Decimal or generates an error if the decimal does not fall within the specified inclusive range. The comparison is made with Python Decimal arithmetic.</p><p>The minimum and maximum limits can be None, meaning no lower or upper limit, respectively.</p><p>The <code>dot</code> argument is optional and allows you to internationalize the symbol used to separate the decimals.</p><h5><code>IS_FLOAT_IN_RANGE</code></h5><div class="inxx">IS_FLOAT_IN_RANGE</div><p>Checks that the field value is a floating point number within a definite range, <code>0 &lt;= value &lt;= 100</code> in the following example:</p><pre><code class="code">requires = IS_FLOAT_IN_RANGE(0, 100, dot=".",
         error_message='too small or too large!')</code></pre><p>The <code>dot</code> argument is optional and allows you to internationalize the symbol used to separate the decimals.</p><h5><code>IS_INT_IN_RANGE</code></h5><div class="inxx">IS_INT_IN_RANGE</div><p>Checks that the field value is an integer number within a definite range, <code>0 &lt;= value &lt; 100</code> in the following example:</p><pre><code class="code">requires = IS_INT_IN_RANGE(0, 100,
         error_message='too small or too large!')</code></pre><h5><code>IS_IN_SET</code></h5><div class="inxx">IS_IN_SET</div><div class="inxx">multiple</div><p>In SQLFORM (and the grids) this validator will automatically set the form field to an option field (ie, with a drop-down menu).</p><p><code>IS_IN_SET</code> checks that the field values are in a set:</p><pre><code class="code">requires = IS_IN_SET(['a', 'b', 'c'],zero=T('choose one'),
         error_message='must be a or b or c')</code></pre><p>The zero argument is optional and it determines the text of the option selected by default, an option which is not accepted by the <code>IS_IN_SET</code> validator itself. If you do not want a "choose one" option, set <code>zero=None</code>.</p><p>The elements of the set can be combined with an numerical validator, as long as IS_IN_SET is first in the list. Doing so wil force conversion by the validtor to the numerical type. So, IS_IN_SET can be followed by  <code>IS_INT_IN_RANGE</code> (which converts the value to int) or  <code>IS_FLOAT_IN_RANGE</code> (which converts the value to float). For example:</p><pre><code class="code">requires = [ IS_IN_SET([2, 3, 5, 7],IS_INT_IN_RANGE(0, 8),
          error_message='must be prime and less than 10')]</code></pre><p><span class="anchor" id="markmin_checkbox_validation"></span></p><h6>Checkbox validation</h6><p>To force a filled-in form checkbox (such as an acceptance of terms and conditions), use this:</p><pre><code class="code">requires=IS_IN_SET(['on'])</code></pre><h6>Dictionaries and tuples with IS_IN_SET</h6><p>You may also use a dictionary or a list of tuples to make the drop down list more descriptive:</p><pre><code class="code">Dictionary example:
requires = IS_IN_SET({'A':'Apple','B':'Banana','C':'Cherry'},zero=None)

List of tuples example:
requires = IS_IN_SET([('A','Apple'),('B','Banana'),('C','Cherry')])</code></pre><h5><code>IS_IN_SET</code> and Tagging</h5><p>The <code>IS_IN_SET</code> validator has an optional attribute <code>multiple=False</code>. If set to True, multiple values can be stored in one field. The field should be of type <code>list:integer</code> or <code>list:string</code>. <code>multiple</code> references are handled automatically in create and update forms, but they are transparent to the DAL. We strongly suggest using the jQuery multiselect plugin to render multiple fields.</p><blockquote>Note that when <code>multiple=True</code>, <code>IS_IN_SET</code> will accept <code>zero</code> or more values, i.e. it will accept the field when nothing has been selected. <code>multiple</code> can also be a tuple of the form <code>(a,b)</code> where <code>a</code> and <code>b</code> are the minimum and (exclusive) maximum number of items that can be selected respectively.</blockquote><h4>Complexity and security validators</h4><h5><code>IS_STRONG</code></h5><div class="inxx">IS_STRONG</div><p>Enforces complexity requirements on a field (usually a password field)</p><p>Example:</p><pre><code class="code">requires = IS_STRONG(min=10, special=2, upper=2)</code></pre><p>where</p><ul><li>min is minimum length of the value</li><li>special is the minimum number of required special characters special characters are any of the following <code>!@#$%^&amp;*(){}[]-+</code></li><li>upper is the minimum number of upper case characters</li></ul><h5><code>CRYPT</code></h5><div class="inxx">CRYPT</div><p>This is also a filter. It performs a secure hash on the input and it is used to prevent passwords from being passed in the clear to the database.</p><pre><code class="code">requires = CRYPT()</code></pre><p>By default, CRYPT uses 1000 iterations of the pbkdf2 algorithm combined with SHA512 to produce a 20-byte-long hash. Older versions of web2py used "md5" or HMAC+SHA512 depending on whether a key was was specified or not.</p><p>If a key is specified, CRYPT uses the HMAC algorithm. The key may contain a prefix that determines the algorithm to use with HMAC, for example SHA512:</p><pre><code class="code">requires = CRYPT(key='sha512:thisisthekey')</code></pre><p>This is the recommended syntax. The key must be a unique string associated with the database used. The key can never be changed. If you lose the key, the previously hashed values become useless.</p><p>By default, CRYPT uses random salt, such that each result is different. To use a constant salt value, specify its value:</p><pre><code class="code">requires = CRYPT(salt='mysaltvalue')</code></pre><p>Or, to use no salt:</p><pre><code class="code">requires = CRYPT(salt=False)</code></pre><p>The CRYPT validator hashes its input, and this makes it somewhat special. If you need to validate a password field before it is hashed, you can use CRYPT in a list of validators, but must make sure it is the last of the list, so that it is called last. For example:</p><pre><code class="code">requires = [IS_STRONG(),CRYPT(key='sha512:thisisthekey')]</code></pre><p><code>CRYPT</code> also takes a <code>min_length</code> argument, which defaults to zero.</p><p>The resulting hash takes the form <code>alg$salt$hash</code>, where <code>alg</code> is the hash algorithm used, <code>salt</code> is the salt string (which can be empty), and <code>hash</code> is the algorithm's output. Consequently, the hash is self-identifying, allowing, for example, the algorithm to be changed without invalidating previous hashes. The key, however, must remain the same.</p><h4>Special type validators</h4><h5><code>IS_LIST_OF</code></h5><div class="inxx">IS_LIST_OF</div><p>This is not properly a validator. Its intended use is to allow validations of fields that return multiple values. It is used in those rare cases when a form contains multiple fields with the same name or a multiple selection box. Its only argument is another validator, and all it does is to apply the other validator to each element of the list. For example, the following expression checks that every item in a list is an integer in the range 0-10:</p><pre><code class="code">requires = IS_LIST_OF(IS_INT_IN_RANGE(0, 10))</code></pre><p>It never returns an error and does not contain an error message. The inner validator controls the error generation.</p><h5><code>IS_IMAGE</code></h5><div class="inxx">IS_IMAGE</div><p>This validator checks if a file uploaded through the file input was saved in one of the selected image formats and has dimensions (width and height) within given limits.</p><p>It does not check for maximum file size (use IS_LENGTH for that). It returns a validation failure if no data was uploaded. It supports the file formats BMP, GIF, JPEG, PNG, and it does not require the Python Imaging Library.</p><p>Code parts taken from ref.<sup>[<a href="/book/default/reference/42/source1" target="_blank">source1</a>]</sup></p><p>It takes the following arguments:</p><ul><li>extensions: iterable containing allowed image file extensions in lowercase</li><li>maxsize: iterable containing maximum width and height of the image</li><li>minsize: iterable containing minimum width and height of the image</li></ul><p>Use (-1, -1) as minsize to bypass the image-size check.</p><p>Here are some Examples:</p><ul><li>Check if uploaded file is in any of supported image formats:</li></ul><pre><code class="code">requires = IS_IMAGE()</code></pre><ul><li>Check if uploaded file is either JPEG or PNG:</li></ul><pre><code class="code">requires = IS_IMAGE(extensions=('jpeg', 'png'))</code></pre><ul><li>Check if uploaded file is PNG with maximum size of 200x200 pixels:</li></ul><pre><code class="code">requires = IS_IMAGE(extensions=('png'), maxsize=(200, 200))</code></pre><ul><li>Note: on displaying an edit form for a table including <code>requires = IS_IMAGE()</code>, a <code>delete</code> checkbox will NOT appear because to delete the file would cause the validation to fail. To display the <code>delete</code> checkbox use this validation:</li></ul><pre><code class="code">requires = IS_EMPTY_OR(IS_IMAGE())</code></pre><h5><code>IS_UPLOAD_FILENAME</code></h5><div class="inxx">IS_UPLOAD_FILENAME</div><p>This validator checks if the name and extension of a file uploaded through the file input matches the given criteria.</p><p>It does not ensure the file type in any way. Returns validation failure if no data was uploaded.</p><p>Its arguments are:</p><ul><li>filename: filename (before dot) regex.</li><li>extension: extension (after dot) regex.</li><li>lastdot: which dot should be used as a filename / extension separator: <code>True</code> indicates last dot (e.g., "file.tar.gz" will be broken in "file.tar" + "gz") while <code>False</code> means first dot (e.g., "file.tar.gz" will be broken into "file" + "tar.gz").</li><li>case: 0 means keep the case; 1 means transform the string into lowercase (default); 2 means transform the string into uppercase.</li></ul><p>If there is no dot present, extension checks will be done against an empty string and filename checks will be done against the whole value.</p><p>Examples:</p><p>Check if file has a pdf extension (case insensitive):</p><pre><code class="code">requires = IS_UPLOAD_FILENAME(extension='pdf')</code></pre><p>Check if file has a tar.gz extension and name starting with backup:</p><pre><code class="code">requires = IS_UPLOAD_FILENAME(filename='backup.*', extension='tar.gz', lastdot=False)</code></pre><p>Check if file has no extension and name matching README (case sensitive):</p><pre><code class="code">requires = IS_UPLOAD_FILENAME(filename='^README$', extension='^$', case=0)</code></pre><h5><code>IS_IPV4</code></h5><div class="inxx">IS_IPV4</div><p>This validator checks if a field's value is an IP version 4 address in decimal form. Can be set to force addresses from a certain range.</p><p>IPv4 regex taken from ref.<sup>[<a href="/book/default/reference/42/regexlib" target="_blank">regexlib</a>]</sup> Its arguments are:</p><ul><li><code>minip</code> lowest allowed address; accepts: <strong>str</strong>, e.g., 192.168.0.1; <strong>iterable of numbers</strong>, e.g., [192, 168, 0, 1]; <strong>int</strong>, e.g., 3232235521</li><li><code>maxip</code> highest allowed address; same as above</li></ul><p>All three example values are equal, since addresses are converted to integers for inclusion check with following function:</p><pre><code class="code">number = 16777216 * IP[0] + 65536 * IP[1] + 256 * IP[2] + IP[3]</code></pre><p>Examples:</p><p>Check for valid IPv4 address:</p><pre><code class="code">requires = IS_IPV4()</code></pre><p>Check for valid private network IPv4 address:</p><pre><code class="code">requires = IS_IPV4(minip='192.168.0.1', maxip='192.168.255.255')</code></pre><h4>Other validators</h4><h5><code>CLEANUP</code></h5><div class="inxx">CLEANUP</div><p>This is a filter. It never fails. It just removes all characters whose decimal ASCII codes are not in the list [10, 13, 32-127].</p><pre><code class="code">requires = CLEANUP()</code></pre><h4>Database validators</h4><h5><code>IS_NOT_IN_DB</code></h5><div class="inxx">IS_NOT_IN_DB</div><h6>Synopsis:</h6><code>IS_NOT_IN_DB(db|set, 'table.field')</code><p>Consider the following example:</p><pre><code class="code">db.define_table('person', Field('name'))
db.person.name.requires = IS_NOT_IN_DB(db, 'person.name')</code></pre><p>It requires that when you insert a new person, his/her name is not already in the database, <code>db</code>, in the field <code>person.name</code>.</p><p>A set can be used instead of <code>db</code>.</p><p>As with all other validators this requirement is enforced at the form processing level, not at the database level. This means that there is a small probability that, if two visitors try to concurrently insert records with the same person.name, this results in a race condition and both records are accepted. It is therefore safer to also inform the database that this field should have a unique value:</p><pre><code class="code">db.define_table('person', Field('name', unique=True))
db.person.name.requires = IS_NOT_IN_DB(db, 'person.name')</code></pre><p>Now if a race condition occurs, the database raises an OperationalError and one of the two inserts is rejected.</p><p>The first argument of <code>IS_NOT_IN_DB</code> can be a database connection or a Set. In the latter case, you would be checking only the set defined by the Set.</p><p>A complete argument list for <code>IS_NOT_IN_DB()</code> is as follows:</p><pre><code class="code">IS_NOT_IN_DB(dbset, field, error_message='value already in database or empty', allowed_override=[],
    ignore_common_filters=True)</code></pre><p>The following code, for example, does not allow registration of two persons with the same name within 10 days of each other:</p><pre><code class="code">import datetime
now = datetime.datetime.today()
db.define_table('person',
    Field('name'),
    Field('registration_stamp', 'datetime', default=now))
recent = db(db.person.registration_stamp&gt;now-datetime.timedelta(10))
db.person.name.requires = IS_NOT_IN_DB(recent, 'person.name')</code></pre><h5><code>IS_IN_DB</code></h5><div class="inxx">IS_IN_DB</div><p><span class="anchor" id="markmin_validate_IS_IN_DB"></span></p><h6>Synopsis:</h6><code>IS_IN_DB(db|set,'table.value_field','%(representing_field)s',zero='choose one')</code><p>where the third and fourth arguments are optional.</p><p><code>multiple=</code> is also possible if the field type is a list. The default is False. It can be set to True or to a tuple (min,max) to restrict the number of values selected. So <code>multiple=(1,10)</code> enforces at least one and at most ten selections.</p><p>Other optional arguments are discussed below.</p><h6>Example</h6><p>Consider the following tables and requirement:</p><pre><code class="code">db.define_table('person', Field('name', unique=True))
db.define_table('dog', Field('name'), Field('owner', db.person)
db.dog.owner.requires = IS_IN_DB(db, 'person.id', '%(name)s',
                                 zero=T('choose one'))
*or using a Set*
db.person.name.requires = IS_IN_DB(db(db.person.id&gt;10), 'person.id', '%(name)s')</code></pre><p>It is enforced at the level of dog INSERT/UPDATE/DELETE forms. This example requires that a <code>dog.owner</code> be a valid id in the field <code>person.id</code> in the database <code>db</code>. Because of this validator, the <code>dog.owner</code> field is represented as a drop-down list. The third argument of the validator is a string that describes the elements in the drop-down list. In the example you want to see the person <code>%(name)s</code> instead of the person <code>%(id)s</code>. <code>%(...)s</code> is replaced by the value of the field in brackets for each record.</p><p>The <code>zero</code> option works very much like for the <code>IS_IN_SET</code> validator.</p><p>The first argument of the validator can be a database connection or a DAL Set, as in <code>IS_NOT_IN_DB</code>. This can be useful for example when wishing to limit the records in the drop-down list. In this example, we use <code>IS_IN_DB</code> in a controller to limit the records dynamically each time the controller is called:</p><pre><code class="code">def index():
    (...)
    query = (db.table.field == 'xyz') #in practice 'xyz' would be a variable
    db.table.field.requires=IS_IN_DB(db(query),....)
    form=SQLFORM(...)
    if form.process().accepted: ...
    (...)</code></pre><p>If you want the field validated, but you do not want a drop-down, you must put the validator in a list.</p><pre><code class="code">db.dog.owner.requires = [IS_IN_DB(db, 'person.id', '%(name)s')]</code></pre><div class="inxx">_and</div><p>Occasionally you want the drop-down (so you do not want to use the list syntax above) yet you want to use additional validators. For this purpose the <code>IS_IN_DB</code> validator takes an extra argument <code>_and</code> that can point to a list of other validators applied if the validated value passes the <code>IS_IN_DB</code> validation. For example to validate all dog owners in db that are not in a subset:</p><pre><code class="code">subset=db(db.person.id&gt;100)
db.dog.owner.requires = IS_IN_DB(db, 'person.id', '%(name)s',
                                 _and=IS_NOT_IN_DB(subset,'person.id'))</code></pre><p><code>IS_IN_DB</code> has a boolean <code>distinct</code> argument which defaults to <code>False</code>. When set to <code>True</code> it prevents repeated values in the drop-down.</p><p><code>IS_IN_DB</code> also takes a <code>cache</code> argument that works like the <code>cache</code> argument of select.</p><h5><code>IS_IN_DB</code> and Tagging</h5><div class="inxx">tags</div><div class="inxx">multiple</div><p>The <code>IS_IN_DB</code> validator has an optional attribute <code>multiple=False</code>. If set to <code>True</code> multiple values can be stored in one field. This field should be of type <code>list:reference</code> as discussed in Chapter 6. An explicit example of tagging is discussed there. <code>multiple</code> references are handled automatically in create and update forms, but they are transparent to the DAL. We strongly suggest using the jQuery multiselect plugin to render multiple fields.</p><h4>Custom validators</h4><div class="inxx">custom validator</div><p>All validators follow the prototype below:</p><pre><code class="code">class sample_validator:
    def __init__(self, *a, error_message='error'):
        self.a = a
        self.e = error_message
    def __call__(self, value):
        if validate(value):
            return (parsed(value), None)
        return (value, self.e)
    def formatter(self, value):
        return format(value)</code></pre><p>i.e., when called to validate a value, a validator returns a tuple <code>(x, y)</code>. If <code>y</code> is <code>None</code>, then the value passed validation and <code>x</code> contains a parsed value. For example, if the validator requires the value to be an integer, <code>x</code> is converted to <code>int(value)</code>. If the value did not pass validation, then <code>x</code> contains the input value and <code>y</code> contains an error message that explains the failed validation. This error message is used to report the error in forms that do not validate.</p><p>The validator may also contain a <code>formatter</code> method. It must perform the opposite conversion to the one the <code>__call__</code> does. For example, consider the source code for <code>IS_DATE</code>:</p><pre><code class="code">class IS_DATE(object):
    def __init__(self, format='%Y-%m-%d', error_message='must be YYYY-MM-DD!'):
        self.format = format
        self.error_message = error_message
    def __call__(self, value):
        try:
            y, m, d, hh, mm, ss, t0, t1, t2 = time.strptime(value, str(self.format))
            value = datetime.date(y, m, d)
            return (value, None)
        except:
            return (value, self.error_message)
    def formatter(self, value):
        return value.strftime(str(self.format))</code></pre><p>On success, the <code>__call__</code> method reads a date string from the form and converts it into a datetime.date object using the format string specified in the constructor. The <code>formatter</code> object takes a datetime.date object and converts it to a string representation using the same format. The <code>formatter</code> is called automatically in forms, but you can also call it explicitly to convert objects into their proper representation. For example:</p><pre><code class="code">&gt;&gt;&gt; db = DAL()
&gt;&gt;&gt; db.define_table('atable',
       Field('birth', 'date', requires=IS_DATE('%m/%d/%Y')))
&gt;&gt;&gt; id = db.atable.insert(birth=datetime.date(2008, 1, 1))
&gt;&gt;&gt; row = db.atable[id]
&gt;&gt;&gt; print db.atable.formatter(row.birth)
01/01/2008</code></pre><p>When multiple validators are required (and stored in a list), they are executed in order and the output of one is passed as input to the next. The chain breaks when one of the validators fails.</p><p>Conversely, when we call the <code>formatter</code> method of a field, the formatters of the associated validators are also chained, but in reverse order.</p><blockquote>Notice that as alternative to custom validators, you can also use the <code>onvalidate</code> argument of <code>form.accepts(...)</code>, <code>form.process(...)</code> and <code>form.validate(...)</code>.</blockquote><h4>Validators with dependencies</h4><p>Usually validators are set once for all in models.</p><p>Occasionally, you need to validate a field and the validator depends on the value of another field. This can be done in various ways. It can be done in the model or in the controller.</p><p>For example, here is a page that generates a registration form that asks for username and password twice. None of the fields can be empty, and both passwords must match:</p><pre><code class="code">def index():
    form = SQLFORM.factory(
        Field('username', requires=IS_NOT_EMPTY()),
        Field('password', requires=IS_NOT_EMPTY()),
        Field('password_again',
              requires=IS_EQUAL_TO(request.vars.password)))
    if form.process().accepted:
        pass # or take some action
    return dict(form=form)</code></pre><p>The same mechanism can be applied to FORM and SQLFORM objects.</p><h3>Widgets</h3><p>Here is a list of available web2py widgets:</p><pre><code class="code">SQLFORM.widgets.string.widget
SQLFORM.widgets.text.widget
SQLFORM.widgets.password.widget
SQLFORM.widgets.integer.widget
SQLFORM.widgets.double.widget
SQLFORM.widgets.time.widget
SQLFORM.widgets.date.widget
SQLFORM.widgets.datetime.widget
SQLFORM.widgets.upload.widget
SQLFORM.widgets.boolean.widget
SQLFORM.widgets.options.widget
SQLFORM.widgets.multiple.widget
SQLFORM.widgets.radio.widget
SQLFORM.widgets.checkboxes.widget
SQLFORM.widgets.autocomplete</code></pre><p>The first ten of them are the defaults for the corresponding field types. The "options" widget is used when a field's requires is <code>IS_IN_SET</code> or <code>IS_IN_DB</code> with <code>multiple=False</code> (default behavior). The "multiple" widget is used when a field's requires is <code>IS_IN_SET</code> or <code>IS_IN_DB</code> with <code>multiple=True</code>. The "radio" and "checkboxes" widgets are never used by default, but can be set manually. The autocomplete widget is special and discussed in its own section.</p><p>For example, to have a "string" field represented by a textarea:</p><pre><code class="code">Field('comment', 'string', widget=SQLFORM.widgets.text.widget)</code></pre><p>Widgets can also be assigned to fields <em>a posteriori</em>:</p><pre><code>db.mytable.myfield.widget = SQLFORM.widgets.string.widget</code></pre><p>Sometimes widgets take additional arguments and one needs to specify their values. In this case one can use <code>lambda</code></p><pre><code>db.mytable.myfield.widget = lambda field,value:     SQLFORM.widgets.string.widget(field,value,_style='color:blue')</code></pre><p>Widgets are helper factories and their first two arguments are always <code>field</code> and <code>value</code>. The other arguments can include normal helper attributes such as <code>_style</code>, <code>_class</code>, etc. Some widgets also take special arguments. In particular <code>SQLFORM.widgets.radio</code> and <code>SQLFORM.widgets.checkboxes</code> take a <code>style</code> argument (not to be confused with <code>_style</code>) which can be set to "table", "ul", or "divs" in order to match the <code>formstyle</code> of the containing form.</p><p>You can create new widgets or extend existing widgets.</p><p><code>SQLFORM.widgets[type]</code> is a class and <code>SQLFORM.widgets[type].widget</code> is a static member function of the corresponding class. Each widget function takes two arguments: the field object, and the current value of that field. It returns a representation of the widget. As an example, the string widget could be re-coded as follows:</p><pre><code class="code">def my_string_widget(field, value):
    return INPUT(_name=field.name,
                 _id="%s_%s" % (field._tablename, field.name),
                 _class=field.type,
                 _value=value,
                 requires=field.requires)

Field('comment', 'string', widget=my_string_widget)</code></pre><p>The id and class values must follow the convention described later in this chapter. A widget may contain its own validators, but it is good practice to associate the validators to the "requires" attribute of the field and have the widget get them from there.</p><h4>Autocomplete widget</h4><div class="inxx">autocomplete</div><p>There are two possible uses for the autocomplete widget: to autocomplete a field that takes a value from a list or to autocomplete a reference field (where the string to be autocompleted is a representation of the reference which is implemented as an id).</p><p>The first case is easy:</p><pre><code class="code">db.define_table('category',Field('name'))
db.define_table('product',Field('name'),Field('category'))
db.product.category.widget = SQLFORM.widgets.autocomplete(
     request, db.category.name, limitby=(0,10), min_length=2)</code></pre><p>Where <code>limitby</code> instructs the widget to display no more than 10 suggestions at the time, and <code>min_length</code> instructs the widget to perform an Ajax callback to fetch suggestions only after the user has typed at least 2 characters in the search box.</p><p>The second case is more complex:</p><pre><code class="code">db.define_table('category',Field('name'))
db.define_table('product',Field('name'),Field('category'))
db.product.category.widget = SQLFORM.widgets.autocomplete(
     request, db.category.name, id_field=db.category.id)</code></pre><p>In this case the value of <code>id_field</code> tells the widget that even if the value to be autocompleted is a <code>db.category.name</code>, the value to be stored is the corresponding <code>db.category.id</code>. An optional parameter is <code>orderby</code> that instructs the widget on how to sort the suggestions (alphabetical by default).</p><p>This widget works via Ajax. Where is the Ajax callback? Some magic is going on in this widget. The callback is a method of the widget object itself. How is it exposed? In web2py any piece of code can generate a response by raising an HTTP exception. This widget exploits this possibility in the following way: the widget sends the Ajax call to the same URL that generated the widget in the first place and puts a special token in the request.vars. Should the widget get instantiated again, it finds the token and raises an HTTP exception that responds to the request. All of this is done under the hood and hidden to the developer.</p><h2><code>SQLFORM.grid</code> and <code>SQLFORM.smartgrid</code></h2><blockquote>Attention: grid and smartgrid were experimental prior web2py version 2.0 and were vulnerable to information leakage. The grid and smartgrid are no longer experimental, but we are still not promising backward compatibility of the presentation layer of the grid, only of its APIs.</blockquote><p>These are two high level objects that create complex CRUD controls. They provide pagination, the ability to browse, search, sort, create, update and delete records from a single object.</p><p>Because web2py's HTML objects build on the underlying, simpler objects, the grids create SQLFORMs for viewing, editing and creating its rows. Many of the arguments to the grids are passed through to this SQLFORM. This means the documentation for SQLFORM (and FORM) is relevant. For example, the grid takes an <code>onvalidation</code> callback. The processing logic of the grid ultimately passes this through to the underlying process() method of FORM, which means you should consult the documentation of <code>onvalidation</code> for FORMs.</p><p>As the grid passes through different states, such as editing a row, a new request is generated. request.args has information about which state the grid is in.</p><h3><code>SQLFORM.grid</code></h3><p>The simplest of the two is <code>SQLFORM.grid</code>. Here is an example of usage:</p><pre><code class="code">@auth.requires_login()
def manage_users():
    grid = SQLFORM.grid(db.auth_user)
    return locals()</code></pre><p>which produces the following page:</p><p><p style="text-align:center"><img src="http://localhost:8000/book/default/image/42/en6700.png" alt="image" style="width:480px" /></p></p><p>The first argument of <code>SQLFORM.grid</code> can be a table or a query. The grid object will provide access to records matching the query.</p><p>Before we dive into the long list of arguments of the grid object we need to understand how it works. The object looks at <code>request.args</code> in order to decide what to do (browse, search, create, update, delete, etc.). Each button created by the object links the same function (<code>manage_users</code> in the above case) but passes different <code>request.args</code>.</p><h4>login required by default for data updates</h4><p>By default all the URLs generated by the grid are digitally signed and verified. This means one cannot perform certain actions (create, update, delete) without being logged-in. These restrictions can be relaxed:</p><pre><code class="code">def manage_users():
    grid = SQLFORM.grid(db.auth_user,user_signature=False)
    return locals()</code></pre><p>but we do not recommend it.</p><h4>Multiple grids per controller function</h4><blockquote>Because of the way grid works one can only have one grid per controller function, unless they are embedded as components via <code>LOAD</code>.
To make the default search grid work in more than one LOADed grid, please use a different <code>formname</code> for each one.</blockquote><h4>Using requests.args safely</h4><p>Because the controller function that contains the grid may itself manipulate the URL arguments (known in web2py as response.args and response.vars), the grid needs to know which args should be handled by the grid and which not. Here is an example of code that allows one to manage any table:</p><pre><code class="code">@auth.requires_login()
def manage():
    table = request.args(0)
    if not table in db.tables(): redirect(URL('error'))
    grid = SQLFORM.grid(db[table],args=request.args[:1])
    return locals()</code></pre><p>the <code>args</code> argument of the <code>grid</code> specifies which <code>request.args</code> should be passed along and ignored by the <code>grid</code>. In our case <code>request.args[:1]</code> is the name of the table we want to manage and it is handled by the <code>manage</code> function itself, not by the <code>grid</code>. So, <code>args=request.args[:1]</code> tells the grid to preserve the first URL argument in any links that it generates, appending any grid-specific arguments after that first argument.</p><h4>SQLFORM.grid signature</h4><p>The complete signature for the grid is the following:</p><pre><code class="code">SQLFORM.grid(
    query,
    fields=None,
    field_id=None,
    left=None,
    headers={},
    orderby=None,
    groupby=None,
    searchable=True,
    sortable=True,
    paginate=20,
    deletable=True,
    editable=True,
    details=True,
    selectable=None,
    create=True,
    csv=True,
    links=None,
    links_in_grid=True,
    upload='&lt;default&gt;',
    args=[],
    user_signature=True,
    maxtextlengths={},
    maxtextlength=20,
    onvalidation=None,
    oncreate=None,
    onupdate=None,
    ondelete=None,
    sorter_icons=(XML('&amp;#x2191;'), XML('&amp;#x2193;')),
    ui = 'web2py',
    showbuttontext=True,
    _class="web2py_grid",
    formname='web2py_grid',
    search_widget='default',
    ignore_rw = False,
    formstyle = 'table3cols',
    exportclasses = None,
    formargs={},
    createargs={},
    editargs={},
    viewargs={},
    buttons_placement = 'right',
    links_placement = 'right'
    )</code></pre><ul><li><code>fields</code> is a list of fields to be fetched from the database. It is also used to determine which fields to be shown in the grid view. However, it doesn't control what is displayed in the separate form used to edit rows. For that, use the readable and writable attribute of the database fields. For example, in a editable grid, suppress updating of a field like this: before creating the SQLFORM.grid, set</li></ul><pre><code class="code">db.my_table.a_field.writable = False
db.my_table.a_field.readable = False
</code></pre><ul><li><code>field_id</code> must be the field of the table to be used as ID, for example <code>db.mytable.id</code>.</li><li><code>left</code> is an optional left join expressions used to build <code>...select(left=...)</code>.</li><li><code>headers</code> is a dictionary that maps 'tablename.fieldname' into the corresponding header label, e.g. <code>{'auth_user.email' : 'Email Address'}</code></li><li><code>orderby</code> is used as default ordering for the rows. See <a href="../06#markmin_orderby">DAL chapter</a> (multiple fields are possible).</li><li><code>groupby</code> is used to group the set. Use the same syntax as you were passing in a simple <code>select(groupby=...)</code>.</li><li><code>searchable</code>, <code>sortable</code>, <code>deletable</code>, <code>editable</code>, <code>details</code>, <code>create</code> determine whether one can search, sort, delete, edit, view details, and create new records respectively.</li><li><code>selectable</code> can be used to call a custom function on multiple records (a checkbox will be inserted for every row) e.g. <code class="code">   selectable = lambda ids : redirect(URL('default', 'mapping_multiple', vars=dict(id=ids)))</code></li></ul><p>or for multiple action buttons, use a list of tuples:</p><code class="code"> selectable = [('button label1',lambda...),('button label2',lambda ...)]</code><ul><li><code>paginate</code> sets the max number of rows per page.</li><li><code>csv</code> if set to true allows to download the grid in various format (more on that later).</li><li><code>links</code> is used to display new columns which can be links to other pages. The <code>links</code> argument must be a list of  <code>dict(header='name',body=lambda row: A(...))</code> where <code>header</code> is the header of the new column and <code>body</code> is a function that takes a row and returns a value. In the example, the value is a <code>A(...)</code> helper.</li><li><code>links_in_grid</code> if set to False, links will only be displayed in the "details" and "edit" page (so, not on the main grid)</li><li><code>upload</code> same as SQLFORM's one. web2py uses the action at that URL to download the file</li><li><code>maxtextlength</code> sets the maximum length of text to be displayed for each field value, in the grid view. This value can be overwritten for each field using <code>maxtextlengths</code>, a dictionary of 'tablename.fieldname':length e.g. <code>{'auth_user.email' : 50}</code></li><li><code>onvalidation</code>, <code>oncreate</code>, <code>onupdate</code> and <code>ondelete</code> are callback functions. All but <code>ondelete</code> take a form object as input, ondelete takes the table and the record id</li></ul><p>Because the edit/create form is an SQLFORM which extends FORM, these callbacks are essentially used in the same way as documented in the sections for FORM and SQLFORM.</p><p>Here is skeleton code:</p><pre><code class="code">def myonvalidation(form):
    print "In onvalidation callback"
    print form.vars
    form.errors= True  #this prevents the submission from completing
    
    #...or to add messages to specific elements on the form
    form.errors.first_name = "Do not name your child after prominent deities"   
    form.errors.last_name = "Last names must start with a letter"
    response.flash = "I don't like your submission" 

def myoncreate(form):
    print 'create!'
    print form.vars

def myonupdate(form):
    print 'update!'
    print form.vars

def myondelete(table, id):
    print 'delete!'
    print table, id</code></pre><p>onupdate and oncreate are the same callbacks available to SQLFORM.process()</p><ul><li><code>sorter_icons</code> is a list of two strings (or helpers) that will be used to represent the up and down sorting options for each field.</li><li><code>ui</code> can be set equal to 'web2py' and will generate web2py friendly class names, can be set equal to <code>jquery-ui</code> and will generate jquery UI friendly class names, but it can also be its own set of class names for the various grid components: <pre><code class="code">ui = dict(
    widget='',
    header='',
    content='',
    default='',
    cornerall='',
    cornertop='',
    cornerbottom='',
    button='button',
    buttontext='buttontext button',
    buttonadd='icon plus',
    buttonback='icon leftarrow',
    buttonexport='icon downarrow',
    buttondelete='icon trash',
    buttonedit='icon pen',
    buttontable='icon rightarrow',
    buttonview='icon magnifier')</code></pre></li><li><code>search_widget</code> allows to override the default search widget and we refer the reader the source code in "gluon/sqlhtml.py" for details.</li><li><code>showbuttontext</code> allows buttons without text (there will effectively be only icons)</li><li><code>_class</code> is the class for the grid container.</li><li><code>exportclasses</code> takes a dictionary of tuples: by default it's defined as</li></ul><pre><code class="code">csv_with_hidden_cols=(ExporterCSV, 'CSV (hidden cols)'),
csv=(ExporterCSV, 'CSV'),
xml=(ExporterXML, 'XML'),
html=(ExporterHTML, 'HTML'),
tsv_with_hidden_cols=(ExporterTSV, 'TSV (Excel compatible, hidden cols)'),
tsv=(ExporterTSV, 'TSV (Excel compatible)'))</code></pre><p>ExporterCSV, ExporterXML, ExporterHTML and ExporterTSV are all defined in gluon/sqlhtml.py. Take a look at those for creating your own exporter. If you pass a dict like <code>dict(xml=False, html=False)</code> you will disable the xml and html export formats.</p><ul><li><code>formargs</code> is passed to all SQLFORM objects used by the grid, while <code>createargs</code>, <code>editargs</code> and <code>viewargs</code> are passed only to the specific create, edit and details SQLFORMs</li><li><code>formname</code>, <code>ignore_rw</code> and <code>formstyle</code> are passed to the SQLFORM objects used by the grid for create/update forms.</li><li><code>buttons_placement</code> and <code>links_placement</code> both take a parameter ('right', 'left', 'both') that will affect where on the row the buttons (or the links) will be placed</li></ul><blockquote><code>deletable</code>, <code>editable</code> and <code>details</code> are usually boolean values but they can be functions which take the row object and decide whether to display the corresponding button or not.</blockquote><h4>Virtual fields in SQLFORM.grid and smartgrid</h4><p>In versions of web2py after 2.6, virtual fields are shown in grids like normal fields: either shown alongside all other fields by default, or by including them in the <code>fields</code> argument. However, virtual fields are not sortable.</p><p>In older web2py versions, showing virtual fields in a grid requires use of the <code>links</code> argument. This is still supported for more recent versions. If table db.t1 has a field called t1.vfield which is based on the values of t1.field1 and t1.field2, do this:</p><code class="code">grid = SQLFORM.grid(db.t1, ..., fields = [t1.field1, t1.field2,...], 
   links = [dict(header='Virtual Field 1',body=lambda row:row.vfield),...] )</code><p>In all cases, because t1.vfield depends on t1.field1 and t1.field2, these fields must be present in the row. In the example above, this is guaranteed by including t1.field1 and t1.field2 in the fields argument. Alternatively, showing all fields will also work. You can suppress a field from displaying by setting the readable attribute to False.</p><p>Note that when defining the virtual field, the lambda function must qualify fields with the database name, but in the links argument, this is not necessary. So for the example above, the virtual field may be defined like:</p><pre><code class="code">db.define_table('t1',Field('field1','string'),
   Field('field2','string'),
  Field.Virtual('virtual1', lambda row: row.t1.field1 + row.t1.field2),
  ...)</code></pre><h3>SQLFORM.smartgrid</h3><p>A <code>SQLFORM.smartgrid</code> looks a lot like a <code>grid</code>, in fact it contains a grid but it is designed to take as input not a query but only one table and to browse said table and selected referencing tables.</p><p>For example consider the following table structure:</p><pre><code class="code">db.define_table('parent',Field('name'))
db.define_table('child',Field('name'),Field('parent','reference parent'))</code></pre><p>With SQLFORM.grid you can list all parents:</p><pre><code class="code">SQLFORM.grid(db.parent)</code></pre><p>all children:</p><pre><code class="code">SQLFORM.grid(db.child)</code></pre><p>and all parents and children in one table:</p><pre><code class="code">SQLFORM.grid(db.parent,left=db.child.on(db.child.parent==db.parent.id))</code></pre><p>With SQLFORM.smartgrid you can put all the data in one object that spawns both tables:</p><pre><code class="code">@auth.requires_login()
def manage():
    grid = SQLFORM.smartgrid(db.parent,linked_tables=['child'])
    return locals()</code></pre><p>which looks like this:</p><p><p style="text-align:center"><img src="http://localhost:8000/book/default/image/42/en6800.png" alt="image" style="width:480px" /></p></p><p>Notice the extra "children" links. One could create the extra <code>links</code> using a regular <code>grid</code> but they would point to a different action. With a <code>smartgrid</code> they are created automatically and handled by the same object.</p><p>Also notice that when clicking on the "children" link for a given parent one only gets the list of children for that parent (and that is obvious) but also notice that if one now tried to add a new child, the parent value for the new child is automatically set to the selected parent (displayed in the breadcrumbs associated to the object). The value of this field can be overwritten. We can prevent this by making it readonly:</p><pre><code class="code">@auth.requires_login():
def manage():
    db.child.parent.writable = False
    grid = SQLFORM.smartgrid(db.parent,linked_tables=['child'])
    return locals()</code></pre><p>If the <code>linked_tables</code> argument is not specified all referencing tables are automatically linked. Anyway, to avoid accidentally exposing data we recommend explicitly listing tables that should be linked.</p><p>The following code creates a very powerful management interface for all tables in the system:</p><pre><code class="code">@auth.requires_membership('managers'):
def manage():
    table = request.args(0) or 'auth_user'
    if not table in db.tables(): redirect(URL('error'))
    grid = SQLFORM.smartgrid(db[table],args=request.args[:1])
    return locals()</code></pre><h4>smartgrid signature</h4><p>The <code>smartgrid</code> takes the same arguments as a <code>grid</code> and some more with some caveats:</p><ul><li>The first argument is a table, not a query</li><li>There is an extra argument <code>constraints</code> which is a dictionary of 'tablename':query which can be used to further restrict access to the records displayed in the 'tablename' grid.</li><li>There is an extra argument <code>linked_tables</code> which is a list of tablenames of tables that should be accessible via the smartgrid.</li><li><code>divider</code> allows to specify a character to use in the breadcrumb navigator, <code>breadcrumbs_class</code> will apply the class to the breadcrumb element</li><li>All the arguments but the table, <code>args</code>, <code>linked_tables</code> and <code>user_signatures</code> can be dictionaries as explained below.</li></ul><p>Consider the previous grid:</p><pre><code class="code">grid = SQLFORM.smartgrid(db.parent,linked_tables=['child'])</code></pre><p>It allows one to access both a <code>db.parent</code> and a <code>db.child</code>. Apart for navigation controls, for each one table, a smarttable is nothing but a grid. This means that, in this case, one smartgrid can create a grid for parent and one grid for child. We may want to pass different sets of parameters to these grids. For example different sets of <code>searchable</code> parameters.</p><p>While for a grid we would pass a boolean:</p><pre><code class="code">grid = SQLFORM.grid(db.parent,searchable=True)</code></pre><p>For a smartgrid we would pass a dictionary of booleans:</p><pre><code class="code">grid = SQLFORM.smartgrid(db.parent,linked_tables=['child'],
     searchable= dict(parent=True, child=False))</code></pre><p>In this way we made parents searchable but children for each parent not searchable (there should not be that many to need the search widget).</p><h3>grid and smartgrid access control</h3><p><code>grid</code> and <code>smartgrid</code> do not automatically enforce access control like crud does but you can integrate it with <code>auth</code> using explicit permission checking:</p><pre><code class="code">grid = SQLFORM.grid(db.auth_user,
     editable = auth.has_membership('managers'),
     deletable = auth.has_membership('managers'))</code></pre><p>or</p><pre><code class="code">grid = SQLFORM.grid(db.auth_user,
     editable = auth.has_permission('edit','auth_user'),
     deletable = auth.has_permission('delete','auth_user'))</code></pre><h3>smartgrid plurals</h3><p>The <code>smartgrid</code> is the only object in web2py that displays the table name and it needs both the singular and the plural. For example one parent can have one "Child" or many "Children". Therefore a table object needs to know its own singular and plural names. web2py normally guesses them but you can set them explicitly:</p><pre><code class="code">db.define_table('child', ..., singular="Child", plural="Children")</code></pre><p>or with: <div class="inxx">singular</div> <div class="inxx">plural</div></p><pre><code class="code">db.define_table('child', ...)
db.child._singular = "Child"
db.child._plural = "Children"</code></pre><p>They should also be internationalized using the <code>T</code> operator.</p><p>The plural and singular values are then used by <code>smartgrid</code> to provide correct names for headers and links.</p>