<h2>Rdzeń</h2><h3>Opcje linii poleceń</h3><p>Możliwe jest zrezygnowanie z interfejsu UI i rozpoczęcie pracy z web2py bezpośrednio z linii poleceń przez wpisanie czegoś takiego:</p><div class="inxx">hasło</div><pre><code class="code">python web2py.py -a 'your password' -i 127.0.0.1 -p 8000</code></pre><p>Podczas startu web2py tworzony jest plik o nazwie "parameters_8000.py", w którym zapisywane jest szyfrowane hasło. Jeśli użyje się "&lt;ask&gt;" jako hasła, web2py poprosi o podanie hasła.</p><p>Dla dodatkowego bezpieczeństwa można wystartować web2py poleceniem:</p><pre><code class="code">python web2py.py -a '&lt;recycle&gt;' -i 127.0.0.1 -p 8000</code></pre><p>W tym przypadku web2py ponownie wykorzystuje przechowywane zaszyfrowane hasło. Jeśli hasło nie zostało podane lub jeśli plik "parameters_8000.py" został usunięty, nie jest dostępny internetowy interfejs administracyjny.</p><div class="inxx">PAM</div><p>W niektórych systemach Unix/Linux, jeśli hasło to</p><pre><code class="code">&lt;pam_user:some_user&gt;</code></pre><p>web2py używa hasła PAM konta systemu operacyjnego <code>some_user</code> do uwierzytelniania administratora, chyba że jest zablokowany przez konfigurację PAM.</p><blockquote>Platforma web2py zwykle działa z CPython (implementaja C interpretera Python stworzona
przez Guido van Rossum), ale również może działać z PyPy i Jython. Ta ostatnia
implementacja umożliwia używanie web2py w kontekście infrastruktury Java EE.
W celu umożliwienia stosowania Jythona, wystarczy zamienić wyrażenie "python web2py.py ..."
na "jython web2py.py". Szczegółowe informacje o instalacji Jython, modułu zxJDBC
wymaganego do dostępu do bazy danych można znaleźć w rozdziale 14.</blockquote><p>Skrypt "web2py.py" może przyjmować wiele argumentów linii poleceń określających maksymalną liczbę wątków, udostępniających SSL itd. W celu uzyskania pełnego wykazu wpisz:</p><div class="inxx">linia poleceń</div><pre><code class="code">&gt;&gt;&gt; python web2py.py -h
Usage: python web2py.py

web2py Web Framework startup script. ATTENTION: unless a password
is specified (-a 'passwd'), web2py will attempt to run a GUI.
In this case command line options are ignored.

Options:
  --version             show program's version number and exit
  -h, --help            show this help message and exit
  -i IP, --ip=IP        IP address of the server (e.g., 127.0.0.1 or ::1);
                        Note: This value is ignored when using the
                        'interfaces' option.
  -p PORT, --port=PORT  port of server (8000)
  -a PASSWORD, --password=PASSWORD
                        password to be used for administration (use -a
                        "&lt;recycle&gt;" to reuse the last password))
  -c SSL_CERTIFICATE, --ssl_certificate=SSL_CERTIFICATE
                        file that contains ssl certificate
  -k SSL_PRIVATE_KEY, --ssl_private_key=SSL_PRIVATE_KEY
                        file that contains ssl private key
  --ca-cert=SSL_CA_CERTIFICATE
                        Use this file containing the CA certificate to
                        validate X509 certificates from clients
  -d PID_FILENAME, --pid_filename=PID_FILENAME
                        file to store the pid of the server
  -l LOG_FILENAME, --log_filename=LOG_FILENAME
                        file to log connections
  -n NUMTHREADS, --numthreads=NUMTHREADS
                        number of threads (deprecated)
  --minthreads=MINTHREADS
                        minimum number of server threads
  --maxthreads=MAXTHREADS
                        maximum number of server threads
  -s SERVER_NAME, --server_name=SERVER_NAME
                        server name for the web server
  -q REQUEST_QUEUE_SIZE, --request_queue_size=REQUEST_QUEUE_SIZE
                        max number of queued requests when server unavailable
  -o TIMEOUT, --timeout=TIMEOUT
                        timeout for individual request (10 seconds)
  -z SHUTDOWN_TIMEOUT, --shutdown_timeout=SHUTDOWN_TIMEOUT
                        timeout on shutdown of server (5 seconds)
  --socket-timeout=SOCKET_TIMEOUT
                        timeout for socket (5 second)
  -f FOLDER, --folder=FOLDER
                        location of the applications folder (also known as directory) 
  -v, --verbose         increase --test verbosity
  -Q, --quiet           disable all output
  -D DEBUGLEVEL, --debug=DEBUGLEVEL
                        set debug output level (0-100, 0 means all, 100 means
                        none; default is 30)
  -S APPNAME, --shell=APPNAME
                        run web2py in interactive shell or IPython (if
                        installed) with specified appname (if app does not
                        exist it will be created). APPNAME like a/c/f (c,f
                        optional)
  -B, --bpython         run web2py in interactive shell or bpython (if
                        installed) with specified appname (if app does not
                        exist it will be created). Use combined with --shell
  -P, --plain           only use plain python shell; should be used with
                        --shell option
  -M, --import_models   auto import model files; default is False; should be
                        used with --shell option
  -R PYTHON_FILE, --run=PYTHON_FILE
                        run PYTHON_FILE in web2py environment; should be used
                        with --shell option
  -K SCHEDULER, --scheduler=SCHEDULER
                        run scheduled tasks for the specified apps: expects a
                        list of app names as -K app1,app2,app3 or a list of
                        app:groups as -K app1:group1:group2,app2:group1 to
                        override specific group_names. (only strings, no
                        spaces allowed. Requires a scheduler defined in the
                        models
  -X, --with-scheduler  run schedulers alongside webserver
  -T TEST_PATH, --test=TEST_PATH
                        run doctests in web2py environment; TEST_PATH like
                        a/c/f (c,f optional)
  -C, --cron            trigger a cron run manually; usually invoked from a
                        system crontab
  --softcron            triggers the use of softcron
  -Y, --run-cron        start the background cron process
  -J, --cronjob         identify cron-initiated command
  -L CONFIG, --config=CONFIG
                        config file
  -F PROFILER_FILENAME, --profiler=PROFILER_FILENAME
                        profiler filename
  -t, --taskbar         use web2py gui and run in taskbar (system tray)
  --nogui               text-only, no GUI
  -A ARGS, --args=ARGS  should be followed by a list of arguments to be passed
                        to script, to be used with -S, -A must be the last
                        option
  --no-banner           Do not print header banner
  --interfaces=INTERFACES
                        listen on multiple addresses: "ip1:port1:key1:cert1:ca
                        _cert1;ip2:port2:key2:cert2:ca_cert2;..."
                        (:key:cert:ca_cert optional; no spaces; IPv6 addresses
                        must be in square [] brackets)
  --run_system_tests    runs web2py tests</code></pre><blockquote>Uwaga: Opcja <code>-W</code>, używana do instalacji usługi Windows, została usunięta.
Proszę zobaczyć <a href="../13/#markmin_nssm">nssm w rozdziale Deployment Recipes</a></blockquote><p>Opcje pisane małymi literami są używane do konfiguracji serwera internetowego. Opcja <code>-L</code> informuje web2py aby czytał opcje konfiguracyjne z pliku, <code>-W</code> instaluje web2py jako usługę Windows, podczas gdy opcje <code>-S</code>, <code>-P</code> i <code>-M</code> uruchamiają interaktywną powłokę Pythona. Opcja <code>-T</code> wyszukuje i uruchamia kontroler doctests w środowisku wykonawczym web2py. Poniższy przykład uruchamia doctests ze wszystkich kontrolerów w aplikacji "welcome":</p><pre><code class="code">python web2py.py -vT welcome</code></pre><p>jeśli uruchomi się web2py jako usługę Windows przez opcję <code>-W</code>, to nie jest wygodne przekazywanie konfiguracji przy użyciu argumentów linii poleceń. Z tego powodu w folderze web2py znajduje się prosty plik konfiguracyjny "options_std.py" dla wewnętrznego serwera internetowego:</p><pre><code class="code">import socket
import os

ip = '0.0.0.0'
port = 80
interfaces = [('0.0.0.0', 80)]
               #,('0.0.0.0',443,'ssl_private_key.pem','ssl_certificate.pem')]
password = '&lt;recycle&gt;'  # ## &lt;recycle&gt; means use the previous password
pid_filename = 'httpserver.pid'
log_filename = 'httpserver.log'
profiler_filename = None
ssl_certificate = None  # 'ssl_certificate.pem'  # ## path to certificate file
ssl_private_key = None  # 'ssl_private_key.pem'  # ## path to private key file
#numthreads = 50 # ## deprecated; remove
minthreads = None
maxthreads = None
server_name = socket.gethostname()
request_queue_size = 5
timeout = 30
shutdown_timeout = 5
folder = os.getcwd()
extcron = None
nocron = None</code></pre><p>Plik ten zawiera wartości domyślne web2py. Jeśli edytuje się ten plik, to musi się go importować jawnie z użyciem opcji <code>-L</code> linii poleceń. Działa to tylko gdy uruchomi się web2py jako usługę Windows.</p><h3>Proces przetwarzania</h3><p>Proces przetwarzania danych w web2py jest następujący:</p><ul><li>Żądanie HTTP dociera do serwera internetowego (wbudowanego serwera Rocket lub innego serwera połączonego z web2py poprzez WSGI lub inny adapter). Serwer internetowy obsługuje każde żądanie w oddzielnym wątku, równolegle.</li><li>Nagłówek żądania HTTP jest parsowany i przekazywany do dyspozytora (<em>ang. dispatcher</em>) (wyjaśnionego dalej w tym rozdziale).</li><li>Dyspozytor decyduje, która z zainstalowanych aplikacji będzie obsługiwać żądanie i odwzorowuje PATH_INFO z adresu URL na wywołanie funkcji. Każdy adres URL odpowiada jednemu wywołaniu funkcji.</li><li>Żądania dla plików w folderze statycznym są obsługiwane bezpośrednio a większe pliki są automatycznie strumieniowane do klienta.</li><li>Żądania pozostałe (nie dotyczące plików statycznych) są odwzorowywane do akcje (tj. funkcji w pliku kontrolera z żądanej aplikacji).</li><li>Przed wywołaniem akcji dzieje się kilka rzeczy: jeśli żądanie zawiera nagłówek ciasteczka dla aplikacji, pobierany jest obiekt sesji; jeśli nie, tworzony jest id sesji (ale plik sesji jest zapisywany później); tworzone jest środowisko dla żądania; w tym środowisku wykonywane są modele.</li><li>Na koniec, we wstępnie zbudowanym środowisku wykonywana jest akcja kontrolera.</li><li>Jeśli akcja zwraca ciąg znakowy, to jest on zwracany klientowi (lub jeśli akcja zwraca obiekt helpera HTML web2py, to jest on serializowany i zwracany klientowi).</li><li>Jeśli akcja zwraca element iterowalny, to zostaje na nim zastosowana pętla i strumień danych przesyłany klientowi.</li><li>Jeśli akcja zwraca słownik, web2py próbuje zlokalizować widok do renderowana słownika. Widok musi mieć tą sama nazwę co akcja (chyba, że określono to inaczej) i to samo rozszerzenie, co żądana strona (domyślnie .html); w przypadku błędu web2py może zastosować widok ogólny (jeśli jest dostępny i włączony). Widok widzi każdą zmienną zdefiniowana w modelach, jak również te zmienne w słowniku zwracane przez akcje, ale nie ma tu zmiennych globalnych zdefiniowanych w kontrolerze.</li><li>Cały kod wykonywany jest w pojedynczej transakcji bazy danych, chyba że określono to inaczej.</li><li>Jeśli kod użytkownika powiedzie się, transakcja jest zatwierdzana.</li><li>Jeśli kod użytkownika nie powiedzie się, w bilecie zostaje jest zapisany komunikat z ostatniego wywołania (<em>ang. traceback</em>) i uzytkownikowi zostaje wysłany identyfikator biletu. Tylko administrator systemu może wyszukiwać i odczytywać w bilecie komunikat z ostatniego wywołania.</li></ul><p>Istnieje kilka uwag, o których warto pamiętać:</p><ul><li>Modele w tym samym folderze (podfolderze) są wykonywane w alfabetycznej kolejności.</li><li>Każda zmienna zdefiniowana w modelu będzie widoczna dla innych modeli w kolejności alfabetycznej, dla kontrolerów i widoków.</li></ul><div class="inxx">models_to_run</div><ul><li>Modele w podfolderach są wykonywane warunkowo . Na przykład, jeśli użytkownik wysyła żądanie "/a/c/f", gdzie "a" to aplikacja, "c" to kontroler a "f" to funkcja</li></ul><p>(akcja), to następnie wykonywane są następujące modele:</p><pre><code>applications/a/models/*.py
applications/a/models/c/*.py
applications/a/models/c/f/*.py</code></pre><p>Zachowanie takie jest wymuszane domyślnie. Zmieniając listę wyrażeń regularnych <code>response.models_to_run</code> można wymusić takie zachowanie, jakie się chce (zobacz do <a href="#markmin_response_models_to_run">response</a> w celu poznania szczegółów)</p><ul><li>Wykonywany jest żądany kontroler i wywoływana jest potrzebna funkcja. Oznacza to, że dla każdego żądania  dla określonego kontrolera wykonywany jest również cały kod na najwyższym poziomie w tym kontrolerze.</li><li>Widok jest wywoływany tylko wtedy, gdy akcja zwraca słownik.</li><li>Jeżeli widok nie zostanie znaleziony, web2py spróbuje użyć widoku ogólnego. Domyślnie, widok ogólne są wyłączone, lecz aplikacja 'welcome' zawiera linię w /models/db.py do ich włączenie, ale tylko na localhost. Mogą one być włączone dla każdego typu i każdej akcji (za pomocą <code>response.generic_patterns</code>). Ogólnie, ogólne widoki są narzędziem programistycznym i zazwyczaj nie powinny być wykorzystywane w środowisku produkcyjnym. Jeśli chce się aby jakieś akcje wykorzystywały widok ogólny, trzeba umieścić je na liście <code>response.generic_patterns</code> (omówionej w rozdziale Usługi).</li></ul><p>Możliwe zachowania akcji są następujące:</p><p><strong>Zwracanie ciąga znakowego</strong></p><pre><code>def index(): return 'data'</code></pre><p><strong>Zwracanie słownika dla widoku</strong>:</p><pre><code>def index(): return dict(key='value')</code></pre><p><strong>Zwracanie wszystkich lokalnych zmiennych</strong>:</p><pre><code>def index(): return locals()</code></pre><p><strong>Przekierowanie użytkowników do innej strony</strong>:</p><pre><code>def index(): redirect(URL('other_action'))</code></pre><p><strong>Zwracanie strony HTTP innej niż "200 OK"</strong>:</p><pre><code>def index(): raise HTTP(404)</code></pre><p><strong>Zwracanie helpera</strong> (na przykład FORM):</p><pre><code>def index(): return FORM(INPUT(_name='test'))</code></pre><p>(jest to najczęściej stosowane dla wywołań zwrotnych Ajax i komentarzy, patrz rozdział 12)</p><p>Gdy akcja zwraca słownik, to może zawierać kod generowany przez helpery, w tym formularze oparte na tabelach bazy danych lub formularze z fabryki, na przykład:</p><pre><code>def index(): return dict(form=SQLFORM.factory(Field('name')).process())</code></pre><p>(Wszystkie formularze generowane przez web2py wykorzystują zgłoszenia zwrotne (<em>ang. postback</em>), patrz rozdział 3)</p><h3>Rozdzielanie</h3><p><div class="inxx">mapowanie url</div> <div class="inxx">odwzorowywanie url</div> <div class="inxx">rozdzielanie</div></p><p>Platforma web2py odwzorowuje adres URL formularza o postaci:</p><pre><code class="code">http://127.0.0.1:8000/a/c/f.html</code></pre><p>do funkcji <code>f()</code> w kontrolerze "c.py" w aplikacji"a". Jeśli <code>f</code> nie jest podana, web2py stosuje domyślnie funkcję <code>index</code> kontrolera. Jeśli <code>c</code> nie jest podany, web2py stosuje domyślnie kontroler "default.py" a przy braku <code>a</code>, web2py wykorzystuje domyślnie aplikację <code>init</code>. Jeśli nie ma aplikacji <code>init</code>, web2py próbuje uruchomić aplikację <code>welcome</code>. Jest to pokazane na poniższym obrazie:</p><p><p style="text-align:center"><img src="http://127.0.0.1:8000/book/default/image/42/pl5700.png" alt="image" style="width:480px" /></p></p><p>Domyślnie, każde nowe żądanie tworzy nową sesję. Ponadto, ciasteczko sesji jest zwracane do przeglądarki klienta w celu śledzenia sesji.</p><p>Rozszerzenie <code>.html</code> jest opcjonalne i jest rozszerzeniem domyślnym. Rozszerzenie determinuje rozszerzenie widoku, który renderuje wyjście funkcji kontrolera <code>f()</code>. Pozwala aby ta sama zawartość była serwowana w wielu formatach (html, xml, json, rss itd.).</p><blockquote>Funkcje posiadające argumenty lub rozpoczynające się dwoma znakami podkreślenia
nie są publicznie widoczne i mogą tylko być wywoływane przez inne funkcje.</blockquote><div class="inxx">pliki statyczne</div><p>Istnieje wyjątek zrobiony dla adresów URL formularzy o postaci:</p><pre><code class="code">http://127.0.0.1:8000/a/static/filename</code></pre><p>Nie ma kontrolera o nazwie "static". web2py interpretuje to jako żądanie dla pliku o nazwie "filename" w podfolderze "static" aplikacji "a".</p><p><div class="inxx">PARTIAL CONTENT</div> <div class="inxx">IF_MODIFIED_SINCE</div> Po pobraniu plików statycznych, web2py nie tworzy sesji, ani nie wystawia ciasteczka lub wykonuje modele. web2py zawsze strumieniuje pliki statyczne kawałkami o rozmiarze 1MB i wysyła PARTIAL CONTENT, gdy klient wysyła żądanie RANGE dla podzbioru pliku.</p><p>Platforma web2py również obsługuje protokół IF_MODIFIED_SINCE i nie wysyła pliku, jeśli jest on już przechowywany w pamięci podręcznej przeglądarki i jeśli plik ten nie został zmieniony od czasu przesłania go do przeglądarki.</p><p>Podczas linkowania do plików audio lub wideo w folderze statycznym, jeśli chce się wymusić na przeglądarce aby pobierała pliki audio lub wideo, a nie je strumieniowała w odtwarzaczu medialnym, trzeba dodać <code>?attachment</code> do adresu URL. To poinformuje web2py aby ustawił nagłówek <code>Content-Disposition</code> odpowiedzi HTTP na "attachment". Na przykład:</p><pre><code class="code">&lt;a href="/app/static/my_audio_file.mp3?attachment"&gt;Download&lt;/a&gt;</code></pre><p>Po kliknięciu powyższego odnośnika, przeglądarka poprosi użytkownika aby pobrał plik MP3 zamiast go strumieniować w odtwarzaczu audio. Tak jak opisano <a href="#markmin_response">poniżej</a>, można również bezpośrednio ustawiać nagłówki odpowiedzi HTTP przypisując <code>dict</code> nazw nagłówków i ich wartości do <code>response.headers</code>.</p><p><div class="inxx">request.application</div> <div class="inxx">request.controller</div> <div class="inxx">request.function</div> <div class="inxx">GET</div> <div class="inxx">POST</div> <div class="inxx">request.args</div> web2py odwzorowuje żądania GET i POST formularza:</p><pre><code class="code">http://127.0.0.1:8000/a/c/f.html/x/y/z?p=1&amp;q=2</code></pre><p>do funkcji <code>f</code> w kontrolerze "c.py" w aplikacji <code>a</code> i przechowuje parametry adresu URL w zmiennej <code>request</code> jak niżej:</p><pre><code class="code">request.args = ['x', 'y', 'z']</code></pre><p>i:</p><pre><code class="code">request.vars = {'p':1, 'q':2}</code></pre><p>i:</p><pre><code class="code">request.application = 'a'
request.controller = 'c'
request.function = 'f'</code></pre><p>W powyższym przykładzie zarówno <code>request.args[i]</code> jak i <code>request.args(i)</code> mogą być używane do pobrania i-tego elementu <code>request.args</code>, ale gdy pierwszy zgłasza wyjątek jeśli na liście nie występuje index, to drugi zwraca w takim przypadku None.</p><div class="inxx">request.url</div><pre><code class="code">request.url</code></pre><p>przechowuje pełny adres URL bieżącego żądania (nie dołączając zmiennych GET).</p><p><div class="inxx">request.ajax</div> <div class="inxx">request.cid</div></p><pre><code class="code">request.ajax</code></pre><p>domyślnie wartość False, ale True jeśli web2py stwierdzi, że akcja została wywołana przez żądanie Ajax.</p><p>Jeśli żądanie jest żądaniem Ajax i jeśli zostało zainicjowane przez komponent web2py, nazwę komponentu można znaleźć w:</p><pre><code class="code">request.cid</code></pre><p>Komponenty omówione są bardziej szczegółowo w rozdziale 12.</p><p><div class="inxx">request.get_vars</div> <div class="inxx">request.post_vars</div> <div class="inxx">request.vars</div> Jeśli żądanie HTTP jest typu GET, to <code>request.env.request_method</code> zostaje ustawiona na "GET", jeśli natomiast typu POST, to na "POST". Parametry zapytania z adresu URL są przechowywane w zmiennej <code>request.get_vars</code>. Zmienna <code>request.post_vars</code> zawiera wszystkie parametry przekazane do ciała żądania (zazwyczaj POST, PUT lub DELETE). Słownik <code>request.vars</code> zawiera je oba (<code>get_vars</code> i <code>post_vars</code>)</p><p>Platforma web2py przechowuje zmienne środowiskowe WSGI i web2py w zmiennej <code>request.env</code>, na przykład:</p><pre><code class="code">request.env.path_info = 'a/c/f'</code></pre><p>a nagłówki HTTP w zmiennych środowiskowych, na przykład:</p><pre><code class="code">request.env.http_host = '127.0.0.1:8000'</code></pre><blockquote>Proszę zwrócić uwagę, że web2py sprawdza wszystkie adresy URL, aby zapobiegać
atakom z przeglądaniem katalogów.</blockquote><p>Adresy URL mogą zawierać tylko znaki alfanumeryczne, znaki podkreślenia i ukośniki. Parametr <code>args</code> nie może zawierać występujących po sobie kropek. Spacje są zamieniane na znaki podkreślenia przed walidacją. Jeśli składnia adresu URL jest nieprawidłowa, web2py zwraca komunikat błędu 400 HTTP<sup>[<a href="/book/default/reference/42/http-w" target="_blank">http-w</a>]</sup> <sup>[<a href="/book/default/reference/42/http-o" target="_blank">http-o</a>]</sup> .</p><p>Jeśli adres URL zgodny jest z żądaniem dla plików statycznych, web2py po prostu czyta  i zwraca (strumieniuje) żądany plik.</p><p>Jeśli adres URL nie żąda pliku statycznego, web2py przetwarza żądanie w następującej kolejności:</p><ul><li>Analizuje ciasteczka.</li><li>Tworzy środowisko.</li><li>Inicjuje obiekty  <code>request</code>, <code>response</code>, <code>cache</code>.</li><li>Otwiera isteniejący obiekt  <code>session</code> lub tworzy nowy.</li><li>Wykonuje modele należące do żądanej aplikacji.</li><li>Wykonuje żądaną funkcję akcji kontrolera.</li><li>Jeśli funkcja zwraca słownik, wykonuje związany widok.</li><li>W razie sukcesu zatwierdza wszystkie otwarte transakcje.</li><li>Zapisuje sesję.</li><li>Zwraca odpowiedź HTTP.</li></ul><p>Proszę zauważyć, że kontroler i widok są wykonywane w różnych kopiach tego samego środowiska, dlatego widok nie widzi kontrolera, ale widzi modele i zmienne zwracane przez funkcje akcji kontrolera.</p><p>Jeśli zostaje wywołany wyjątek (inny niż HTTP), web2py wykonuje następujące rzeczy:</p><ul><li>Zapisuje komunikat z ostatniego wywołania (traceback) w pliku błędu i przypisuje mu numer biletu.</li><li>Wycofuje wszystkie otwarte transakcje bazy danych.</li><li>Zwraca stronę błędu raportującą numer biletu.</li></ul><p>Jeśli wyjątek jest wyjątkiem <code>HTTP</code>, to zakłada się, że zamierzone zachowanie (na przykład, przekierowanie <code>HTTP</code>) i wszystkie otwarte transakcje bazy danych zostały zatwierdzone. Zachowanie późniejsze jest określone przez sam wyjątek <code>HTTP</code>. Klasa wyjątku <code>HTTP</code> nie jest standardowym wyjątkiem Pythona – jest zdefiniowana przez web2py.</p><h3>Biblioteki</h3><p>Biblioteki web2py są dostępne dla aplikacji użytkownika jako obiekty globalne. Na przykład obiekty <code>request</code>, <code>response</code>, <code>session</code>, <code>cache</code>, klasy helperów, walidatorów, API DAL oraz  funkcje <code>T</code> i <code>redirect</code>.</p><p>Obiekty te sa zdefiniowane w nastęþujacych plikach rdzenia:</p><pre><code class="code">web2py.py
gluon/__init__.py    gluon/highlight.py   gluon/restricted.py  gluon/streamer.py
gluon/admin.py       gluon/html.py        gluon/rewrite.py     gluon/template.py
gluon/cache.py       gluon/http.py        gluon/rocket.py      gluon/storage.py
gluon/cfs.py         gluon/import_all.py  gluon/sanitizer.py   gluon/tools.py
gluon/compileapp.py  gluon/languages.py   gluon/serializers.py gluon/utils.py
gluon/contenttype.py gluon/main.py        gluon/settings.py    gluon/validators.py
gluon/dal.py         gluon/myregex.py     gluon/shell.py       gluon/widget.py
gluon/decoder.py     gluon/newcron.py     gluon/sql.py         gluon/winservice.py
gluon/fileutils.py   gluon/portalocker.py gluon/sqlhtml.py     gluon/xmlrpc.py
gluon/globals.py     gluon/reserved_sql_keywords.py</code></pre><blockquote>Proszę zauważyć, że wiele z tych modułów, w szczególności <code>dal</code> (warstwa abstrakcji
bazy danych), <code>template</code> (język szablonowania), <code>rocket</code> (serwer internetowy)
i <code>html</code> (helpery) nie mają zależności i mogą być używane poza web2py.</blockquote><p>Skompresowane przez gzip archiwum tar aplikacji dostarczane wraz z web2py to</p><pre><code class="code">welcome.w2p</code></pre><p>Aplikacja ta jest tworzona podczas instalacji i nadpisywana podczas aktualizacji.</p><blockquote>Podczas pierwszego uruchomienia web2py tworzy dwa nowe foldery: deposit i applications.
Folder deposit jest używany jako tymczasowy magazyn dla instalowania i odinstalowywania
aplikacji.

Podczas pierwszego uruchomienia web2py i po aktualizacji, aplikacja "welcome" jest
pakowana do pliku "welcome.w2p" aby mogła być używana jako aplikacja szkieletowa.</blockquote><p>Kiedy web2py zostaje uaktualniany, to dostarczany jest wraz z plikiem o nazwie "NEWINSTALL". Jeśli web2py odnajdzie ten plik, to rozumie, że uaktualnienie zostało zrealizowane, dlatego usuwa plik "welcome.w2p" i tworzy w jego miejsce nowy, o tej samej nazwie.</p><p>Aktualna wersja web2py jest zapisywana w polu "VERSION" i spełnia standardową notację wersjonowania, wg której identyfikator budowania jest znacznikiem czasowym budowania.</p><p>Jednostkowe testy web2py znajduja się w</p><pre><code class="code">gluon/tests/</code></pre><p>Istnieją handlery  do połączeń z różnymi serwerami internetowymi:</p><pre><code class="code">cgihandler.py       # nie zalecany
gaehandler.py       # dla Google App Engine
fcgihandler.py      # dla FastCGI
wsgihandler.py      # dla WSGI
isapiwsgihandler.py # dla IIS
modpythonhandler.py # przestarzały</code></pre><p>("fcgihandler" wywołuje "gluon/contrib/gateways/fcgi.py" stworzony przez Allana Saddi) i</p><pre><code>anyserver.py</code></pre><p>który jest skryptem do współdziałania z wieloma serwerami internetowymi, co opisane zostało w rozdziale 13.</p><p>W katalogu "examples" znajdują się trzy przykładowe pliki:</p><pre><code class="code">options_std.py
routes.parametric.example.py
routes.patterns.example.py</code></pre><p>Wszystkie te pliki trzeba skopiować do głównego katalogu (tam gdzie jest plik web2py.py lub web2py.exe) i można je edytować, zgodnie ze swoimi potrzebami. Pierwszy jest opcjonalnym plikiem konfiguracyjnym, który może być przekazany do web2py.py przy pomocy opcji <code>-L</code>. Drugi jest przykładem pliku mapującego adres URL. Będzie ładowany automatycznie, jeśli zmieni się jego nazwę na "routes.py". Trzeci jest alternatywna składnią dla mapowania adresów URL i może być też przemianowany na "routes.py" (lub skopiowany do tego pliku).</p><p>Pliki</p><pre><code class="code">app.example.yaml
queue.example.yaml</code></pre><p>są przykładowymi plikami konfiguracyjnymi używanymi do wdrożeń na Google App Engine. Można przeczytać więcej na ten temat w rozdziale "Receptury wdrożeniowe" i na stronach dokumentacji Google.</p><p>Istnieją również dodatkowe biblioteki, niektóre opracowane przez osoby trzecie:</p><p><strong>feedparser</strong><sup>[<a href="/book/default/reference/42/feedparser" target="_blank">feedparser</a>]</sup>  opracowana przez by Marka Pilgrima dla odczytu kanałów RSS i Atom:</p><pre><code class="code">gluon/contrib/__init__.py
gluon/contrib/feedparser.py</code></pre><p><strong>markdown2</strong><sup>[<a href="/book/default/reference/42/markdown2" target="_blank">markdown2</a>]</sup>  opracowana przez Trenta Micka dla znaczników wiki:</p><pre><code class="code">gluon/contrib/markdown/__init__.py
gluon/contrib/markdown/markdown2.py</code></pre><p><strong>markmin</strong> język znaczników:</p><pre><code class="code">gluon/contrib/markmin</code></pre><p>(patrz <a href="../05/#markmin_markmin_syntax">składnia MARKMIN</a> w celu uzyskania wiecej informacji)</p><p><strong>fpdf</strong> stworzona przez Mariano Reingart dla generowania dokumentów PDF:</p><pre><code>gluon/contrib/fpdf</code></pre><p>Nie są one udokumentowane w tej książce, ale są hostowane i udokumentowane tutaj:</p><pre><code>http://code.google.com/p/pyfpdf/</code></pre><p><strong>pysimplesoap</strong> jest implementacją lekkiego serwerem SOAP stworzona przez  Mariano Reingarta:</p><pre><code class="code">gluon/contrib/pysimplesoap/</code></pre><p><strong>simplejsonrpc</strong> jest lekkim klientem JSON-RPC stworzonym przez Mariano Reingarta: <div class="inxx">jsonrpc</div></p><pre><code>gluon/contrib/simplejsonrpc.py</code></pre><p><strong>memcache</strong><sup>[<a href="/book/default/reference/42/memcache" target="_blank">memcache</a>]</sup>  API Pythona stworzone przez Evana Martina:</p><pre><code>gluon/contrib/memcache/__init__.py
gluon/contrib/memcache/memcache.py</code></pre><p><strong>redis_cache</strong> <div class="inxx">redis</div> jest modułem pamięci podręcznej dla bazy danych redis:</p><pre><code>gluon/contrib/redis_cache.py</code></pre><p><strong>gql</strong>, port DAL dla Google App Engine:</p><pre><code class="code">gluon/contrib/gql.py</code></pre><p><strong>memdb</strong>, port DAL górnej części memcache:</p><pre><code class="code">gluon/contrib/memdb.py</code></pre><p><strong>gae_memcache</strong> to API wykorzystujące memcache dla Google App Engine:</p><pre><code class="code">gluon/contrib/gae_memcache.py</code></pre><p><strong>pyrtf</strong><sup>[<a href="/book/default/reference/42/pyrtf" target="_blank">pyrtf</a>]</sup>  do generowania dokumentów Rich Text Format (RTF), opracowana przez Simona Cusacka i  poprawiona przez Granta Edwardsa:</p><pre><code class="code">gluon/contrib/pyrtf/</code></pre><p><strong>PyRSS2Gen</strong><sup>[<a href="/book/default/reference/42/pyrss2gen" target="_blank">pyrss2gen</a>]</sup>  opracowana przez Dalke Scientific Software do generowania kanałów RSS:</p><pre><code class="code">gluon/contrib/rss2.py</code></pre><p><strong>simplejson</strong><sup>[<a href="/book/default/reference/42/simplejson" target="_blank">simplejson</a>]</sup>  standardowa biblioteka do paesowania i pisania obiektów JSON opracowana przez Boba Ippolito:</p><pre><code class="code">gluon/contrib/simplejson/</code></pre><p><strong>Google Wallet</strong> <sup>[<a href="/book/default/reference/42/googlewallet" target="_blank">googlewallet</a>]</sup> dostarcza przyciski "pay now" linkujący Google jako procesor płatności:</p><pre><code class="code">gluon/contrib/google_wallet.py</code></pre><p><strong>Stripe.com</strong> <sup>[<a href="/book/default/reference/42/stripe" target="_blank">stripe</a>]</sup> dostarcza proste API do przyjmowania płatności kartami kredytowymi::</p><pre><code class="code">gluon/contrib/stripe.py</code></pre><p><strong>AuthorizeNet</strong> <sup>[<a href="/book/default/reference/42/authorizenet" target="_blank">authorizenet</a>]</sup> dostarcza API do przyjmowania płatności kartami kredytowymi poprzez sieć Authorize.net</p><pre><code class="code">gluon/contrib/AuthorizeNet.py</code></pre><p><strong>Dowcommerce</strong> <sup>[<a href="/book/default/reference/42/dowcommerce" target="_blank">dowcommerce</a>]</sup> API przetwarzania kart kredytowych:</p><pre><code class="code">gluon/contrib/DowCommerce.py</code></pre><p><strong>PaymentTech</strong> API przetwarzania kart kredytowych::</p><pre><code class="code">gluon/contrib/paymentech.py</code></pre><p><strong>PAM</strong><sup>[<a href="/book/default/reference/42/PAM" target="_blank">PAM</a>]</sup>  API uwierzytelniania stworzone przez Chrisa AtLee:</p><pre><code class="code">gluon/contrib/pam.py</code></pre><p>Klasyfikator Bayesian do wypełniania bazy danych danymi fikcyjnymi w celach testowych:</p><pre><code class="code">gluon/contrib/populate.py</code></pre><p>Plik z API do uruchamiania na Heroku.com : <div class="inxx">heroku</div></p><pre><code class="code">gluon/contrib/heroku.py</code></pre><p>Plik umożliwiający interakcje z paskiem zadań w Windows, gdy web2py jest uruchomiony jako usługa:</p><pre><code class="code">gluon/contrib/taskbar_widget.py</code></pre><p>Opcjonalne <strong>login_methods</strong> i login_forms używane do uwierzytelniania:</p><pre><code class="code">gluon/contrib/login_methods/__init__.py
gluon/contrib/login_methods/basic_auth.py
gluon/contrib/login_methods/browserid_account.py
gluon/contrib/login_methods/cas_auth.py
gluon/contrib/login_methods/dropbox_account.py
gluon/contrib/login_methods/email_auth.py
gluon/contrib/login_methods/extended_login_form.py
gluon/contrib/login_methods/gae_google_account.py
gluon/contrib/login_methods/ldap_auth.py
gluon/contrib/login_methods/linkedin_account.py
gluon/contrib/login_methods/loginza.py
gluon/contrib/login_methods/oauth10a_account.py
gluon/contrib/login_methods/oauth20_account.py
gluon/contrib/login_methods/oneall_account.py
gluon/contrib/login_methods/openid_auth.py
gluon/contrib/login_methods/pam_auth.py
gluon/contrib/login_methods/rpx_account.py
gluon/contrib/login_methods/x509_auth.py</code></pre><p>Paltforma web2py zawiera również folder z przydatnymi skryptami, w tym</p><pre><code class="code">scripts/setup-web2py-fedora.sh
scripts/setup-web2py-ubuntu.sh
scripts/setup-web2py-nginx-uwsgi-ubuntu.sh
scripts/setup-web2py-heroku.sh
scripts/update-web2py.sh
scripts/make_min_web2py.py
...
scripts/sessions2trash.py
scripts/sync_languages.py
scripts/tickets2db.py
scripts/tickets2email.py
...
scripts/extract_mysql_models.py
scripts/extract_pgsql_models.py
...
scripts/access.wsgi
scripts/cpdb.py</code></pre><p>Skrypty <code>setup-web2py-*</code> są szczególnie przydatne, ponieważ próbują realizować od podstaw pełną instalację i konfigurację środowiska produkcyjnego web2py. Niektóre z nich zostały omówione w rozdziale 14, ale wszystkie z nich zawierają wewnątrz opis dokumentacyjny, który wyjaśnia ich przeznaczenie i używanie.</p><p>Wreszcie web2py zawiera pliki wymagane do budowy dystrybucji binarnej.</p><pre><code class="code">Makefile
setup_exe.py
setup_app.py</code></pre><p>Są to skrypty konfiguracyjne odpowiednio dla <strong>py2exe</strong> i <strong>py2app</strong> i są tylko wymagane przy budowaniu dystrybucji binarnej web2py. NIGDY NIE ZAJDZIE POTRZEBA ICH URUCHOMIENIA.</p><p>Aplikacje web2py zawierają dodatkowe pliki, zwłaszcza biblioteki JavaScript osób trzecich, takie jak jQuery, calendar i Codemirror. Ich autorzy są wymienieniu w plikach tych bibliotek.</p><h3>Aplikacje</h3><p>Aplikacje stworzone w web2py są złożone z następujących części (znajdujących sie w swoich katalogach):</p><ul><li><strong>models</strong> (modele) opisuje reprezentację danych w tabelach bazy danych i relacje pomiędzy tabelami;</li><li><strong>controllers</strong> (kontrolery) opisuje logikę aplikację i proces przetwarzania;</li><li><strong>views</strong> (widoki) opisuje jak dane powinny być prezentowane użytkownikowi przy użyciu HTML i JavaScript;</li><li><strong>languages</strong> (języki) opisują jak przetłumaczyć ciągy tekstowe w aplikacji na różne obsługiwane języki;</li><li><strong>static files</strong> (pliki statyczne) nie wymagają przetwarzania (np. obrazy, arkusze stylów CSS itd.);</li><li><strong>ABOUT</strong> i <strong>README</strong> - te pliki są oczywiste;</li><li><strong>errors</strong> (błędy) przechowuje sie tu raporty o błędach wygenerowane przez aplikację;</li><li><strong>sessions</strong> (sesje) przechowuje się tu informacje odnoszące się do każdego określonego użytkownika;</li><li><strong>databases</strong> (bazy danych) przechowuje się tu bazy danych SQLite i dodatkowe tabelaryczne informacje;</li><li><strong>cache</strong> (pamięc podręczna) przechowuje się tu buforowane elementy aplikacje;</li><li><strong>modules</strong> (moduły) są tu opcjonalne moduły Pythona;</li><li><strong>private</strong> (prywatne) pliki, które są dostępne dla kontrolerów ale nie bezpośrednio dla programisty;</li><li><strong>uploads</strong> (przesłane) pliki są dostępne dla modeli ale nie bezpośrednio dla programisty (np. pliki przesłane na serwer przez użytkowników aplikacji).</li><li><strong>tests</strong> (testy) jest katalogiem do przechowywania skrytów testów, wyposażenia i makiet.</li></ul><p>Modele, widoki, kontrolery, języki i pliki statyczne są dostępne poprzez interfejs administracyjny [design]. Pliki ABOUT i README oraz katalog errors są również dostępne przez interfejs administracyjny za pośrednictwem odpowiednich elementów menu. Pliki sesji, pamięci podręcznej, modułów i pliki prywatne są dostępne przez aplikacje, ale nie za pomocą interfejsu administracyjnego.</p><p>Wszystko jest uporządkowane w jasne struktury katalogów, które są replikowane dla każdej zainstalowanej aplikacji web2py, choć użytkownik nie potrzebuje bezpośredniego dostępu do systemu plików:</p><p><div class="inxx">o aplikacji</div> <div class="inxx">licecja</div> <div class="inxx">pamięć podręczna</div> <div class="inxx">kontrolery</div> <div class="inxx">bazy danych</div> <div class="inxx">błedy</div> <div class="inxx">języki</div> <div class="inxx">modele</div> <div class="inxx">moduły</div> <div class="inxx">prywatne pliki</div> <div class="inxx">sesje</div> <div class="inxx">pliki statyczne</div> <div class="inxx">testy</div> <div class="inxx">pliki przesłane</div> <div class="inxx">widoki</div> <div class="inxx">__init__.py</div></p><pre><code class="code">__init__.py  ABOUT        LICENSE    models    views
controllers  modules      private    tests     cron
cache        errors       upload     sessions  static</code></pre><p>Plik "__init__.py" to pusty plik wymagany w celu umożliwienia Pythonowi (i web2py) importowanie modułów w katalogu <code>modules</code>.</p><p>Proszę zwrócić uwagę, że aplikacja <strong>admin</strong> po prostu dostarcza interfejs internetowy dla aplikacji web2py w systemie plików serwera. Aplikacje web2py mogą być również tworzone i programowane z poziomu linii poleceń lub poprzez wybrany edytor tekstowy (np. w IDE) – nie jest konieczne korzystanie z interfejsu <strong>admin</strong> w przeglądarce. Nową aplikację można utworzyć ręcznie przez replikowanie powyższej struktury katalogów, np. "applications/newapp/" (lub po prostu rozpakowanie pliku <code>welcome.w2p</code> do katalogu nowej aplikacji). Pliki aplikacji mogą być również stworzone i edytowane z poziomu linii poleceń bez konieczności korzystania z interfejsu <strong>admin</strong>.</p><h3>API</h3><p>Modele, kontrolery i widoki są wykonywane w środowisku, w którym następujące obiekty są już za nas zaimportowane:</p><p><strong>Obiekty globalne:</strong> <div class="inxx">request</div> <div class="inxx">response</div> <div class="inxx">session</div> <div class="inxx">cache</div></p><pre><code class="code">request, response, session, cache</code></pre><p><strong>Umiędzynarodowienie :</strong> <div class="inxx">T</div> <div class="inxx">umiędzynarodowienie</div></p><pre><code class="code">T</code></pre><p><strong>Nawigacja:</strong> <div class="inxx">redirect</div> <div class="inxx">HTTP</div></p><pre><code class="code">redirect, HTTP</code></pre><p><strong>Helpery:</strong> <div class="inxx">helpery</div></p><pre><code class="code">XML, URL, BEAUTIFY

A, B, BODY, BR, CENTER, CODE, COL, COLGROUP,
DIV, EM, EMBED, FIELDSET, FORM, H1, H2, H3, H4, H5, H6,
HEAD, HR, HTML, I, IFRAME, IMG, INPUT, LABEL, LEGEND,
LI, LINK, OL, UL, META, OBJECT, OPTION, P, PRE,
SCRIPT, OPTGROUP, SELECT, SPAN, STYLE,
TABLE, TAG, TD, TEXTAREA, TH, THEAD, TBODY, TFOOT,
TITLE, TR, TT, URL, XHTML, xmlescape, embed64

CAT, MARKMIN, MENU, ON</code></pre><p><strong>Formularze i tabele</strong></p><pre><code>SQLFORM (SQLFORM.factory, SQLFORM.grid, SQLFORM.smartgrid)</code></pre><p><strong>Walidatory:</strong> <div class="inxx">walidatory</div></p><pre><code class="code">CLEANUP, CRYPT, IS_ALPHANUMERIC, IS_DATE_IN_RANGE, IS_DATE,
IS_DATETIME_IN_RANGE, IS_DATETIME, IS_DECIMAL_IN_RANGE,
IS_EMAIL, IS_EMPTY_OR, IS_EXPR, IS_FLOAT_IN_RANGE, IS_IMAGE,
IS_IN_DB, IS_IN_SET, IS_INT_IN_RANGE, IS_IPV4, IS_LENGTH,
IS_LIST_OF, IS_LOWER, IS_MATCH, IS_EQUAL_TO, IS_NOT_EMPTY,
IS_NOT_IN_DB, IS_NULL_OR, IS_SLUG, IS_STRONG, IS_TIME,
IS_UPLOAD_FILENAME, IS_UPPER, IS_URL</code></pre><p><strong>Baza danych:</strong> <div class="inxx">DAL</div></p><pre><code class="code">DAL, Field</code></pre><p>W celu zachowania wstecznej kompatybilności <code>SQLDB=DAL</code> i <code>SQLField=Field</code>. Zachęcamy do stosowania nowej składni <code>DAL</code> i <code>Field</code>, zamiast starej.</p><p>W bibliotekach są zdefiniowane inne obiekty i moduły, ale nie są one importowane automatycznie, ponieważ używane są rzadko.</p><p>Podstawowe encje API w środowisku wykonawczym web2py, to <code>request</code>, <code>response</code>, <code>session</code>, <code>cache</code>, <code>URL</code>, <code>HTTP</code>, <code>redirect</code> i <code>T</code>. Są one omówione niżej.</p><p>Kilka obiektów i funkcji, w tym <strong>Auth</strong>, <strong>Crud</strong> i <strong>Service</strong> są zdefiniowane w "gluon/tools.py" i jeśli są potrzebne, to muszą zostać zaimportowane:</p><pre><code class="code">from gluon.tools import Auth, Crud, Service</code></pre><p>Są one importowane w <code>db.py</code> w aplikacji szkieletowej.</p><h4>Dostęp do API z modułów Pythona</h4><p>Twoje modele lub kontrolery mogą importować moduły Pythona, które do działania wymagają zastosowania jakichś interfejsów API web2py API. Sposobem na to jest ich zaimportowanie:</p><pre><code>from gluon import *</code></pre><p>W rzeczywistości, każdy moduł Pythona, jeśli nawet nie został zaimportowany przez aplikację web2py, może importować API web2py, jeśli web2py jest w <code>sys.path</code>.</p><p>Choć jest jedno zastrzeżenie. Web2py definiuje niektóre obiekty globalne (request, response, session, cache, T), które mogą istnieć tylko wtedy, gdy obecne jest żądanie HTTP (lub zostało ono sfałszowane). Dlatego moduły mogą z nich korzystać tylko wtedy, gdy są wywoływane z aplikacji. Z tego powodu są one umieszczane w kontenerze wywołującym <code>current</code>, który jest obiektem lokalnego wątku. Oto przykład.</p><p>Utwórz moduł "/myapp/modules/test.py" zawierający:</p><pre><code>from gluon import *
def ip(): return current.request.client</code></pre><p>Teraz w kontrolerze "myapp" możesz napisać</p><pre><code>import test
def index():
    return "Twój ip to " + test.ip()</code></pre><p>Zwróć uwagę na kilka rzeczy:</p><ul><li>Wyrażenie <code>import test</code> wyszukuje moduł najpierw w folderze bieżącej aplikacji, następnie w folderach wykazanych w <code>sys.path</code>. Dlatego moduły poziomu aplikacji zawsze mają pierwszeństwo przed modułami Pythona. Umożliwia to, aby różne aplikacje korzystały bez konfliktu z różnych wersji swoich modułów.</li><li>Różni użytkownicy mogą wywoływać równocześnie tą sama akcję <code>index</code>, która wywołuje funkcję w module bez powodowania konfliktu, ponieważ obiekt <code>current.request</code> jest innym obiektem w każdym wątku. Wystarczy zachować ostrożność, aby nie przejść do <code>current.request</code> poza funkcjami lub klasami w module (czyli na najwyższym poziomie).</li><li>Wyrażenie <code>import test</code> jest skrótem wyrażenia <code>from applications.appname.modules import test</code>. Używając dłuższej składni można zaimportować moduły z innej aplikacji.</li></ul><p>W celu jednolitości z normalnym zachowaniem Pythona, web2py domyślnie nie przeładowuje modułów po wprowadzeniu zmian. Lecz można to zmienić. Aby włączyć możliwość automatycznego przeładowywania modułów, trzeba użyć funkcję <code>track_changes</code> w sposób następujący (zwykle w pliku modelu, przed jakimkolwiek wyrażeniem import):</p><pre><code class="code">from gluon.custom_import import track_changes; track_changes(True)</code></pre><p>Od teraz, za każdym razem, moduł jest importowany, importer sprawdza, czy plik źródłowy Pythona (.py) został zmieniony. Jeśli tak, to moduł zostanie przeładowany.</p><blockquote>Nie wywołuj track_changes w samych modułach.</blockquote><p>Śledzenie zmian obywa się tylko dla modułów, które są przechowywane w aplikacji. Moduły importujące <code>current</code> uzyskują dostęp do:</p><ul><li><code>current.request</code></li><li><code>current.response</code></li><li><code>current.session</code></li><li><code>current.cache</code></li><li><code>current.T</code></li></ul><p>oraz każdej innej zmiennej aplikacji wybranej do przechowywania w current. Na przykład. możnaby zrobić taki model</p><pre><code>auth = Auth(db)
from gluon import current
current.auth = auth</code></pre><p>co spowoduje, że teraz wszystkie moduły mogą mieć dostęp do <code>current.auth</code>.</p><p>Wyrażenia <code>current</code> i <code>import</code> tworzą pełnowartościowy mechanizm do budowania rozszerzalnych i mogących być wielokrotnie używanych modułów dla aplikacji.</p><blockquote>Uważaj! Biorąc <code>from gluon import current</code>, dobrze jest użyć <code>current.request</code>
i którykolwiek z innych obiektów lokalnego wątku, ale nigdy nie należy przypisywać
go do zmiennych globalnych w module, tak jak tu
<pre><code>request = current.request # ŹLE! NIEBEZPIECZNIE!</code></pre>
ani też nie należy przypisywać go do atrybutu klasy
<pre><code>class MyClass:
    request = current.request # ŹLE! NIEBEZPIECZNIE!</code></pre>
To dlatego, że obiekt lokalnego wątku musi być ekstrahowany w czasie wykonania.
Natomiast zmienne globalne są definiowane tylko raz, podczas importowania modelu
po raz pierwszy.</blockquote><p>Inne zastrzeżenie dotyczy operacji z pamięcią podręczną. Nie można używać obiektu <code>cache</code> do dekorowania funkcji w modułach, dlatego że nie zachowuje się on zgodnie z oczekiwaniami. Aby buforować funkcje <code>f</code> w module musi się użyć <code>lazy_cache</code>:</p><pre><code class="code">from gluon.cache import lazy_cache

@lazy_cache('key', time_expire=60, cache_model='ram')
def f(a,b,c,): ....</code></pre><p>Pamiętaj, że klucz jest określany przez użytkownika, ale musi on być jednoznacznie powiązany z funkcją. Jeśli zostanie pominięty, to web2py określi go automatycznie.</p><h3>Obiekt <code>request</code></h3><p><div class="inxx">request</div> <div class="inxx">Storage</div> <div class="inxx">request.cookies</div> <div class="inxx">user_agent</div></p><p>Obiekt <code>request</code> jest instancją wszechobecnej klasy web2py o nazwie <code>gluon.storage.Storage</code>, która rozszerza klasę <code>dict</code> Pythona. W zasadzie jest to słownik, ale wartości jego elementów mogą być również dostępne jako atrybuty:</p><pre><code class="code">request.vars</code></pre><p>jest tym samym, co:</p><pre><code class="code">request['vars']</code></pre><p>W przeciwieństwie do słownika, jeśli atrybut (lub klucz) nie istnieje, to nie jest zgłaszany wyjątek. Zamiast tego zwracane jest <code>None</code>.</p><blockquote>Czasem jest to przydatne do tworzenia własnych obiektów Storage. Można to zrobić
następująco:
<pre><code class="code">from gluon.storage import Storage
my_storage = Storage() # pusty obket storage
my_other_storage = Storage(dict(a=1, b=2)) # konwersja słownika do Storage</code></pre></blockquote><p>Obiekt <code>request</code> ma następujące elementy (atrybuty), z których niektóre również są dostępne w instancji klasy <code>Storage</code>:</p><ul><li><code>request.cookies</code>: obiekt <code>Cookie.SimpleCookie()</code> zawierający ciasteczka przekazywane przez żądania HTTP. Działa on jak słownik ciasteczek. Każde ciasteczko jest obiektem Morsel <sup>[<a href="/book/default/reference/42/morsel" target="_blank">morsel</a>]</sup>;</li><li><code>request.env</code>: obiekt <code>Storage</code> zawierający zmienne środowiskowe przekazywane do kontrolera, w tym zmienne nagłówka HTTP z żądania HTTP i standardowe parametry WSGI. Wszystkie zmienne środowiskowe są konwertowane na małe litery a kropki na znaki podkreślenia w celi łatwiejszego zapamiętania;</li><li><code>request.application</code>: nazwa żądanej aplikacji;</li><li><code>request.controller</code>: nazwa żądanego kontrolera;</li><li><code>request.function</code>: nazwa żądanej funkcji;</li><li><code>request.extension</code>: rozszerzenie żądanej akcji. Domyślną wartością jest "html". Jeśli kontroler zwraca słownik i nie określa widoku, to jest używany do określenia rozszerzenia pliku widoku, który będzie renderował słownik (parsowany w <code>request.env.path_info</code>);</li><li><code>request.folder</code>: słownik aplikacji. Na przykład, jeśli aplikacją jest "welcome", <code>request.folder</code> zostaje ustawione na ścieżkę bezwzględną "/path/to/welcome". W programie należy zawsze używać tej zmiennej oraz funkcji <code>os.path.join</code> do budowy ścieżek do plików, do których potrzeba uzyskać dostęp. Chociaż web2py zawsze używa ścieżek bezwzględnych, to dobrą praktyką jest niezmienianie nigdy jawnie bieżącego folderu roboczego (cokolwiek nim jest) ponieważ nie jest to bezpieczne dla wątku;</li><li><code>request.now</code>: obiekt <code>datetime.datetime</code> przechowujący datę i czas bieżącego żądania;</li><li><code>request.utcnow</code>: obiekt <code>datetime.datetime</code> przechowujący datę i czas UTC bieżącego żądania;</li><li><code>request.args</code>: lista parametrów ścieżki URL występujących po nazwie funkcji kontrolera; ekwiwalent <code>request.env.path_info.split('/')[3:]</code></li><li><code>request.vars</code>: obiekt <code>gluon.storage.Storage</code> zawierający wszystkie parametry żądania;</li><li><code>request.get_vars</code>: obiekt <code>gluon.storage.Storage</code> zawierający tylko parametry przekazane do ciąga zapytania (żądanie dla <code>/a/c/f?var1=1&amp;var2=2</code> będzie się kończyć ciągiem <code>{var1: "1", var2: "2"}</code>);</li><li><code>request.post_vars</code>: obiekt <code>gluon.storage.Storage</code> zawierający tylko parametry przekazane do ciała żądania (zwykle w żądaniach POST, PUT, DELETE);</li><li><code>request.client</code>: adres IP klienta, zgodnie z ustaleniem <code>request.env.http_x_forwarded_for</code>, jeśli obecne, a jeśli nie to przez <code>request.env.remote_addr</code>. Chociaż jest to użyteczne, to jednak nie należy temu ufać, ponieważ <code>http_x_forwarded_for</code> może być sfałszowane;</li><li><code>request.is_local</code>: <code>True</code> jeśli klientem jest localhost, w przeciwnym razie <code>False</code>. Powinno działać na proxy, jeśli proxy obsługuje <code>http_x_forwarded_for</code>;</li><li><code>request.is_https</code>: <code>True</code> jeśli żądanie używa protokołu HTTPS, w przeciwnym razie <code>False</code>;</li><li><code>request.body</code>: strumień plikowy tylko do odczytu zawierający ciało żądania HTTP. Jest on automatycznie parsowany w celu pobrania <code>request.post_vars</code> i następnie przewinięty. Można go odczytać poprzez <code>request.body.read()</code>;</li><li><code>request.ajax</code> True jeśli funkcja jest wywoływana poprzez żądanie Ajax;</li><li><code>request.cid</code> jest to identyfikator komponentu, który wygenerował żądanie Ajax (jeśli miało to miejsce). Więcej informacji na ten temat znajduje się w rozdziale 12;</li><li><code>request.requires_https()</code> uniemożliwia dalsze wykonywanie kodu, jeśli żądanie nie jest realizowane poprzez HTTPS i przekierowuje odwiedzającego do bieżącej strony poprzez HTTPS.</li><li><code>request.restful</code> jest to nowy i bardzo przydatny dekorator, który może być wykorzystany do zmiany zachowania akcji web2py przez oddzielne żądania GET/POST/PUSH/DELETE. Jest to omówione w rozdziale 10.</li><li><code>request.user_agent()</code> analizuje pole user_agent w nagłówku żądania i zwraca informację w formie słownika. Jest to przydatne do wykrywania urządzeń mobilnych. Wykorzystuje kod "gluon/contrib/user_agent_parser.py" stworzony przez Rossa Peoples. Aby zobaczyć jak to działa, spróbuj osadzić w widoku następujący kod:</li></ul><pre><code class="code">{{=BEAUTIFY(request.user_agent())}}</code></pre><ul><li><code>request.global_settings</code> <div class="inxx">request.global_settings</div> zawiera ustawienia ogólnosystemowe web2py. Są one ustawiane automatycznie i nie ma potrzeby zmieniania ich. Na przykład <code>request.global_settings.gluon_parent</code> zawiera pełną ścieżkę do folderu web2py, <code>request.global_settings.is_pypy</code> określa czy web2py jest uruchomiony na PyPy;</li><li><code>request.wsgi</code> jest to hak, który umożliwia wywołanie aplikacji WSGI osób trzecich z poziomu akcji.</li></ul><p>Ostatnio dołączono:</p><ul><li><code>request.wsgi.environ</code></li><li><code>request.wsgi.start_response</code></li><li><code>request.wsgi.middleware</code></li></ul><p>ich użycie jest omówione na końcu tego rozdziału.</p><p>Jako przykład, następujące adres na typowym systemie:</p><pre><code class="code">http://127.0.0.1:8000/examples/default/status/x/y/z?p=1&amp;q=2</code></pre><p>da w wyniku następujący obiekt <code>request</code>: <div class="inxx">request</div> <div class="inxx">env</div></p><table><tbody><tr class="first"><td><strong>variable</strong></td><td><strong>value</strong></td></tr><tr class="even"><td><code>request.application</code></td><td><code>examples</code></td></tr><tr><td><code>request.controller</code></td><td><code>default</code></td></tr><tr class="even"><td><code>request.function</code></td><td><code>status</code></td></tr><tr><td><code>request.extension</code></td><td><code>html</code></td></tr><tr class="even"><td><code>request.view</code></td><td><code>status</code></td></tr><tr><td><code>request.folder</code></td><td><code>applications/examples/</code></td></tr><tr class="even"><td><code>request.args</code></td><td><code>['x', 'y', 'z']</code></td></tr><tr><td><code>request.vars</code></td><td><code>&lt;Storage {'p': 1, 'q': 2}&gt;</code></td></tr><tr class="even"><td><code>request.get_vars</code></td><td><code>&lt;Storage {'p': 1, 'q': 2}&gt;</code></td></tr><tr><td><code>request.post_vars</code></td><td><code>&lt;Storage {}&gt;</code></td></tr><tr class="even"><td><code>request.is_local</code></td><td><code>False</code></td></tr><tr><td><code>request.is_https</code></td><td><code>False</code></td></tr><tr class="even"><td><code>request.ajax</code></td><td><code>False</code></td></tr><tr><td><code>request.cid</code></td><td><code>None</code></td></tr><tr class="even"><td><code>request.wsgi</code></td><td><code>&lt;hook&gt;</code></td></tr><tr><td><code>request.env.content_length</code></td><td><code>0</code></td></tr><tr class="even"><td><code>request.env.content_type</code></td><td></td></tr><tr><td><code>request.env.http_accept</code></td><td><code>text/xml,text/html;</code></td></tr><tr class="even"><td><code>request.env.http_accept_encoding</code></td><td><code>gzip, deflate</code></td></tr><tr><td><code>request.env.http_accept_language</code></td><td><code>en</code></td></tr><tr class="even"><td><code>request.env.http_cookie</code></td><td><code>session_id_examples=127.0.0.1.119725</code></td></tr><tr><td><code>request.env.http_host</code></td><td><code>127.0.0.1:8000</code></td></tr><tr class="even"><td><code>request.env.http_referer</code></td><td><code>http://web2py.com/</code></td></tr><tr><td><code>request.env.http_user_agent</code></td><td><code>Mozilla/5.0</code></td></tr><tr class="even"><td><code>request.env.path_info</code></td><td><code>/examples/simple_examples/status</code></td></tr><tr><td><code>request.env.query_string</code></td><td><code>remote_addr:127.0.0.1</code></td></tr><tr class="even"><td><code>request.env.request_method</code></td><td><code>GET</code></td></tr><tr><td><code>request.env.script_name</code></td><td></td></tr><tr class="even"><td><code>request.env.server_name</code></td><td><code>127.0.0.1</code></td></tr><tr><td><code>request.env.server_port</code></td><td><code>8000</code></td></tr><tr class="even"><td><code>request.env.server_protocol</code></td><td><code>HTTP/1.1</code></td></tr><tr><td><code>request.env.server_software</code></td><td><code>Rocket 1.2.6</code></td></tr><tr class="even"><td><code>request.env.web2py_path</code></td><td><code>/Users/mdipierro/web2py</code></td></tr><tr><td><code>request.env.web2py_version</code></td><td><code>Version 2.4.1</code></td></tr><tr class="even"><td><code>request.env.wsgi_errors</code></td><td><code>&lt;open file, mode 'w' at &gt;</code></td></tr><tr><td><code>request.env.wsgi_input</code></td><td></td></tr><tr class="even"><td><code>request.env.wsgi_url_scheme</code></td><td><code>http</code></td></tr></tbody></table><p>To jakie zmienne środowiskowe zostaną zdefiniowane zależy od serwera internetowego. Tutaj założyliśmy użycie wbudowanego serwera WSGI Rocket. Ten zestaw zmiennych nie różni zbyt od tego, jaki otrzymuje się przy użyciu serwera internetowego Apache.</p><p>Zmienne <code>request.env.http_*</code> z nagłówka żądania HTTP są parsowane.</p><p>Zmienne <code>request.env.web2py_*</code> ze środowiska serwera internetowego nie są parsowane, ale są tworzone przez web2py. W przypadku naszej aplikacji trzeba znać lokalizację i wersję oraz czy jest ona uruchomiona na Google App Engine (ponieważ może być konieczna specyficzna optymalizacja).</p><p>Warto również zwrócić uwagę na zmienne <code>request.env.wsgi_*</code>. Są one specyficzne dla adaptera wsgi.</p><h3>Obiekt <code>response</code></h3><div class="inxx">response</div><div class="inxx">response.body</div><div class="inxx">response.cookies</div><div class="inxx">response.download</div><div class="inxx">response.files</div><div class="inxx">response.flash</div><div class="inxx">response.headers</div><div class="inxx">response.meta</div><div class="inxx">response.menu</div><div class="inxx">response.postprocessing</div><div class="inxx">response.render</div><div class="inxx">response.static_version</div><div class="inxx">response.status</div><div class="inxx">response.stream</div><div class="inxx">response.subtitle</div><div class="inxx">response.title</div><div class="inxx">response.toolbar</div><div class="inxx">response.view</div><div class="inxx">response.delimiters</div><div class="inxx">response.js</div><div class="inxx">response.write</div><div class="inxx">response.include_files</div><div class="inxx">response.include_meta</div><div class="inxx">response.optimize_css</div><div class="inxx">response.optimize_js</div><div class="inxx">response._caller</div><div class="inxx">response.models_to_run</div><p>Obiekt <code>response</code> jest inną instancją klasy <code>Storage</code>. Zawiera co następuje:</p><ul><li><code>response.body</code>: obiekt <code>StringIO</code> w którym web2py zapisuje ciało strony wyjściowej. NIGDY NIE ZMIENIAJ TEJ ZMIENNEJ;</li><li><code>response.cookies</code>: podobne do <code>request.cookies</code> z tą różnicą, że zamiast ciasteczek przesłanych od klienta zawiera ciasteczka ciasteczka wysłane przez serwer do klienta. Ciasteczko sesji jest obsługiwane automatycznie.</li><li><code>response.download(request, db)</code>: metoda używana do implementowania funkcji kontrolera umożliwiającej pobieranie przesyłanych plików. Metoda <code>response.download</code> oczekuje aby ostatni <code>arg</code> w <code>request.args</code> był zakodowaną nazwą pliku (np. nazwą pliku generowaną w czasie przesyłania i zapisana w polu upload). Ekstrahuje ona nazwę przesyłanego pliku oraz nazwę tabeli, jak również oryginalną nazwę pliku. Metoda <code>response.download</code> pobiera dwa opcjonalne argumenty: <code>chunk_size</code> ustawia rozmiar w bajtach dla pakietowego przesyłania strumieniowego (domyślnie to 64K) a <code>attachments</code> określa czy pobrany plik powinien być traktowany jako załącznik czy też nie (domyślnie to <code>True</code>). Trzeba mieć na uwadze, że <code>response.download</code> jest specjalnie przeznaczony dla pobieranie plików związanych z polami upload w <code>db</code>. Używaj <code>response.stream</code> (patrz niżej) dla innych typów pobieranych plików i strumieniowania. Proszę również zwrócić uwagę, że nie jest konieczne użycie <code>response.download</code> w celu uzyskania dostępu do plików przesyłanych do folderu /static – pliki statyczne mogą (i na ogół powinny) być dostępne bezpośrednio poprzez adres URL (np. /app/static/files/myfile.pdf);</li><li><code>response.files</code>: lista plików <code>.css</code>, <code>.js</code>, <code>.coffee</code> i <code>.less</code> wymaganych przez stronę. Będą one automatycznie linkowane w sekcji standardowego widoku "layout.html" za pomocą "web2py_ajax.html". W celu dołączenia nowych plików CSS, JS, COFFEE lub LESS wystarczy je dołączyć do tej listy. Będą obsługiwane duplikaty. Kolejność jest ważna;</li><li><code>response.include_files()</code> generuje znaczniki sekcji head pliku html w celu dołączenia wszystkich <code>response.files</code> (używanych w "views/web2py_ajax.html");</li><li><code>response.flash</code>: opcjonalny parametr, który może zostać zawarty w widokach. Zwykle używany do powiadamiania użytkownika o czymś co się stało.</li><li><code>response.headers</code>: słownik dla nagłówków odpowiedzi HTTP. Platforma web2py ustawia domyślnie kilka nagłówków, w tym "Content-Length", "Content-Type" i "X-Powered-By" (ustawiany na <code>web2py</code>). Platforma web2py ustawia również nagłówki "Cache-Control", "Expires" i "Pragma" w celu zapobiegania buforowaniu po stronie klienta, z wyjątkiem żądań dla plików statycznych, dla których buforowanie po stronie klienta jest włączone. Nagłówki ustawiane przez web2py mogą być nadpisywane lub usuwane oraz mogą być dodawane nowe nagłówki (np. <code>response.headers['Cache-Control'] = 'private'</code>). Nagłówek może zostać usunięty przez usunięcie jego klucza ze słownika, np. <code>del response.headers['Custom-Header']</code>, jednak domyślne nagłówki web2py zostaną po prostu dodane ponownie przed zwróceniem odpowiedzi. Aby uniknąć tego problemu, potrzeba ustawić wartość nagłówka na None, np. w celu usunięcia domyśłnego nagłówka Content-Type, trzeba ustawić <code>response.headers['Content-Type'] = None</code>;</li><li><code>response.menu</code>: opcjonalny parametr, który może być zawarty w widokach, zwykle używany do przekazania nawigacyjnego drzewa menu do widoku. Może być renderowany przez helper MENU;</li><li><code>response.meta</code>: obiekt klasy Storage, który zawiera opcjonalne informacje <code>&lt;meta&gt;</code>, takie jak <code>response.meta.author</code>, <code>.description</code> lub <code>.keywords</code>. Zawartość każdej zmiennej meta jest automatycznie umieszczana w odpowiednim znaczniku <code>META</code> przez kod w widoku "views/web2py_ajax.html", który jest dołączany przez domyślny widok "views/layout.html";</li><li><code>response.include_meta()</code> generuje ciąg znakowy zawierający wszystkie serializowane nagłówki <code>response.meta</code> (używane w widoku "views/web2py_ajax.html");</li><li><code>response.postprocessing</code>: jest to lista funkcji, domyślnie pusta. Funkcje te są wykorzystywane do filtrowania obiektu odpowiedzi na wyjściu akcji, zanim wyjście zostanie zrenderowane przez widok. Listę ta można wykorzystać do implementacji innych języków szablonowania;</li><li><code>response.render(view, vars)</code>: metoda używana do wywołania widoku w sposób jawny wewnątrz kontrolera. Opcjonalny parametr <code>view</code> jest nazwą pliku widoku, <code>vars</code> jest słownikiem nazwanych wartości przekazywanych do widoku;</li><li><code>response.session_file</code>: plik strumienia zawierający sesję;</li><li><code>response.session_file_name</code>: nazwa pliku w którym będą zapisywane sesje;</li><li><code>response.session_id</code>: identyfikator bieżącej sesji. Jest ustalany automatycznie. NIGDY NIE ZMIENIAJ TEJ ZMIENNEJ;</li><li><code>response.session_id_name</code>: nazwa ciasteczka sesji dla tej aplikacji. NIGDY NIE ZMIENIAJ TEJ ZMIENNEJ;</li><li><code>response.static_version</code>: numer wersji dla zarządzania statycznymi aktywami;</li><li><code>response.status</code>: kod stanu HTTP, który ma być przekazany do odpowiedzi. Domyślnie, to 200 (OK);</li><li><code>response.stream(file, chunk_size, request=request, attachment=False, filename=None)</code>: gdy kontroler to zwraca, web2py strumieniuje z powrotem zawartość pliku do klienta w blokach o wielkości określonej w <code>chunk_size</code>. Parametr <code>request</code> jest wymagany do korzystania z początku fragmentu w nagłówku HTTP. Parametr <code>file</code>powinien być ścieżką do pliku (z powodu wstecznej kompatybilności, może to być również obiekt otwartego pliku, lecz nie jest to zalecane). Jak wspomniano powyżej, metoda <code>response.download</code> powinna być używana do pobierania przechowywanych plików poprzez pole upload. Metodę <code>response.stream</code> można wykorzystywać w innych przypadkach, takich jak zwracanie pliku tymczasowego lub obiektu StringIO utworzonego przez kontroler. Jeśli parametr <code>attachment</code> to True, nagłówek Content-Disposition zostanie ustawiony na "attachment", a jeśli <code>filename</code> jest też dostarczone, to zostanie dodany również nagłówek Content-Disposition (ale tylko wtedy, gdy <code>attachment</code> ma wartość True). Jeśli nic nie zawarto w <code>response.headers</code>, to następujące nagłówki odpowiedzi zostaną automatycznie ustawione: Content-Type, Content-Length, Cache-Control, Pragma i Last-Modified (trzy ostatnie będą ustawione w celu umożliwienia przeglądarce buforowania pliku). Aby nadpisać któryś z tych automatycznych ustawień, wystarczy ustawić go w <code>response.headers</code> przed wywołaniem <code>response.stream</code>;</li><li><code>response.subtitle</code>: opcjonalny parametr, który może zostać zawarty w widokach. Powinien zawierać podtytuł strony;</li><li><code>response.title</code>: opcjonalny parametr, który może zostać zawarty w widokach. Powinien zawierać tytuł strony i powinien być renderowany wewnątrz znacznika title HTML w sekcji header.</li><li><code>response.toolbar</code>: funkcja umożliwiająca osadzenie paska narzędziowego na stronie do celów debugowania <code>{{=response.toolbar()}}</code>. Ten pasek narzędziowy wyświetla żądania, odpowiedzi, zmienne sesji oraz czas dostępu do bazy danych w każdym zapytaniu;</li><li><code>response._vars</code>: ta zmienna jest dostępna tylko w widoku, nie w akcji. Zawiera wartości zwracane przez akcję do widoku;</li><li><code>response._caller</code>: jest to funkcja opakowująca wszystkie wywołania akcji. Domyślnie jest to funkcja identyczna, ale może zostać zmodyfikowana w celu wyłapania specjalnych typów wyjątków i ich dodatkowym zarejestrowaniu w dzienniku; <code>  response._caller = lambda f: f()
  </code></li><li><code>response.optimize_css</code>: można ustawić na "concat,minify,inline" w celu łączenia, minifikacji i łączenia w jedną linię kodu plików CSS dołączonych przez web2py;</li><li><code>response.optimize_js</code>: można ustawić na "concat,minify,inline" w celu łączenia, minifikacji i łączenia w jedną linię kodu plików CSS dołączonych przez web2py;</li><li><code>response.view</code>: nazwa szablonu widoku, który musi renderować stronę. Domyślnie ustawione jest na: <code class="code">  "%s/%s.%s" % (request.controller, request.function, request.extension)
  </code> lub jeżeli powyższy plik nie może zostać zlokalizowany, to na <code class="code">  "generic.%s" % (request.extension)
  </code> Można zmienić wartość tej zmiennej w celu zmodyfikowania pliku widoku związanego z określona akcją.</li><li><code>response.delimiters</code> domyślnie to <code>('{{','}}')</code>. Pozwala to na zmianę separatora kodu osadzanego w widokach;</li><li><code>response.xmlrpc(request, methods)</code>: gdy kontroler to zwraca, funkcja udostępnia metody poprzez XML-RPC<sup>[<a href="/book/default/reference/42/xmlrpc" target="_blank">xmlrpc</a>]</sup> . Funkcja ta jest przestarzała ponieważ dostępne są lepsze mechanizmy opisane w rozdziale 10;</li><li><code>response.write(text)</code>: metoda do wpisywania tekstu do ciała strony wyjściowej;</li><li><code>response.js</code> może zawierać kod JavaScript. Kod ten będzie wykonywany tylko jeśli odpowiedź jest odbierana przez komponent web2py, tak jak opisano to w rozdziale 12;</li><li><code>response.models_to_run</code> <span class="anchor" id="markmin_response_models_to_run"></span> zawiera listę wyrażeń regularnych wybierających to co modele uruchamiają;<ul><li>Domyślnie jest ustawiane dla ładowania plików /a/models/*.py, /a/models/c/*.py i /a/models/c/f/*.py gdy żądany jest <code>/a/c/f</code>. Można ustawić np. <code>response.models_to_run = ['myfolder/']</code> aby wymuszać tylko modele wewnątrz podfolderu <code>models/myfolder</code> aplikacji;</li><li>NB: <code>response.models_to_run</code> jest listą wyrażeń regularnych a nie listą ścieżek do pliku. Wyrażenia regularne są względne w stosunku do folderu models/, tak więc każdemu plikowi modelu odpowiada jedna ścieżka do pliku, który ma być wykonany. Należy również zwrócić uwagę, że to nie może wpływać na żadne modele które zostały już ewaluowane, ponieważ zostały wcześniej posortowane alfabetycznie. Tak jest, jeśli warunkowy model dla kontrolera orange to orange/orange_model.py i ustawiono wyrażenie regularne na [.*], którego zmiany nie wpływają na żaden poprzednio odrzucony model do załadowania, taki jak apple/apple_model.py – dopasowuje to nowe wyrażenie regularne, ale będzie to ewaluowane i odrzucane zanim orange/orange_model.py zmieni wyrażenie regularne;</li><li>Oznacza to, że jeśli chce się użyć models_to_run w celu udostępnienia warunkowych modeli pomiędzy kontrolerami, to trzeba umieścić model w podfolderze, w którym elementy są sortowane malejąco, taki jak zzz i następnie użycie wyrażenia regularnego 'zzz'.</li></ul></li></ul><p>Ponieważ <code>response</code> jest obiektem <code>gluon.storage.Storage</code>, to może być zastosowane do przechowywania innych atrybutów, które chce się przekazać do widoku. Chociaż nie ma technicznych ograniczeń, naszym zaleceniem jest przechowywanie tylko zmiennych, które mają być renderowane przez wszystkie strony z ogólnym układem ("layout.html").</p><p>W każdym razie, zdecydowanie sugerujemy aby utrzymywać zmienne wymienione tutaj:</p><pre><code class="code">response.title
response.subtitle
response.flash
response.menu
response.meta.author
response.meta.description
response.meta.keywords
response.meta.*</code></pre><p>ponieważ w ten sposób łatwiej jest zamienić standardowy plik "layout.html", na taki, który stosuje ten sam zestaw zmiennych.</p><p>W starszych wersjach web2py używano <code>response.author</code> zamiast <code>response.meta.author</code> i podobne do innych meta atrybutów.</p><h3>Obiekt <code>session</code></h3><p><div class="inxx">session</div> <div class="inxx">session.connect</div> <div class="inxx">session.forget</div> <div class="inxx">session.secure</div> Obiekt <code>session</code> jest jedną z instancji klasy <code>Storage</code>. Cokolwiek zostanie zapisywane w <code>session</code>, na przykład:</p><pre><code class="code">session.myvariable = "hello"</code></pre><p>może być odzyskane w późniejszym czasie:</p><pre><code class="code">a = session.myvariable</code></pre><p>tak długo, jak kod jest wykonywany w ramach tej samej sesji przez tego samego użytkownika (o ile użytkownik nie usunie ciasteczek sesji a sesja nie wygasła). Ponieważ <code>session</code> jest obiektem <code>Storage</code>, próba uzyskania dostępu do atrybutu (klucza), który nie został ustawiony nie zgłasza wyjątku, zamiast tego zwraca <code>None</code>.</p><p>Obiekt sesji ma trzy ważne metody. Jedna z nich, to <code>forget</code>:</p><pre><code class="code">session.forget(response)</code></pre><p>Informuje ona web2py, aby nie zapisywał sesji. Powinna być stosowana w tych kontrolerach, których akcje są wywoływane często i nie ma potrzeby śledzenia aktywności użytkownika. Metoda <code>session.forget()</code> zapobiega przed przepisywaniem pliku sesji niezależnie od tego czy był on modyfikowany. Metoda <code>session.forget(response)</code> dodatkowo otwiera i zamyka plik sesji. Rzadko trzeba korzystać z tej metody, ponieważ sesje nie są zapisywana, gdy nie zostały zmienione. Jednakże, jeśli strona wykonuje wiele jednoczesnych żądań Ajax, to dobrym pomysłem na wywoływanie akcji poprzez Ajax jest wywołanie <code>session.forget(response)</code> (zakładając, że sesja nie jest potrzebna dla akcji). W przeciwnym razie każda akcja Ajax będzie musiała czekać na zakończenie poprzedniej akcji (i odblokowanie pliku sesji) przed kontynuowaniem, co spowalnia ładowanie strony. Należy mieć na uwadze, że sesje nie zostają zablokowane, gdy są przechowywane w bazie danych.</p><p>Inna metoda to:</p><pre><code class="code">session.secure()</code></pre><p>który informuje web2py, aby ustawił ciasteczko sesji jako bezpieczne ciasteczko. Powinno się to ustawiać, jeśli aplikacja używa połączenia https. Przez ustawienie ciasteczka sesji jako bezpiecznego, serwer prosi przeglądarkę aby nie odsyłał z powrotem ciasteczka do serwera, chyba że przez połączenie https.</p><p>Następną metodą jest <code>connect</code>. Domyślnie sesje są przechowywane w systemie plików a ciasteczko jest używane do przechowywania i pobierania <code>session.id</code>. Używając metody connect jest możliwe poinformowanie web2y aby przechowywał sesje w bazie danych albo w ciasteczkach, eliminując konieczność dostępu do systemu plików w zarządzaniu sesją.</p><p>Na przykład, aby <strong>przechować sesje w bazie danych</strong>:</p><pre><code class="code">session.connect(request, response, db, masterapp=None)</code></pre><p>gdzie <code>db</code> jest nazwą otwartego połączenia z bazą danych (tak jak zwrócił to DAL). Powiadamia to web2py, że chce się przechować sesje w bazie danych a nie w systemie plików. Metoda <code>session.connect</code> musi być wywołana po <code>db=DAL(...)</code>, ale przed jakąkolwiek logika wymagajacą sesji, na przykład, konfiguracją <code>Auth</code>.</p><p>web2py tworzy tabelę:</p><pre><code class="code">db.define_table('web2py_session',
                 Field('locked', 'boolean', default=False),
                 Field('client_ip'),
                 Field('created_datetime', 'datetime', default=now),
                 Field('modified_datetime', 'datetime'),
                 Field('unique_key'),
                 Field('session_data', 'text'))</code></pre><p>i zapisze speklowane sesje w polu <code>session_data</code>.</p><p>Opcja <code>masterapp=None</code> (domyślnie) informuje web2py aby próbował odzyskać istniejącą sesję z nazwą w <code>request.application</code>, w uruchomionej aplikacji.</p><p>Jeśli chce się aby dwie lub więcej aplikacji współdzieliły sesje, trzeba ustawić <code>masterapp</code> na nazwę głównej aplikacji.</p><p>Aby zamiast tego <strong>zapisać sesje w ciasteczkach</strong> można zrobić:</p><pre><code class="code">session.connect(request,response,cookie_key='yoursecret',compression_level=None)</code></pre><p>Tutaj <code>cookie_key</code> to symetryczny klucz szyfrowania. <code>compression_level</code> jest opcjonalnym poziomem szyfrowania <code>zlib`.

Natomiast sesje w ciasteczku są często zalecane z powodu skalowalności, gdyż mają
ograniczoną wielkość. Duże sesje będą powodować załamanie się ciasteczek.

Można sprawdzić stan swojej aplikacji w dowolnym momencie przez wydrukowanie zmiennych
systemowych  </code>request<code>, </code>session<code> i </code>response<code>. Jednym sposobem na wykonanie
tego jest utworzenie dedykowanej akcji:</code> def status(): return dict(request=request, session=session, response=response) <code>:code

W widoku "generic.html" osiąga się to używając </code>{{=response.toolbar()}}<code>.

#### Nie przechowuj w sesji klas zdefiniowanych przez użytkownika

Zmienne przechowywane w sesji są zachowywane pomiędzy żądaniami dzięki  serializacji.

Sesje są pobierane przed wykonaniem kodu modułu, a więc przed zdefiniowaniem klas.
Dlatego klasy zdefiniowane przez użytkownika nie mogą zostać speklowane. 

Klasy zdefiniowane w modułach są również szarą strefą i nie powinny być umieszczane
w pamięci. Będą one działać przez większość czasu ale w końcu mogą załamać sesję.
Tak jest ponieważ, na przykład, jeśli zrestartuje się serwer internetowy w chwili
pobierania sesji przez użytkownika, to może się zdarzyć, że moduł zostanie zaimportowany.
Ten sam problem wystąpi podczas uruchamiania przez serwer internetowy nowego procesu
roboczego oraz w środowisku rozproszonym.

#### Oddzielne sesje

Jeśli sesje są przechowywane w systemie plików i ma się ich wiele, to system plików
może stać się wąskim gardłem. Jedno z rozwiązań jest następujące:</code> session.connect(request, response, separate=True) <code>:code

Ustawiając </code>separate=True<code> web2py będzie przechowywał sesje nie w folderze "sessions/"
ale w podfolderze folderu "sessions/". Podfolder będzie tworzony automatycznie.
Sesje z tym samym przedrostkiem będą zapisywane w tym samym podfolderze. Znowu trzeba
mieć na uwadze, że powyższe wyrażenie musi być wywołane przed jakąkolwiek logiką,
którą może wymagać sesja.

### Obiekt </code>cache<pre><code></code></pre>cache<code>:inxx </code>cache.ram<code>:inxx </code>cache.disk<code>:inxx
Globalny obiekt </code>cache<code> jest również dostępny w środowisku uruchomieniowym web2py.
Ma on dwa atrybuty:
- </code>cache.ram<code>: pamięć podręczna aplikacji w głównej pamięci;
- </code>cache.disk<code>: pamięć podręczna aplikacji na dysku.
Atrybut </code>cache<code> jest wywoływalny, co pozwala na stosowanie go jako dekoratora
akcji lub widoków.

Powyższy przykład buforuje funkcję </code>time.ctime()<code> w RAM:</code> def cache_in_ram(): import time t = cache.ram('time', lambda: time.ctime(), time_expire=5) return dict(time=t, link=A('click me', _href=request.url)) <code>:code

Wyjście funkcji </code>lambda: time.ctime()<code> jest buforowane w RAM przez 5 sekund.
Ciąg </code>'time'<code> został tu użyty jako klucz.

Poniższy przykład buforuje funkcję </code>time.ctime()<code> na dysku:</code> def cache_on_disk(): import time t = cache.disk('time', lambda: time.ctime(), time_expire=5) return dict(time=t, link=A('click me', _href=request.url)) <code>:code

Wyjście funkcji </code>lambda: time.ctime()<code> jest buforowane na dysku (z wykorzystaniem
modułów shelve) na 5 sekund.

Trzeba mieć na uwadze, że drugi argument </code>cache.ram<code> i </code>cache.disk<code> musi być
funkcją lub wywoływalnym obiektem. Jeśli chce się buforować istniejący obiekt,
a nie wyjście funkcji, można po prostu zwrócić to przez funkcję lambda:</code> cache.ram('myobject', lambda: myobject, time_expire=60*60*24) <code>:code

Następny przykład buforuje funkcję </code>time.ctime()<code> zarówno w RAM jak i na dysku:</code> def cache_in_ram_and_disk(): import time t = cache.ram('time', lambda: cache.disk('time', lambda: time.ctime(), time_expire=5), time_expire=5) return dict(time=t, link=A('click me', _href=request.url)) <code>:code

Wyjście </code>lambda: time.ctime()<code> jest buforowane na dysku (z wykorzystaniem moduły
shelve) a następnie w RAM na 5 sekund. Najpierw web2py przeszukuje pamięć RAM
i jeśli nic tam nie znajdzie, to przeszukuje dysk. Jeśli nie ma tego co potrzeba
ani w pamieci RAM ani na dysku, to wykonywana jest funkcja </code>lambda: time.ctime()<pre><code>i pamięć podręczna zostaje zaktualizowana. Technika ta jest użyteczna w środowisku
wieloprocesorowym. Dwa czasy nie muszą być takie same.

W poniższym przykładzie buforowane jest wyjście kontrolera funkcji (ale nie widoku)
w pamięci RAM:
</code></pre>buforowanie kontrolera<code>:inxx</code> @cache(request.env.path_info, time_expire=5, cache_model=cache.ram) def cache_controller_in_ram(): import time t = time.ctime() return dict(time=t, link=A('click me', _href=request.url)) <code>:code

Słownik zwracany przez </code>cache_controller_in_ram<code> jest buforowany w RAM na 5 sekund.
Proszę zwrócić uwagę, że wynik wyboru bazy danych nie może być buforowany bez wykonania
najpierw serializacji. Lepszym sposobem jest buforowanie wybranej bazy danych bezpośrednio
przy wykorzystaniu argumentu </code>select<code> metody </code>cache<code>.

Poniższy przykład buforuje wyjście funkcji kontrolera (ale nie widoku) na dysk:</code> @cache(request.env.path_info, time_expire=5, cache_model=cache.disk) def cache_controller_on_disk(): import time t = time.ctime() return dict(time=t, link=A('click to reload', _href=request.url)) <code>:code

Słownik zwracany przez </code>cache_controller_on_disk<code> jest buforowany na dysku przez
5 sekund. Trzeba pamiętać, że web2py nie może buforować słownika, który zawiera
niepeklowane obiekty.

Możliwe jest również buforowanie widoku. Renderowanie widoku w funkcji kontrolera
to trik polegający na tym, aby kontroler zwracał ciąg znakowy. Jest to realizowane
przez zwracanie </code>response.render(d)<code> gdzie </code>d<code> jest słownikiem, który chcemy
przekazać do widoku. Poniższy przykład buforuje w RAM wyjście funkcji kontrolera
(łącznie z renderowanym widokiem):
</code>buforowanie widoku<code>:inxx</code> @cache(request.env.path_info, time_expire=5, cache_model=cache.ram) def cache_controller_and_view(): import time t = time.ctime() d = dict(time=t, link=A('click to reload', _href=request.url)) return response.render(d) <code>:code
Funkcja </code>response.render(d)<code> zwraca zrenderowany widok jako ciąg znakowy,
który jest teraz buforowany przez 5 sekund. Jest to najlepszy i najszybszy sposób buforowania.
------
Zalecamy stosowanie [[@cache.action #cache_action]] obsługiwane w web2py &gt; 2.4.6 
------

Proszę zwrócić uwagę, że </code>time_expire<code> jest używany do porównania bieżącego czasu
z czasem żądanego obiektu, który był ostatnio zapisany w pamięci podręcznej. Nie ma
to wpływu na przyszłe żądania. Umożliwia aby </code>time_expire<code> był ustawiany dynamicznie
podczas żądania obiektu, a nie ustalany podczas zapisywania obiektu. Na przykład:</code> message = cache.ram('message', lambda: 'Hello', time_expire=5)</p><code>:code

Załóżmy teraz, że następujące wywołanie jest wykonane na 10 sekund przed powyższym wywołaniem:</code><p>message = cache.ram('message', lambda: 'Goodbye', time_expire=20) <code>:code

Ponieważ </code>time_expire<code> jest ustawione na 20 sekund w drugim wywołaniu i tylko
10 sekund upłynęło od komunikaty, który był zapisany pierwszy, wartość "Hello"
będzie pobierana z pamięci podręcznej i nie zostanie zaktualizowana na "Goodbye".
5 sekundowa wartość </code>time_expire<code> w pierwszym wywołaniu nie ma wpływu na drugie
wywołanie.

Ustawienie </code>time_expire=0<code> (lub na wartość ujemną) wymusza, aby buforowana pozycja
była odświeżana  (ponieważ czas jaki upłynął od ostatniego zapisu zawsze będzie &gt; 0)
a ustawienie </code>time_expire=None<code> wymusza pobieranie wartości buforowanej, niezależnie
od czasu jaki upłynął od ostatnie zapisu (jeśli </code>time_expire<code> ma zawsze wartość</code>None<code>, to element buforowany będzie nigdy nie wygasający).

Z pamięci podręcznej można usunąć jedna lub więcej zmiennych poleceniem</code>cache clear<code>:inxx
</code> cache.ram.clear(regex='...') <code>:code

gdzie </code>regex<code> jest wyrażeniem regularnym dopasowującym wszystkie klucze, jakie
chce się usunąć z pamięci podręcznej. Można również usunąć pojedynczy element stosując:</code> cache.ram(key, None) <code>:code

gdzie </code>key<code> jest kluczem buforowanego elementu.

Możliwe jest również określenie innych mechanizmów buforowania, takie jak memcache.
Memcache jest dostępny poprzez </code>gluon.contrib.memcache<code> i został omówiony w rozdziale 14.

------
Bądź ostrożny podczas buforowania, pamiętając, że buforowanie jest zwykle dokonywane
na poziomie aplikacji, a nie na poziomie użytkownika. Jeśli potrzeba, na przykład,
buforować zawartość specyficzną dla użytkownika, to trzeba wybrać klucz, który zawiera
identyfikator użytkownika.
------

------
Aplikacja interfejsu administracyjnego aplikacji umożliwia wyświetlanie przycisków
pamięci podręcznej (i czyszczenia pamięci podręcznej). Dostęp do nich można uzyskać
z poziomu ekranu zarządzania bazą danych.
------

[[cache_action]]
#### </code>cache.action<code>W web2py domyślnie zakłada się, że zwracana zawartość nie będzie buforowana, gdyż
zmniejsza to złe skutki niewłaściwego buforowania po stronie klienta.

Na przykład, gdy wyświetla się formularz użytkownikowi lub listę rekordów, strona
internetowa nie powinna być buforowana, gdyż inni użytkownicy mogą w tym czasie
wprowadzać nowe rekordy do tabeli, która się wyświetla.

Zamiast tego, jeśli wyświetlana jest strona, której zawartość nie będzie się nigdy
zmieniać (lub zmieniać rzadko, np. raz na tydzień), to warto tą strona przechować,
ale jeszcze lepiej jest powiadomić klienta, że strona ta jest niezmienna.

Osiąga się to przez wysyłanie wraz ze stroną kilku specjalnych nagłówków. Gdy
przeglądarka klienta odbierze taką zawartość, to przechowa ją w pamięci podręcznej
przeglądarki i nie będzie żądać ponownie takiej strony od serwera. Jest to **główny**
mechanizm przyśpieszania witryn o dostępie publicznym.

W wersjach web2py &gt; 2.4.6 wprowadzono nowy dekortor </code>cache.action<code> umożliwiający
bardziej inteligentną obsługę takich sytuacji.
Dekorator </code>cache.action<code> może zostać użyty do:
- ustawiania inteligentnych nagłówków buforowania;
- odpowiedniego buforowania wyników.
------
NB: Jest stosowane dla jednego lub drugiego celu albo obu naraz.
------
Użycie request.env.path_info jako klucza w buforowaniu widoku poprzez</code>@cache(request.env.path_info, time_expire=300, cache_model=cache.ram)<code> sprawia
kilka problemów, np.:
+ Zmienne URL nie są obsługiwane
  -- Buforowanie wyniku ''/app/default/index?**search=foo**'' : przez następne
     300 sekund ''/app/default/index?**search=bar**'' zwróci dokładnie ta samą rzecz
     co ''/app/default/index?**search=foo**'';
+ Użytkownik nie jest obsługiwany
  -- Jakiś użytkownik uzyskuje często dostęp do strony i wybiera ją z pamięci podręcznej.
     Jednakże, buforowany był wynik ''/app/default/index'' przy wykorzystaniu request.env.path_info
     jako klucz, tak więc inny użytkownik będzie widział stronę, która nie była przeznaczona dla niego;
  -- Buforowana została strona użytkownika "Bill", gdy "Bill" uzyskał dostęp do strony z pulpitu.
     Teraz próbuje on uzyskać dostęp z telefonu komórkowego: jeśli przygotowany był szablon dla
     użytkowników mobilnych, który jest inny od standardowego, to "Joe" nie zobaczy go;
+ Język nie jest obsługiwany
  -- Podczas buforowania strony, jeśli użyje się funkcji T() dla tych samych
     elementów, strona zostanie zapisana wraz z ustalonym tłumaczeniem;
+ Metoda żądania nie jest obsługiwana
  -- Gdy buforuje się stronę, to należy je buforować tylko wtedy, gdy jest ona
     wynikiem operacji GET
+ Kod stan strony nie jest obsługiwany
  -- Gdy buforuje się stronę po raz pierwszy, czasami może pójść coś nie tak
     i zwracana jest piękna strona 404.
     Przecież nie chcesz buforować błędów.

Zamiast pisać dużo kodu szablonowego rozwiązującego te wszystkie problemy, wystarczy
utworzyć </code>cache.action<code>.
Inteligentnie używa to nagłówki buforowania pozwalając przeglądarce buforować wynik:
jeśli przekaże się do buforowania model, to rozwiązany zostanie automatycznie klucz,
w najlepszy sposób, tak że różne wersje tej samej strony mogą być przechowywane
i pobierane odpowiednio (np. jedna w języku angielskim a druga w polskim).

Pobiera to kilka parametrów, z inteligentnymi wartościami domyślnymi:

- time_expire : domyślnie 300 sekund;
- cache_model : domyślnie None. Oznacza to, że @cache.action będzie **tylko** zmieniał nagłówki, aby pozwolić przeglądarce klienta buforować tą zawartość;
    -- jeśli przekaże się, np., </code>cache.ram<code>, to wynik zostanie też zapisany w pamięci podręcznej;
- prefix : jeśli chce się poprzedzić klucz auto-generated przedrostkiem (przydatne przy usuwaniu go później przez np. </code>cache.ram.clear(prefix*)<code>);
- session : jeśli chce się wziąść po uwagę sesję, domyślnie False;
- vars : jeśli chce się wziąć pod uwagę zmienne URL, domyślnie True;
- lang : jeśli chce się wziąć pod język, domyślnie True;
- user_agent : jeśli chce się wziąć pod uwagę rodzaj przeglądarki użytkownika (''ang. user agent''), domyślnie False;
- public : jeśli chce się buforować tą samą stronę dla wszystkich odwiedzających, tak że będzie zawsze dostępna, domyślnie True;
- valid_statuses : domyślnie None. cache.client będzie buforował tylko strony z metodą GET, których kod stanu rozpoczyna się os 1,2 lub 3; 
  Można przekazać listę kodów stanu (jeśli chce się aby strony były buforowane z tymi stanami, np. status_codes=[200] spowoduje buforowanie tylko strony, których kod stanu wynosi 200) 
- quick : domyślnie None, ale można przekazać listę liter w celu ustawienia właściwej  funkcjonalności:
  -- **S**ession, **V**ars, **L**ang, **U**ser_agent, **P**ublic
     np. </code>@cache.action(time_expire=300, cache_model=cache.ram, quick='SVP')<code> to to samo co
     </code>@cache.action(time_expire=300, cache_model=cache.ram, session=True, vars=True, public=True)<code>
**Obsługiwanie**, opisane wyżej, oznacza np. dla **zmiennych**, że chcąc buforować różne strony,
gdy **zmienne** są różne, to ''/app/default/index?**search=foo**'' nie będzie takie
samo jak ''/app/default/index?**search=bar**''.
To zachowanie jest nadpisywane przez kilka ustawień, tak więc np., jeśli ustawi
się </code>session=True, public=True<code>, to drugie wyrazenie zostanie odrzucone.

Stosuj to mądrze!

[[URL]]
### Funkcja </code>URL<pre><code></code></pre>URL<code>:inxx </code>funkcja URL<code>:inxx
Funkcja </code>URL<code> jest jedna z najważniejszych funkcji w web2py. Generuje wewnętrzne
ścieżki URL dla akcji i plików statycznych.

Oto przykład:
</code> URL('f')</p><code>:code

jest mapowane na
</code><p>/[application]/[controller]/f <code>:code

Proszę zwrócić uwagę, że wyjście funkcji </code>URL<code> zależy od nazwy bieżącej aplikacji,
wywoływanego kontrolera i innych parametrów. Platforma web2py obsługuje mapowanie
URL i odwrotne mapowanie URL. Mapowanie URL pozwala przedefiniować format zewnętrznych
adresów URL. Jeśli używa się funkcji </code>URL<code> do generowania wszystkich zewnętrznych
adresów URL, to następnie trzeba dodać lub zmienić mapowania URL, co zabezpieczy
nie działającym linkom w aplikacji web2py.

Do funkcji </code>URL` można przekazać dodatkowe parametry, tj. dodatkowe warunki w ścieżce adresu URL (args) i zmienne zapytań URL (vars):</p><pre><code class="code">URL('f', args=['x', 'y'], vars=dict(z='t'))</code></pre><p>jest mapowane na</p><pre><code class="code">/[application]/[controller]/f/x/y?z=t</code></pre><p>Atrybuty <code>args</code> są automatycznie parsowane, dekodowane i w końcu zapisywane w <code>request.args</code>. Podobnie <code>vars</code> są parsowane, dekodowane i zapisywane w <code>request.vars</code>. <code>args</code> i <code>vars</code> dostarczają podstawowe mechanizmy, przy pomocy których web2py wymienia informację z przeglądarką klienta.</p><p>Jeśli <code>args</code> zawiera tylko jeden element, to nie ma potrzeby przekazywania go w liście.</p><p>Można również użyć funkcji <code>URL</code> do generowania adresów URL dla akcji w innych kontrolerach i aplikacjach:</p><pre><code class="code">URL('a', 'c', 'f', args=['x', 'y'], vars=dict(z='t'))</code></pre><p>jest mapowane na</p><pre><code>/a/c/f/x/y?z=t</code></pre><p>Możliwe jest też określenie aplikacji, kontrolera i funkcji przy użyciu nazwanych argumentów:</p><pre><code class="code">URL(a='a', c='c', f='f')</code></pre><p>Jeśli brak jest nazwy aplikacji <em>a</em>, to przyjmowana jest bieżąca aplikacja.</p><pre><code class="code">URL('c', 'f')</code></pre><p>Jeśli brak jest nazwy kontrolera <em>c</em>, to przyjmowany jest bieżący kontroler.</p><pre><code class="code">URL('f')</code></pre><p>Zamiast przekazywania nazwy funkcji kontrolera możliwe jest przekazywanie samej funkcji</p><pre><code class="code">URL(f)</code></pre><p>Z wyżej omówionych powodów, należy zawsze używać funkcji <code>URL</code> do generowania adresów URL plików statycznych aplikacji. Pliki statyczne przechowywane są w podfolderze <code>static</code> (tam kierowane są pliki podczas przesyłania ich za pośrednictwem interfejsu administracyjnego). Platforma web2py udostępnia wirtualny kontroler 'static', którego zadaniem jest pobieranie plików z podfolderu <code>static</code>, ustalenie typu zawartości i strumieniowanie pliku dla klienta. Poniższy przykład generuje adres URL dla pliku statycznego "image.png":</p><pre><code class="code">URL('static', 'image.png')</code></pre><p>jest mapowane na</p><pre><code class="code">/[application]/static/image.png</code></pre><p>Jeśli plik statyczny znajduje się w podfolderze folderu <code>static</code>, można dołączyć podfolder (podfoldery) jako część atrybutu filename. Na przykład, aby wygenerować:</p><pre><code>/[application]/static/images/icons/arrow.png</code></pre><p>trzeba użyć:</p><pre><code class="code">URL('static', 'images/icons/arrow.png')</code></pre><p>Nie ma potrzeby kodowania (zabezpieczania znakami ucieczki) argumentów <code>args</code> i <code>vars</code> - jest to czynione automatycznie.</p><p>Domyślnie rozszerzenie odpowiadające bieżącemu żądaniu (które można znaleźć w <code>request.extension</code>) jest dołączane do funkcji, chyba że request.extension to html (domyślnie). Można to przesłonić dołączając jawnie rozszerzenie jako część nazwy funkcji <code>URL(f='name.ext')</code> lub jako wartość argumentu extension:</p><pre><code class="code">URL(..., extension='css')</code></pre><p>Bieżące rozszerzenie może być zmazane:</p><pre><code class="code">URL(..., extension=False)</code></pre><h4>Bezwzględne adresy URL</h4><p>Domyślnie funkcja <code>URL</code> generuje względne adresy URL. Jednakże, można również generować bezwzględne adresy URL określając argumenty <code>scheme</code> i <code>host</code> (jest to przydatne, na przykład, przy wstawianiu adresów URL w wiadomościach email):</p><pre><code class="code">URL(..., scheme='http', host='www.mysite.com')</code></pre><p>Można automatycznie dołączyć schemat i host bieżącego żądania przez ustawienie tych argumentów na <code>True</code>.</p><pre><code class="code">URL(..., scheme=True, host=True)</code></pre><p>Funkcja <code>URL</code> akceptuje również argument <code>port</code> do określania portu serwera, jeśli to konieczne.</p><h4>Adresy URL z podpisem cyfrowym</h4><div class="inxx">adresy URL z podpisem cfrowym</div><p>Podczas generowania adresu URL, ma się możliwość jego cyfrowego podpisania. Dołącza to zmienną GET <code>_signature</code>, która może być zweryfikowana przez serwer. Można to zrobić w dwojaki sposób.</p><p>Można przekazać do funkcji URL następujące argumenty:</p><ul><li><code>hmac_key</code>: klucz do podpisania adresu URL (ciąg znakowy);</li><li><code>salt</code>: opcjonalny ciąg znakowy będący solą (ciągiem zaburzającym) haszowanie podpisu;</li><li><code>hash_vars</code>: opcjonalna lista nazw zmiennych z ciąga zapytania URL (czyli zmiennych GET), które będą dołączone do sygnatury. Można to również ustawić na <code>True</code> (wartość domyślna) aby dołączać wszystkie zmienne lub na <code>False</code> aby nie dołączać żadnych zmiennych.</li></ul><p>Oto przykład zastosowania:</p><pre><code class="code">KEY = 'mykey'

def one():
    return dict(link=URL('two', vars=dict(a=123), hmac_key=KEY))

def two():
    if not URL.verify(request, hmac_key=KEY): raise HTTP(403)
    # do something
    return locals()</code></pre><p>Sprawia to, że akcja <code>two</code> jest dostępna tylko poprzez adres URL podpisany cyfrowo. Adres URL podpisany cyfrowo wygląda podobnie do tego:</p><pre><code>'/welcome/default/two?a=123&amp;_signature=4981bc70e13866bb60e52a09073560ae822224e9'</code></pre><p>Trzeba mieć na uwadze, że podpis cyfrowy jest weryfikowany przez funkcje <code>URL.verify</code>. Funkcja <code>URL.verify</code> również pobiera argumenty <code>hmac_key</code>, <code>salt</code> i <code>hash_vars</code> opisane powyżej a ich wartości muszą pasować do wartości, które zostały przekazane do funkcji <code>URL</code> podczas tworzenia podpisu cyfrowego.</p><p>Druga i bardziej zaawansowana i bardziej powszechna metoda cyfrowego podpisywania adresów URL to powiązanie tego z uwierzytelnianiem. Najlepiej wyjaśnić to na przykładzie:</p><pre><code class="code">@auth.requires_login()
def one():
    return dict(link=URL('two', vars=dict(a=123), user_signature=True)

@auth.requires_signature()
def two():
    # do something
    return locals()</code></pre><p>W tym przypadku <code>hmac_key</code> jest generowany automatycznie i udostępniany w sesji. Umożliwia to, aby akcja <code>two</code> delegowała kontrole dostępu do akcji <code>one</code>. Jeśli odnośnik został wygenerowany i podpisany, to jest prawidłowy, w innym razie nie. Jeśli odnośnik zostanie skradziony przez innego użytkownika, to będzie nieprawidłowy.</p><p>Dobrą praktyka jest podpisywanie cyfrowo zawsze wywołań zwrotnych Ajax. Jeśli używa się funkcji <code>LOAD</code> web2py, to ma się do dyspozycji argument <code>user_signature</code> służący temu celowi:</p><pre><code>{{=LOAD('default', 'two', vars=dict(a=123), ajax=True, user_signature=True)}}</code></pre><h3><code>HTTP</code> i <code>redirect</code></h3><p><div class="inxx">HTTP</div> <div class="inxx">redirect</div></p><p>Platforma web2py definiuje tylko jeden nowy wyjątek o nazwie <code>HTTP</code>. Ten wyjątek może być wywołany gdziekolwiek w modelu, kontrolerze lub widoku poleceniem:</p><pre><code class="code">raise HTTP(400, "my message")</code></pre><p>Powoduje to, że przepływ sterowania przechodzi z kodu użytkownika z powrotem do web2py i zwraca odpowiedź HTTP podobną do tego:</p><pre><code class="code">HTTP/1.1 400 BAD REQUEST
Date: Sat, 05 Jul 2008 19:36:22 GMT
Server: Rocket WSGI Server
Content-Type: text/html
Via: 1.1 127.0.0.1:8000
Connection: close
Transfer-Encoding: chunked

my message</code></pre><p>Pierwszy argument funkcji <code>HTTP</code> to kod stanu HTTP. Drugi argument to ciąg znakowy, który będzie zwracany jako ciało odpowiedzi. Dodatkowe nazwane argumenty są używane do budowy nagłówka odpowiedzi HTTP. Na przyklad:</p><pre><code class="code">raise HTTP(400, 'my message', test='hello')</code></pre><p>generuje:</p><pre><code class="code">HTTP/1.1 400 BAD REQUEST
Date: Sat, 05 Jul 2008 19:36:22 GMT
Server: Rocket WSGI Server
Content-Type: text/html
Via: 1.1 127.0.0.1:8000
Connection: close
Transfer-Encoding: chunked
test: hello

my message</code></pre><p>Jeśli nie chce się zatwierdzić transakcji otwartej bazy danych, to należy ją wycofać przed wywołaniem wyjątku.</p><p>Wszystkie wyjątki inne niż <code>HTTP</code> powodują, że web2py cofa wszystkie otwarte transakcje bazy danych, rejestruje komunikat dotyczący ostatniego wywołania (<em>ang. traceback</em>), wydaje bilet odwiedzającemu i zwraca standardową stronę błędu.</p><p>Oznacza to, że dla przepływu sterowania między stronami może zostać użyty tylko wyjątek <code>HTTP</code>. Inne wyjątki muszą zostać wyłapane przez aplikację, w przeciwnym razie są one biletowane przez web2py.</p><p>Polecenie:</p><pre><code class="code">redirect('http://www.web2py.com')</code></pre><p>jest po prostu skrótem dla:</p><pre><code class="code">raise HTTP(303,
           'Nastąpi przekierowanie &lt;a href="%s"&gt;tutaj&lt;/a&gt;' % location,
           Location='http://www.web2py.com')</code></pre><p>Nazwane argumenty metody inicjatora <code>HTTP</code> są tłumaczone na dyrektywy nagłówka HTTP, w tym przypadku, docelowe miejsce przekierowania. Wyrażenie <code>redirect</code> pobiera drugi opcjonalny argument, który jest kodem stanu HTTP dla przekierowania (domyślnie 303). Zmień ten numer na 307 dla tymczasowego przekierowania lub na 301 dla stałego przekierowania.</p><p>Najczęstszym sposobem użycia przekierowania jest przekierowanie do innej strony tej samej aplikacji i (opcjonalnie) przekazanie parametrów:</p><pre><code class="code">redirect(URL('index', args=(1,2,3), vars=dict(a='b')))</code></pre><p>W rozdziale 12 omówimy komponenty web2py. Wykonują one żądania Ajax dla akcji web2py. Jeśli wywoływana akcja wykonuje przekierowanie, to można spowodować, że żądanie Ajax nastąpi po przekierowaniu albo że cała strona wykona przekierowanie żądania Ajax. W tym drugim przypadku można ustawić:</p><pre><code class="code">redirect(...,client_side=True)</code></pre><h3>Umiędzynarodowienie i pluralizacja za pomocą <code>T</code></h3><p><div class="inxx">T</div> <div class="inxx">umiędzynarodowienie</div></p><p>Obiekt <code>T</code> jest tłumaczem językowym. Stanowi pojedynczą globalną instancję klasy <code>gluon.language.translator</code> web2py. Wszystkie stałe łańcuchowe (i tylko stałe łańcuchowe) powinny być oznaczone przez <code>T</code>, na przykład:</p><pre><code class="code">a = T("hello world")</code></pre><p>Ciągi znakowe oznaczone przez <code>T</code> są identyfikowane przez web2py jako wymagające tłumaczenia i będą tłumaczone gdy kod (w modelu, kontrolerze lub widoku) będzie wykonywany. Jeśli ciąg znakowy do tłumaczenia nie jest stała lecz zmienną, to będzie dodany do pliku tłumaczenia w czasie wykonania (z wyjątkiem GAE)w celu późniejszego przetłumaczenia.</p><p>Obiekt <code>T</code> może również zawierać zmienne interpolowane i obsługiwać wiele równoważnych składni:</p><pre><code class="code">a = T("hello %s", ('Tim',))
a = T("hello %(name)s", dict(name='Tim'))
a = T("hello %s") % ('Tim',)
a = T("hello %(name)s") % dict(name='Tim')</code></pre><p>Zalecana jest ostatnia składnia ponieważ czyni tłumaczenie najłatwiejszym. Pierwszy ciąg jest tłumaczony zgodnie z żądanym plikiem językowym, a zmienna <code>name</code> jest zamieniana niezależnie od języka.</p><p>Można łączyć tłumaczone ciągi ze zwykłymi ciągami znakowymi:</p><pre><code class="code">T("blah ") + name + T(" blah")</code></pre><p>Poniższy kod jest również dozwolony i często stosowany:</p><pre><code class="code">T("blah %(name)s blah", dict(name='Tim'))</code></pre><p>lub alternatywna składnia</p><pre><code class="code">T("blah %(name)s blah") % dict(name='Tim')</code></pre><p>W obu przypadkach ciąg tłumaczony występujący przed nazwą zmiennej jest podstawiany w wyrażeniu "%(name)s". Poniższej alternatywy NIE NALEŻY STOSOWAĆ:</p><pre><code class="code">T("blah %(name)s blah" % dict(name='Tim'))</code></pre><p>ponieważ ciąg tłumaczony będzie występował po podstawieniu.</p><h4>Ustalenie języka</h4><p>Żądany język jest określany w polu "Accept-Language" nagłówka HTTP, ale ten wybór może być zastąpiony programowo przez żądanie określonego pliku, na przykład:</p><pre><code class="code">T.force('pl-pl')</code></pre><p>który czyta plik językowy "languages/pl-pl.py". Pliki językowe mogą być tworzone i edytowane poprzez interfejs administracyjny.</p><p>Można też wymusić język w każdym tłumaczonym ciągu:</p><pre><code class="code">T("Hello World", language="pl-pl")</code></pre><blockquote>W przypadku wielu wymaganych języków, na przykład "pl-pl, fr-ft", web2py próbuje
zlokalizować pliki tłumaczeń "pl-pl.py" i "fr-fr.py". Jeżeli żaden z wymaganych
plików nie zostanie znaleziony, to następuje próba odnalezienia plików "pl.py"
i "pl.py". Jeżeli te pliki nie będą odnalezione, to wybrany zostanie domyślny plik
"default.py". Jeżeli i ten plik nie będzie odnaleziony, to tłumaczenie nie nastąpi.
Bardziej ogólna zasada jest taka, że web2py próbuje dopasować kolejno nazwy plików
"xx-xy-yy.py", "xx-xy.py", "xx.py", "default.py" dla każdego z akceptowanych języków
"xx-xy-yy", próbując znaleźć najbardziej zbliżona nazwę do preferencji językowej
odwiedzającego.</blockquote><p>Tłumaczenie można całkowicie wyłączyć poprzez</p><pre><code class="code">T.force(None)</code></pre><p>Zwykle, ciąg tłumaczenia jest ewaluowany leniwie podczas renderowania widoku. Dlatego metoda <code>force</code> translatora nie będzie wywoływana wewnątrz widoku.</p><p>Możliwe jest wyłączenie leniwej ewaluacji poprzez</p><pre><code class="code">T.lazy = False</code></pre><p>W ten sposób ciągi są tłumaczone natychmiast przez operator <code>T</code> na podstawie aktualnie akceptowanego lub wymuszanego języka.</p><p>Możliwe jest też wyłączenie leniwej ewaluacji dla pojedynczych ciągów:</p><pre><code class="code">T("Hello World", lazy=False)</code></pre><p>Powszechnie spotykany problem jest następujący. Oryginalna aplikacja jest w języku angielskim. Załóżmy, że jest plik tłumaczenia (na przykład polski, "pl-pl.py") a klient HTTP deklaruje, że jego akceptowanym językiem jest zarówno angielski (en) jak i polski (pl-pl) w tej kolejności. Ma miejsce niepożądana sytuacja: web2py nie wie, że domyślny plik tłumaczenia ("default.py") został napisany w języku  angielskim (en). Dlatego preferować będzie dla wszystkiego tłumaczenie polskie  (pl-pl) ponieważ może znaleźć tylko plik "pl-pl.py". Gdyby nie znalazł tego pliku, to wybrałby domyślny plik językowy d"default.py" (angielski).</p><p>Istnieją dwa rozwiązania tego problemu: utworzenie tłumaczenia dla języka angielskiego, co byłoby powtórzeniem istniejącego pliku "default.py" albo rozwiązanie lepsze – powiadomienie web2py o tym, że powinien zostać zastosowany język angielski (język w którym zakodowano aplikację). Można to zrobić tak:</p><pre><code class="code">T.set_current_languages('en', 'en-en')</code></pre><p>Wyrażenie to przechowuje w <code>T.current_languages</code> listę języków, które nie wymagają tłumaczenia i wymusza przeładowanie plików językowych.</p><p>Trzeba pamiętać, że "pl" i "pl-pl" są różnymi językami z punktu widzenia web2py. Do obsługi obydwu potrzeba dwóch różnych plików językowych, o nazwach zawsze pisanych małymi literami. To samo odnosi się do innych języków.</p><p>Aktualnie akceptowany język jest przechowywany w</p><pre><code class="code">T.accepted_language</code></pre><h4>Tłumaczenie zmiennych</h4><p>T(...) tłumaczy nie tylko łańcuchy tekstowe ale też może tłumaczyć wartości przechowywane w zmiennych:</p><pre><code class="code">&gt;&gt;&gt; a="test"
&gt;&gt;&gt; print T(a)</code></pre><p>W tym przypadku słowo "test" jest tłumaczone ale, jeśli jego tłumaczenie nie zostanie znalezione i jeśli system plików jest zapisywalny, to zostanie ono dodane w pliku językowym do listy słów w celu przetłumaczenia.</p><p>Proszę zauważyć, że może to dać w wyniku wiele plików IO i że można to wyłączyć:</p><pre><code class="code">T.is_writable = False</code></pre><p>zabezpieczając T przed dynamiczną aktualizacją plików językowych.</p><h4>Komentarze i tłumaczenia złożone</h4><p>Zdarza się, że ten sam łańcuch tekstowy występujący w różnych kontekstach w aplikacji, wymaga różnych tłumaczeń opartych na kontekście. Aby to umożliwić, można dodać komentarze do oryginalnego łańcucha tekstowego. Komentarze nie będą renderowane ale zostaną wykorzystane przez web2py do określenia najbardziej właściwego tłumaczenia. Na przykład:</p><pre><code class="code">T("hello world ## first occurrence")
T("hello world ## second occurrence")</code></pre><p>Tekst występujący po znakach <code>##</code>, to komentarz.</p><h4>Silnik liczby mnogiej</h4><p>Począwszy od wersji 2.0, web2py zawiera zaawansowany system pluralizacji (PS). Oznacza to, że gdy tekst oznaczony do tłumaczenia zależy od zmiennej numerycznej, to może zostać przetłumaczony na podstawie wartości numerycznej. Na przykład w angielskim możemy zrenderować:</p><pre><code>x book(s)</code></pre><p>z</p><pre><code>a book (x==1)
5 books (x==5)</code></pre><p>W języku angielskim jest jedna liczba pojedyncza i jedna liczba mnoga. Formę liczby mnogiej tworzy się przez dodanie końcówki "-s" lub "-es" albo używając formy wyjątkowej. web2py dostarcza sposób definiowania zasad liczby mnogiej dla każdego języka, jak również wyjątków od domyślnych reguł. W rzeczywistości web2py już zna zasady tworzenia liczby mnogiej dla wielu języków. Wie, na przykład, że w języku słoweńskim są 3 formy liczby mnogiej (dla x==1, x==3 albo x==4 i x&gt;4). Zasady te są zakodowane w pliku "gluon/contrib/plural_rules/*.py" i można tworzyć nowe pliki. Jawne zasady tworzenia liczby mnogiej dla słów są tworzone przez edytowanie plików pluralizacyjnych w interfejsie administracyjnym.</p><p>Domyślnie PS nie jest aktywowany. Jest on wywoływany przez argument <code>symbols</code> funkcji <code>T</code>. Na przykład:</p><pre><code class="code">T("You have %s %%{book}", symbols=10)</code></pre><p>Teraz PS jest aktywowany dla słowa "book" i dla liczby 10. W wyniku w języku angielskim otrzyma się: "You have 10 books". Proszę zwrócić uwagę, że "books" to liczba mnoga rzeczownika "book".</p><p>PS składa się z 3 elementów:</p><ul><li>wyrażenia zastępczego <code>%%{}</code> do zaznaczania słów na wejściu funkcji <code>T</code>;</li><li>reguły rozstrzygająca, którą formę słowa należy zastosować ("rules/plural_rules/*.py");</li><li>słownika z formami liczby mnogiej danego słowa ("app/languages/plural-*.py").</li></ul><p>Wartością symboli może być pojedyncza zmienna, lista (krotka) zmiennych lub słownik.</p><p>Wyrażenie zastępcze <code>%%{}</code> składa sie z 3 elementów:</p><pre><code>%%{[&lt;modifier&gt;]&lt;word&gt;[&lt;parameter&gt;]},</code></pre><p>gdzie:</p><pre><code>&lt;modifier&gt;::= ! | !! | !!!
&lt;word&gt; ::= każde słowo lub fraza w liczbie pojedynczej pisane małymi literami (!)
&lt;parameter&gt; ::= [index] | (key) | (number)</code></pre><p>Na przykład:</p><ul><li><code>%%{word}</code> jest równoważne <code>%%{word[0]}</code> (jeśli nie zostały zastosowane jakieś modyfikatory);</li><li><code>%%{word[index]}</code> stosuje się gdy parametr symbols jest krotką. Wyrażenie symbols[index] daje liczbę używaną do podejmowania decyzji o tym, która forma słowa ma być wybrana;</li><li><code>%%{word(key)}</code> jest używane do pobierania parametru numerycznego z wyrażenia symbols[key];</li><li><code>%%{word(number)}</code> umożliwia bezpośrednie ustawienie <code>number</code> (np.: <code>%%{word(%i)}</code>);</li><li><code>%%{?word?number}</code> zwraca "word" jeśli <code>number==1</code>, w przeciwnym razie zwraca <code>number</code>;</li><li><code>%%{?number} or %%{??number}</code> zwraca <code>number</code> jeśli <code>number!=1</code>, w przeciwnym razie zwraca nothing</li></ul><code>T("blabla %s %%{word}", symbols=var)</code><p><code>%%{word}</code> domyślnie oznacza <code>%%{word[0]}</code>, gdzie <code>[0]</code> jest indeksem elementu w krotce symbols.</p><code>T("blabla %s %s %%{word[1]}", (var1, var2))</code><p>PS zostaje zastosowany odpowiednio do "word" i "var2".</p><p>Można użyć kilka wyrażeń zastępczych <code>%%{}</code> o tym samym indeksie:</p><code>T("%%{this} %%{is} %s %%{book}", var)</code><p>lub</p><code>T("%%{this[0]} %%{is[0]} %s %%{book[0]}", var)</code><p>Jest generowane na:</p><pre><code>var  output
------------------
 1   this is 1 book
 2   these are 2 books
 3   these are 2 books</code></pre><p>Podobnie można przekazać słownik do parametru symbols:</p><pre><code>T("blabla %(var1)s %(wordcnt)s %%{word(wordcnt)}",
  dict(var1="tututu", wordcnt=20))</code></pre><p>co wytworzy:</p><pre><code>blabla tututu 20 words</code></pre><p>Można zamienić "1" na każde słowo, które chce się okreśłic w wyrażeniu zastępczym <code>%%{?word?number}</code>. Na przykład:</p><code>T("%%{this} %%{is} %%{?a?%s} %%{book}", var)</code><p>wytworzy:</p><pre><code>var  output
------------------
 1   this is a book
 2   these are 2 books
 3   these are 3 books
 ...</code></pre><p>Wenątrz <code>%%{...}</code> można też użyć następujące modyfikatory:</p><ul><li><code>!</code> aby kapitalizować tekst (odpowiednik <code>string.capitalize</code>);</li><li><code>!!</code> aby kapitalizować każde słowo (odpowiednik <code>string.title</code>)</li><li><code>!!!</code> aby kapitalizować każdy znak (odpowiednik <code>string.upper</code>)</li></ul><p>Trzeba pamiętać, że można użyć znak ukośnika jako znak ucieczki dla znaków <code>!</code> i <code>?</code>.</p><h4>Tłumaczenia i pluralizacja a MARKMIN</h4><p>Można również użyć zaawansowanej składni MARKMIN wewnątrz ciągów tłumaczeń przez zamienienie</p><pre><code class="code">T("hello world")</code></pre><p>na</p><pre><code>T.M("hello world")</code></pre><p>Teraz łańcuch tekstowy akceptuje znaczniki MARKMIN, jak opisano to w <a href="../05#markmin_markmin_syntax">rozdziale 5</a></p><h3>Ciasteczka</h3><div class="inxx">cookies</div><p>Do obsługi ciasteczek web2py wykorzystuje moduły ciasteczek Pythona.</p><p>Ciasteczka z przeglądarki przechowywane są w <code>request.cookies</code> a ciasteczka przesłane przez serwer znajdują się w <code>response.cookies</code>.</p><p>Ciasteczka można ustawić w następujący sposób:</p><pre><code class="code">response.cookies['mycookie'] = 'somevalue'
response.cookies['mycookie']['expires'] = 24 * 3600
response.cookies['mycookie']['path'] = '/'</code></pre><p>Druga linia informuje przeglądarkę aby zachowała ciasteczko przez 24 godziny. Trzecia linia informuje przeglądarkę, aby przesłała ciasteczko z powrotem do jakiejś aplikacji (ścieżka URL) w bieżącej domenie. Trzeba pamiętać, że jeśli nie określa się ścieżki do ciasteczka, to przeglądarka przyjmie ścieżkę URL z żądania HTTP, tak więc ciasteczko zwracane jest tylko do serwera, gdy żądana jest ta sama ścieżka URL.</p><p>Ciasteczko można zabezpieczyć przez:</p><pre><code class="code">response.cookies['mycookie']['secure'] = True</code></pre><p>Informuje to przeglądarkę aby wysłała ciasteczko z powrotem do serwera tylko poprzez HTTPS a nie HTTP.</p><p>Ciasteczko można pobrać w ten sposób:</p><pre><code class="code">if request.cookies.has_key('mycookie'):
    value = request.cookies['mycookie'].value</code></pre><p>Jeżeli sesje są włączone, web2py w tle ustawia następujące ciasteczko i używa go do obsługi sesji:</p><pre><code class="code">response.cookies[response.session_id_name] = response.session_id
response.cookies[response.session_id_name]['path'] = "/"</code></pre><p>Proszę zwrócić uwagę, że jeśli pojedyncza aplikacja zawiera wiele poddomen i chce się udostępnić sesję pomiędzy wszystkimi poddomenami (np. sub1.yourdomain.com, sub2.yourdomain.com itd.), należy jawnie ustawić domenę ciasteczka sesji w następujący sposób:</p><pre><code class="code">if not request.env.remote_addr in ['127.0.0.1', 'localhost']:
    response.cookies[response.session_id_name]['domain'] = ".yourdomain.com"</code></pre><p>Powyższy sposób może być przydatny, jeśli, na przykład, chce się aby użytkownik mógł się logować równocześnie do wszystkich poddomen.</p><h3>Aplikacja <strong>init</strong></h3><div class="inxx">init</div><p>Podczas wdrażania web2py chce się ustawić domyślną aplikację, czyli aplikację, która będzie uruchamiana przy pustej ścieżce URL, tak jak tu:</p><pre><code class="code">http://127.0.0.1:8000</code></pre><p>Domyślnie, przy pustej ścieżce, web2py wyszukuje aplikacji o nazwie <strong>init</strong>. Jeżeli jej nie znajdzie, to wyszukuje aplikacji <strong>welcome</strong>.</p><div class="inxx">default_application</div><p>Nazwę domyślnej aplikacji można zmienić z <strong>init</strong> na inną, ustawiając odpowiednio <code>default_application</code> w pliku routes.py:</p><pre><code class="code">default_application = "myapp"</code></pre><p>Uwaga: <code>default_application</code> po raz pierwszy pojawiło się w web2py w wersji 1.83.</p><p>Oto cztery sposoby na ustawienie domyślnej aplikacji:</p><ul><li>Wywołanie domyślnej aplikacji "init".</li><li>Ustawienie <code>default_application</code> w routes.py na pożądaną nazwę aplikacji.</li><li>Wykonanie odwołania symbolicznego z "applications/init" do folderu swojej aplikacji.</li><li>Użycie przepisania adresu URL, co omówione jest w następnym rozdziale.</li></ul><h3>Przepisywanie URL</h3><div class="inxx">url rewrite</div><div class="inxx">routes_in</div><div class="inxx">routes_out</div><p>W web2py istnieje możliwość przepisania ścieżki URL przychodzących żądań przed wywołaniem akcji kontrolera (mapowania URL) i odwrotnie, web2py może przepisać ścieżkę URL generowaną przez funkcję <code>URL</code> (odwrotne mapowanie URL). Jednym z powodów dla których trzeba to zrobić jest obsługa starszych adresów URL. Innym powodem może być uproszenie ścieżek i wykonanie skrótów.</p><p>Platforma web2py zawiera dwa odrębne systemy przepisywania URL: łatwy w użyciu system <em>oparty na parametrach</em> mający zastosowanie we większości przypadków i elastyczny system <em>oparty na wzorcach</em> dobry dla bardziej skomplikowanych zastosowań. W celu określenia reguł przepisywania URL, trzeba utworzyć nowy plik w folderze "web2py" o nazwie <code>routes.py</code> (zawartość <code>routes.py</code> będzie zależeć od tego, który z tych dwóch systemów przepisywania zostanie wybrany, tak jak opisano to w nastęþnych dwóch rozdziałach). Te dwa systemy przepisywania nie mogą być mieszane.</p><blockquote>Trzeba pamiętać, że po edytowaniu pliku routes.py trzeba go przeładować. Można to
zrobić jednym z dwóch sposobów: przez ponowne uruchomienie serwera internetowego
albo przez klikniecie przycisku <em>Przeładuj</em> w interfejsie administracyjnym.
Jeśli popełniony został jakiś błąd trasowania, to nie nastąpi przeładowanie.</blockquote><h4>System trasowania oparty na parametrach</h4><p>Router oparty na parametrach (parametryczny) zapewnia łatwy dostęp do różnych gotowych metod przepisywania ścieżek URL. Jego możliwości obejmują:</p><ul><li>Pominięcie w zewnętrznej ścieżce URL (tej tworzonej przez funkcję URL) nazw domyślnej aplikacji, kontrolera i funkcji;</li><li>Odwzorowanie domen (i ewentualnie portów) do aplikacji lub kontrolerów;</li><li>Osadzenie selektora językowego w adresie URL;</li><li>Usuwanie stałych przedrostków z nadchodzących adresów URL i dodawanie ich z powrotem w wychodzących adresach URL;</li><li>Odwzorowywanie plików głównych, takich jak /robots.txt do katalogu plików statycznych (static)  aplikacji.</li></ul><p>Parametryczny router zapewnia również nieco bardziej elastycznej walidacji przychodzących adresów URL.</p><p>Załóżmy, że napisaliśmy aplikację o nazwie <code>myapp</code> i uczyniliśmy ja aplikacją domyślną, tak więc nazwa tej aplikacji nie jest już częścią adresu URL widzianego przez użytkownika. Nasz domyślny kontroler to ciągle <code>default</code>. Chcemy też usunąć nazwę kontrolera z adresu URL widzianego przez użytkownika. Oto co należy wpisać w pliku <code>routes.py</code>:</p><pre><code class="code">routers = dict(
  BASE  = dict(default_application='myapp'),
)</code></pre><p>To jest to. Parametryczny router jest wystarczająco inteligentny, aby wiedzieć jak właściwie przekształcić takie adresy URL jak te:</p><pre><code class="code">http://domain.com/myapp/default/myapp</code></pre><p>lub</p><pre><code class="code">http://domain.com/myapp/myapp/index</code></pre><p>gdzie normalnie skracana ścieżka byłaby dwuznaczna. Jeśli ma się dwie aplikacje, <code>myapp</code> i <code>myapp2</code>, to można uzyskać ten sam efekt i dodatkowo ze ścieżki URL aplikacji <code>myapp2</code> zostanie usunięta nazwa domyślnego kontrolera, gdy będzie to bezpieczne (co ma miejsce w większości przypadków).</p><p>Oto inny przypadek: załóżmy, że chcemy obsługiwać języki w oparciu o URL, gdzie ścieżki URL wyglądają tak:</p><pre><code class="code">http://myapp/en/some/path</code></pre><p>lub (przepisane)</p><pre><code class="code">http://en/some/path</code></pre><p>Oto jak to zrobić:</p><pre><code class="code">routers = dict(
  BASE  = dict(default_application='myapp'),
  myapp = dict(languages=['en', 'it', 'jp'], default_language='en'),
)</code></pre><p>Teraz przychodzący adres URL,  wyglądający tak:</p><pre><code class="code">http:/domain.com/it/some/path</code></pre><p>Będzie kierowany do <code>/myapp/some/path</code>, a request.uri_language zostanie ustawiony na 'it', wymuszając w ten sposób tłumaczenie. Można również obsługiwać statyczne pliki specyficzne dla języka:</p><pre><code class="code">http://domain.com/it/static/filename</code></pre><p>zostanie mapowane do:</p><pre><code class="code">applications/myapp/static/it/filename</code></pre><p>jeśli ten plik istnieje. Jeśli nie, to adresy URL takie jak:</p><pre><code class="code">http://domain.com/it/static/base.css</code></pre><p>będą nadal przekształcane na:</p><pre><code class="code">applications/myapp/static/base.css</code></pre><p>(ponieważ nie istnieje <code>static/it/base.css</code>).</p><p>Tak więc można mieć statyczne pliki specyficzne językowo, włączając w to obrazy, jeśli potrzeba. Obsługiwane jest również mapowanie domenowe:</p><pre><code class="code">routers = dict(
  BASE  = dict(
      domains = {
          'domain1.com' : 'app1',
          'domain2.com' : 'app2',
      }
  ),
)</code></pre><p>robi to, czego oczekiwaliśmy.</p><pre><code class="code">routers = dict(
  BASE  = dict(
      domains = {
          'domain.com:80'  : 'app/insecure',
          'domain.com:443' : 'app/secure',
      }
  ),
)</code></pre><p>Odwzorowuje <code>http://domain.com</code> na kontroler o nazwie <code>insecure</code>, ponieważ dostęp przez <code>HTTPS</code> następuje przez kontroler <code>secure</code>. Alternatywnie można odwzorować różne porty na różne aplikacje, w oczywisty sposób.</p><p>W celu uzyskania więcej informacji proszę zapoznać się z plikiem <a href="https://github.com/web2py/web2py/blob/master/examples/routes.parametric.example.py">"routes.parametric.example.py"</a> umieszczonym w folderze "examples" standardowej dystrybucji web2py.</p><p>Uwaga: System trasowania <em>oparty na parametrach</em> został wprowadzony po raz pierwszy w wersji 1.92.1 web2py.</p><h4>System trasowania oparty na wzorcach</h4><p>Pomimo, że właśnie opisany system trasowania  <em>oparty na parametrach</em> powinien być wystarczający dla większości, alternatywny system trasowania <em>oparty na wzorcach</em> zapewnia pewną dodatkową elastyczność w bardziej złożonych przypadkach. Aby użyć system oparty na wzorcach, zamiast definiowania routerów jako słownika parametrów trasowania, definiuje się dwie listy (lub krotki) dwóch krotek, <code>routes_in</code> i <code>routes_out</code>. Każda krotka zawiera dwa elementy: wzorzec, który ma zostać być zamieniony i ciąg znakowy go zastępujący. Na przykład:</p><pre><code class="code">routes_in = (
  ('/testme', '/examples/default/index'),
)
routes_out = (
  ('/examples/default/index', '/testme'),
)</code></pre><p>Przy tych trasach adres URL:</p><pre><code class="code">http://127.0.0.1:8000/testme</code></pre><p>jest odwzorowywany na:</p><pre><code class="code">http://127.0.0.1:8000/examples/default/index</code></pre><p>Dla odwiedzającego wszystkie odnośniki URL do strony wyglądają podobnie do <code>/testme</code>.</p><p>Wzorce mają taką samą składnie jak wyrażenia regularne Pythona. Na przykład:</p><pre><code class="code">  ('.*.php', '/init/default/index'),</code></pre><p>odwzorowuje wszystkie adresy URL kończące się na ".php" na stronę index.</p><p>W drugim warunku reguły można również dokonać przekierowania do innej strony:</p><pre><code class="code">  ('.*.php', '303-&gt;http://example.com/newpage'),</code></pre><p>Tutaj 303 jest kodem stanu HTTP do przekierowania odpowiedzi.</p><p>Czasem zachodzi potrzeba pozbycia się przedrostka z adresów URL, ponieważ chce się udostępnić tylko jedna aplikację. Można to osiągnąć za pomocą:</p><pre><code class="code">routes_in = (
  ('/(?P&lt;any&gt;.*)', '/init/\g&lt;any&gt;'),
)
routes_out = (
  ('/init/(?P&lt;any&gt;.*)', '/\g&lt;any&gt;'),
)</code></pre><p>Istnieje również alternatywna składnia umożliwiająca mieszanie notacji wyrażeń regularnych ze powyższą składnią. Składa się ona ze zmiennej <code>$name</code> zamiast <code>(?P&lt;name&gt;\w+)</code> czy <code>\g&lt;name&gt;</code>. Na przykład:</p><pre><code class="code">routes_in = (
  ('/$c/$f', '/init/$c/$f'),
)

routes_out = (
  ('/init/$c/$f', '/$c/$f'),
)</code></pre><p>Eliminuje to również przedrostek aplikacji "/example" we wszystkich adresach URL.</p><p>Używając notacji ze zmienną <code>$name</code>, można automatycznie odwzorowac <code>routes_in</code> na <code>routes_out</code>, pod warunkiem, że nie używa się wyrażeń regularnych. Na przykład:</p><pre><code class="code">routes_in = (
  ('/$c/$f', '/init/$c/$f'),
)

routes_out = [(x, y) for (y, x) in routes_in]</code></pre><p>Jeśli istnieje wiele tras, wykonywana jest pierwsza dopasowana ścieżka URL. Jeśli żaden wzorzec nie zostanie dopasowany, tp ścieżka pozostaje nie zmieniona.</p><p>Można użyć zmiennej <code>$anything</code> aby dopasować cokolwiek (<code>.*</code>) aż do końca linii.</p><p>Oto minimalna treść pliku "routes.py" dla obsługi żądań pliku favicon.ico i robots.txt:</p><p><div class="inxx">favicon</div> <div class="inxx">robots</div></p><pre><code class="code">routes_in = (
  ('/favicon.ico', '/examples/static/favicon.ico'),
  ('/robots.txt', '/examples/static/robots.txt'),
)
routes_out = ()</code></pre><p>Oto bardziej złożony przykład udostępniający pojedynczą aplikację "myapp", bez zbędnych przedrostków, ale również interfejsy <strong>admin</strong> i <strong>appadmin</strong> oraz katalog static:</p><pre><code class="code">routes_in = (
  ('/admin/$anything', '/admin/$anything'),
  ('/static/$anything', '/myapp/static/$anything'),
  ('/appadmin/$anything', '/myapp/appadmin/$anything'),
  ('/favicon.ico', '/myapp/static/favicon.ico'),
  ('/robots.txt', '/myapp/static/robots.txt'),
)
routes_out = [(x, y) for (y, x) in routes_in[:-2]]</code></pre><p>Ogólna składnia trasy jest bardzie skomplikowana, niż widzieliśmy to do tej pory. Oto bardziej ogólny i reprezentatywny przykład:</p><pre><code class="code">routes_in = (
 ('140.191.\d+.\d+:https?://www.web2py.com:post /(?P&lt;any&gt;.*).php',
  '/test/default/index?vars=\g&lt;any&gt;'),
)</code></pre><p>Odwzorowuje to <code>http</code> lub <code>https</code> żądań <code>POST</code> (ale nie pisane małymi literami "post") dla hosta <code>www.web2py.com</code> ze zdalnego IP pasującego do wyrażenia regularnego</p><pre><code class="code">'140.191.\d+.\d+'</code></pre><p>żądana strona pasująca do wyrażenia regularnego</p><pre><code class="code">'/(?P&lt;any&gt;.*).php'</code></pre><p>na</p><pre><code class="code">'/test/default/index?vars=\g&lt;any&gt;'</code></pre><p>gdzie <code>\g&lt;any&gt;</code> jest zamieniane przez dopasowanie wyrażenia regularnego.</p><p>Ogólna składnia to</p><pre><code class="code">'[remote address]:[protocol]://[host]:[method] [path]'</code></pre><p>Jeśli brakuje pierwszej sekcji wzorca (wszystko z wyjątkiem <code>[path]</code>), to web2py dostarcza domyślnie:</p><pre><code class="code">'.*?:https?://[^:/]+:[a-z]+'</code></pre><p>Całe wyrażenie jest dopasowywane jako wyrażenie regularne, tak więc znak kropki (.) musi być poprzedzony znakiem ucieczki (znakiem lewego ukośnika) i każde dopasowywane podwyrażenie można przedstawić przy użyciu <code>(?P&lt;...&gt;...)</code> wykorzystując składnię wyrażenia regularnego Pythona. Metoda żądania (zwykle GET lub POST) musi być pisana małymi literami. Adres URL, który jest dopasowywany musi mieć jakiekolwiek wyrażenie ucieczkowe <code>%xx</code> ujęte w znaki cudzysłowu.</p><p>Umożliwia to przekierowanie żądań opartych na adresie IP klienta lub domenie, na typie żądania, na metodzie i na ścieżce. Umożliwia to również, aby web2py odwzorowywał różne wirtualne hosty w różnych aplikacjach. Każde dopasowane podwyrażenie może być użyte do budowy docelowej ścieżki URL i ostatecznie przekazane jako zmienna GET.</p><p>Wszystkie główne serwery internetowe, takie jak Apache czy lighttpd, mają również zdolność przepisywania adresów URL. W środowisku produkcyjnym może to być wykorzystane zamiast <code>routes.py</code>. Cokolwiek się wybierze, zalecamy aby nie kodować na sztywno wewnętrznych ścieżek URL w aplikacji ale do ich generowania używać funkcji URL. Sprawi to, że aplikacja będzie bardziej przenośna w przypadku zmiany tras.</p><h5>Przepisywanie adresów URL specyficzne dla aplikacji</h5><div class="inxx">routes_app</div><p>Gdy stosuje się system trasowania oparty na wzorcach, aplikacja może ustawiać swoje własne trasy w pliku routes.py zlokalizowanym w podstawowym folderze danej aplikacji. Jest to możliwe przez konfigurację <code>routes_app</code> w pliku podstawowym routes.py, tak aby określić skąd ma być wybrana nazwa przychodzącego adresu URL aplikacji. Gdy to nastąpi, będzie używany  plik routes.py danej aplikacji w miejsce podstawowego pliku routes.py.</p><p>Format <code>routes_app</code> jest identyczny z <code>routes_in</code> z tym wyjątkiem, że wymienialny wzorzec jest tylko nazwą aplikacja. Jeśli zastosowanie <code>routes_app</code> do przychodzącego adresu URL z dopasowaniem nazwy aplikacji nie da rezultatu lub wynikowy plik routes.py określonej aplikacji nie zostanie znaleziony, to zostanie użyty bazowy plik routes.py.</p><p>Uwaga: <code>routes_app</code> został zastosowany po raz pierwszy w wersji 1.83 web2py.</p><h5>Domyślna aplikacja, kontroler i funkcja</h5><div class="inxx">default_application</div><div class="inxx">default_controller</div><div class="inxx">default_function</div><p>Gdy używa się systemu trasowania opartego na wzorcach nazwa domyślnej aplikacji, kontrolera i funkcji mogą być zmienione z <strong>init</strong>, <strong>default</strong> czy <strong>index</strong> odpowiednio na inna nazwę, przez odpowiednie ustawienie wartości w routes.py:</p><pre><code class="code">default_application = "myapp"
default_controller = "admin"
default_function = "start"</code></pre><p>Uwaga: Elementy te po raz pierwszy zastosowano w wersji 1.83 web2py.</p><h4>Trasy do stron błędu</h4><div class="inxx">routes_onerror</div><p>You can also use <code>routes.py</code> to re-route requests to special actions in case there is an error on the server. You can specify this mapping globally, for each app, for each error code, or for each app and error code. Here is an example:</p><pre><code class="code">routes_onerror = [
  ('init/400', '/init/default/login'),
  ('init/*', '/init/static/fail.html'),
  ('*/404', '/init/static/cantfind.html'),
  ('*/*', '/init/error/index')
]</code></pre><p>For each tuple, the first string is matched against "[app name]/[error code]". If a match is found, the failed request is re-routed to the URL in the second string of the matching tuple. If the error handling URL is a not a static file, the following GET variables will be passed to the error action:</p><ul><li><code>code</code>: the HTTP status code (e.g., 404, 500)</li><li><code>ticket</code>: in the form of "[app name]/[ticket number]" (or "None" if no ticket)</li><li><code>requested_uri</code>: equivalent to <code>request.env.request_uri</code></li><li><code>request_url</code>: equivalent to <code>request.url</code></li></ul><p>These variables will be accessible to the error handling action via <code>request.vars</code> and can be used in generating the error response. In particular, it is a good idea for the error action to return the original HTTP error code instead of the default 200 (OK) status code. This can be done by setting <code>response.status = request.vars.code</code>. It is also possible to have the error action send (or queue) an email to an administrator, including a link to the ticket in <code>admin</code>.</p><p>Unmatched errors display a default error page. This default error page can also be customized here (see "routes.parametric.example.py" and "routes.patterns.example.py" in the "examples" folder):</p><pre><code class="code">error_message = '&lt;html&gt;&lt;body&gt;&lt;h1&gt;%s&lt;/h1&gt;&lt;/body&gt;&lt;/html&gt;'
error_message_ticket = '''&lt;html&gt;&lt;body&gt;&lt;h1&gt;Internal error&lt;/h1&gt;
     Ticket issued: &lt;a href="/admin/default/ticket/%(ticket)s"
     target="_blank"&gt;%(ticket)s&lt;/a&gt;&lt;/body&gt;&lt;/html&gt;'''</code></pre><p>The first variable contains the error message when an invalid application or function is requested. The second variable contains the error message when a ticket is issued.</p><p><code>routes_onerror</code> work with both routing mechanisms.</p><div class="inxx">error_handler</div><p>In "routes.py" you can also specify an action in charge of error handling:</p><pre><code class="code">error_handler = dict(application='error',
                      controller='default',
                      function='index')</code></pre><p>If the <code>error_handler</code> is specified the action is called without user redirection and the handler action will be in charge of dealing with the error. In the event that the error-handling page itself returns an error, web2py will fall back to its old static responses.</p><h4>Zarządzanie statycznymi aktywami</h4><p>Since version 2.1.0, web2py has the ability to manage static assets.</p><p>When an application is in development, static file can change often, therefore web2py sends static files with no cache headers. This has the side-effect of "forcing" the browser to request static files at every request. This results in low performance when loading the page.</p><p>In a "production" site, you may want to serve static files with <code>cache</code> headers to prevent un-necessary downloads since static files do not change.</p><p><code>cache</code> headers allow the browser to fetch each file only once, thus saving bandwidth and reducing loading time.</p><p>Yet there is a problem: What should the cache headers declare? When should the files expire? When the files are first served, the server cannot forecast when they will be changed.</p><p>A manual approach consists of creating subfolders for different versions of static files. For example an early version of "layout.css" can be made available at the URL "/myapp/static/css/1.2.3/layout.css". When you change the file, you create a new subfolder and you link it as "/myapp/static/css/1.2.4/layout.css".</p><p>This procedure works but it is pedantic since every time you update the css file, you must remember to move it to another folder, change the URL of the file in your layout.html and deploy.</p><p>Static asset management solves the problem by allowing the developer to declare a version for a group of static files and they will be requested again only when the version number changes. The asset version number is made part of the file url as in the previous example. The difference from the previous approach is that the version number only appears in the URL, not in the file system.</p><p>If you want to serve "/myapp/static/layout.css" with the cache headers, you just need to include the file with a modified URL that includes a version number:</p><pre><code>/myapp/static/_1.2.3/layout.css</code></pre><p>(notice the URL defines a version number, it does not appear anywhere else).</p><p>Notice that the URL starts with "/myapp/static/", followed by a version number composed by an underscore and 3 integers separated by a period (as described in <a href="http://semver.org/">SemVer</a>), then followed by the filename. Also notice that you do not have to create a "_1.2.3/" folder.</p><p>Every time the static file is requested with a version in the url, it will be served with "far in the future" cache headers, specifically:</p><pre><code>Cache-Control : max-age=315360000
Expires: Thu, 31 Dec 2037 23:59:59 GMT</code></pre><p>This means that the browser will fetch those files only once, and they will be saved "forever" in the browser's cache.</p><p>Every time the "_1.2.3/filename" is requested, web2py will remove the version part from the path and serve your file with far in the future headers so they will be cached forever. If you changed the version number in the URL, this tricks the browser into thinking it is requesting a different file, and the file is fetched again.</p><p>You can use "_1.2.3", "_0.0.0", "_999.888.888", as long as the version starts with underscore followed by three numbers separated by period.</p><p>When in development, you can use <code>response.files.append(...)</code> to link the static URLs of static files. In this case you can include the "_1.2.3/" part manually, or you take advantage of a new parameter of the response object: <code>response.static_version</code>. Just include the files the way you used to, for example</p><pre><code>{{response.files.append(URL('static','layout.css'))}}</code></pre><p>and in models set</p><pre><code class="code">response.static_version = '1.2.3'</code></pre><p>This will rewrite automatically every "/myapp/static/layout.css" url as "/myapp/static/_1.2.3/layout.css", for every file included in <code>response.files</code>.</p><p>Often in production you let the webserver (apache, nginx, etc.) serve the static files. You need to adjust your configuration in such a way that it will "skip" the "_1.2.3/" part.</p><p>For example, in Apache, change this:</p><pre><code>AliasMatch ^/([^/]+)/static/(.*)    /home/www-data/web2py/applications/$1/static/$2</code></pre><p>into this:</p><pre><code>AliasMatch ^/([^/]+)/static/(?:_[\d]+.[\d]+.[\d]+/)?(.*)    /home/www-data/web2py/applications/$1/static/$2</code></pre><p>Similarly, in Nginx change this:</p><pre><code>location ~* /(\w+)/static/ {
    root /home/www-data/web2py/applications/;
    expires max;
}</code></pre><p>into this:</p><pre><code>location ~* /(\w+)/static(?:/_[\d]+.[\d]+.[\d]+)?/(.*)$ {
   alias /home/www-data/web2py/applications/$1/static/$2;
   expires max;
}</code></pre><h3>Uruchamianie zadań w tle</h3><p>In web2py, every HTTP request is served in its own thread. Threads are recycled for efficiency and managed by the web server. For security, the web server sets a time-out on each request. This means that actions should not run tasks that take too long, should not create new threads, and should not fork processes (it is possible but not recommended).</p><p>The proper way to run time-consuming tasks is doing it in the background. There is not a single way of doing it, but here we describe three mechanisms that are built into web2py: <strong>cron</strong>, <strong>homemade task queues</strong>, and <strong>scheduler</strong>.</p><p>By <strong>cron</strong> we refer to a web2py functionality not to the Unix Cron mechanism. The web2py cron works on windows too.</p><p>web2py cron is the way to go if you need tasks in the background at scheduled times and these tasks take a relatively short time compared to the time interval between two calls. Each task runs in its own process, and multiple tasks can run concurrently, but you have no control over how many tasks run. If accidentally one task overlaps with itself, it can cause a database lock and a spike in memory usage.</p><p>web2py scheduler takes a different approach. The number of running processes is fixed, and they can run on different machines. Each process is called a worker. Each worker picks a task when available and executes it as soon as possible after the time when it is scheduled to run, but not necessarily at that exact time. There cannot be more processes running than the number of scheduled tasks and therefore no memory spikes. Scheduler tasks can be defined in models and are stored in the database. The web2py scheduler does not implement a distributed queue since it assumes that the time to distribute tasks is negligible compared with the time to run the tasks. Workers pick up the task from the database.</p><p>Homemade tasks queues can be a simpler alternative to the web2py scheduler in some cases.</p><h4>Cron</h4><div class="inxx">cron</div><p>The web2py cron provides the ability for applications to execute tasks at preset times, in a platform-independent manner.</p><p>For each application, cron functionality is defined by a crontab file:</p><pre><code>app/cron/crontab</code></pre><p>It follows the syntax defined in ref. <sup>[<a href="/book/default/reference/42/cron" target="_blank">cron</a>]</sup> (with some extensions that are specific to web2py).</p><blockquote>Before web2py 2.1.1, cron was enabled by default and could be disabled with the <code>-N</code> command line option. Since 2.1.1, cron is disabled by default and can be enabled by the <code>-Y</code> option. This change was motivated by the desire to push users toward using the new scheduler (which is superior to the cron mechanism) and also because cron may impact on performance.</blockquote><p>This means that every application can have a separate cron configuration and that cron config can be changed from within web2py without affecting the host OS itself.</p><p>Here is an example:</p><pre><code class="code">0-59/1  *  *  *  *  root python /path/to/python/script.py
30      3  *  *  *  root *applications/admin/cron/db_vacuum.py
*/30    *  *  *  *  root **applications/admin/cron/something.py
@reboot root    *mycontroller/myfunction
@hourly root    *applications/admin/cron/expire_sessions.py</code></pre><p>The last two lines in this example use extensions to regular cron syntax to provide additional web2py functionality.</p><blockquote>The file "applications/admin/cron/expire_sessions.py" actually exists and ships with the <strong>admin</strong> app. It checks for expired sessions and deletes them. "applications/admin/cron/crontab" runs this task hourly.</blockquote><p>If the task/script is prefixed with an asterisk (<code>*</code>) and ends with <code>.py</code>, it will be executed in the web2py environment. This means you will have all the controllers and models at your disposal. If you use two asterisks (<code>**</code>), the models will not be executed. This is the recommended way of calling, as it has less overhead and avoids potential locking problems.</p><p>Notice that scripts/functions executed in the web2py environment require a manual <code>db.commit()</code> at the end of the function or the transaction will be reverted.</p><p>web2py does not generate tickets or meaningful tracebacks in shell mode, which is how cron is run, so make sure that your web2py code runs without errors before you set it up as a cron task as you will likely not be able to see those errors when run from cron. Moreover, be careful how you use models: while the execution happens in a separate process, database locks have to be taken into account in order to avoid pages waiting for cron tasks that may be blocking the database. Use the <code>**</code> syntax if you don't need to use the database in your cron task.</p><p>You can also call a controller function, in which case there is no need to specify a path. The controller and function will be that of the invoking application. Take special care about the caveats listed above. Example:</p><pre><code class="code">*/30  *  *  *  *  root *mycontroller/myfunction</code></pre><p>If you specify <code>@reboot</code> in the first field in the crontab file, the given task will be executed only once, at web2py startup. You can use this feature if you want to pre-cache, check, or initialize data for an application on web2py startup. Note that cron tasks are executed in parallel with the application --- if the application is not ready to serve requests until the cron task is finished, you should implement checks to reflect this. Example:</p><pre><code class="code">@reboot  root *mycontroller/myfunction</code></pre><p>Depending on how you are invoking web2py, there are four modes of operation for web2py cron.</p><ul><li><em>soft cron</em>: available under all execution modes</li><li><em>hard cron</em>: available if using the built-in web server (either directly or via Apache mod_proxy)</li><li><em>external cron</em>: available if you have access to the system's own cron service</li><li>No cron</li></ul><p>The default is hard cron if you are using the built-in web server; in all other cases, the default is soft cron.  Soft cron is the default method if you are using CGI, FASTCGI or WSGI (but note that soft cron is not <code>enabled</code> by default in the standard <code>wsgihandler.py</code> file provided with web2py).</p><p>Your tasks will be executed on the first call (page load) to web2py after the time specified in crontab; but only after processing the page, so no delay will be observed by the user. Obviously, there is some uncertainty regarding precisely when the task will be executed, depending on the traffic the site receives. Also, the cron task may get interrupted if the web server has a page load timeout set. If these limitations are not acceptable, see <em>external cron</em>. Soft cron is a reasonable last resort, but if your web server allows other cron methods, they should be preferred over soft cron.</p><p>Hard cron is the default if you are using the built-in web server (either directly or via Apache mod_proxy). Hard cron is executed in a parallel thread, so unlike soft cron, there are no limitations with regard to run time or execution time precision.</p><p>External cron is not default in any scenario, but requires you to have access to the system cron facilities. It runs in a parallel process, so none of the limitations of soft cron apply. This is the recommended way of using cron under WSGI or FASTCGI.</p><p>Example of line to add to the system crontab, (usually /etc/crontab):</p><pre><code class="code">0-59/1 * * * * web2py cd /var/www/web2py/ &amp;&amp; python web2py.py -J -C -D 1 &gt;&gt; /tmp/cron.output 2&gt;&amp;1</code></pre><p>With external <code>cron</code>, make sure to add either <code>-J</code> (or <code>--cronjob</code>, which is the same) as indicated above so that web2py knows that task is executed by cron. Web2py sets this internally with soft and hard <code>cron</code>.</p><h4>Homemade task queues</h4><p>While cron is useful to run tasks at regular time intervals, it is not always the best solution to run a background task. For this purpose web2py provides the ability to run any python script as if it were inside a controller:</p><pre><code class="code">python web2py.py -S app -M -R applications/app/private/myscript.py -A a b c</code></pre><p>where <code>-S app</code> tells web2py to run "myscript.py" as "app", <code>-M</code> tells web2py to execute models, and <code>-A a b c</code> passes optional command line arguments <code>sys.args=['a','b','c']</code> to "myscript.py".</p><p>This type of background process should not be executed via cron (except perhaps for cron @reboot) because you need to be sure that no more than one instance is running at the same time. With cron it is possible that a process starts at cron iteration 1 and is not completed by cron iteration 2, so cron starts it again, and again, and again - thus jamming the mail server.</p><p>In chapter 8, we will provide an example of how to use the above method to send emails.</p><h4>Terminarz</h4><p>Prior to version 2.6.0 the scheduler was considered experimental. From v2.6.0 the documented API is stable. The stable API consists of these functions:</p><ul><li>disable()</li><li>resume()</li><li>terminate()</li><li>kill()</li><li>queue_task(),</li><li>task_status()</li><li>stop_task()</li></ul><p>The web2py scheduler works very much like the task queue described in the previous sub-section with some differences:</p><ul><li>It provides a standard mechanism for creating, scheduling, and monitoring tasks.</li><li>There is not a single background process but a set of workers processes.</li><li>The job of worker nodes can be monitored because their state, as well as the state of the tasks, is stored in the database.</li><li>It works without web2py but that is not documented here.</li></ul><p>The scheduler does not use cron, although one can use cron @reboot to start the worker nodes.</p><p>More information about deploying the scheduler under Linux and Windows is in the Deployment recipes chapter.</p><p>In the scheduler, a task is simply a function defined in a model (or in a module and imported by a model). For example:</p><pre><code class="code">def task_add(a,b):
    return a+b</code></pre><p>Tasks will always be called in the same environment seen by controllers and therefore they see all the global variables defined in models, including database connections (<code>db</code>). Tasks differ from a controller action because they are not associated with an HTTP request and therefore there is no <code>request.env</code>. Also, tasks can access another environmental variable that is not present in normal requests: <code>W2P_TASK</code>. <code>W2P_TASK.id</code> holds the <code>scheduler_task.id</code> and <code>W2P_TASK.uuid</code> the <code>scheduler_task.uuid</code> field of the task that is running.</p><blockquote>Remember to call <code>db.commit()</code> at the end of every task if it involves inserts/updates to the database. web2py commits by default at the end of a successful action but the scheduler tasks are not actions.</blockquote><p>To enable the scheduler you must instantiate the Scheduler class in a model. The recommended way to enable the scheduler to your app is to create a model file named <code>scheduler.py</code> and define your function there. After the functions, you can put the following code into the model:</p><pre><code class="code">from gluon.scheduler import Scheduler
scheduler = Scheduler(db)</code></pre><p>If your tasks are defined in a module (as opposed to a model) you may have to restart the workers.</p><p>The task is scheduled with</p><pre><code class="code">scheduler.queue_task(task_add,pvars=dict(a=1,b=2))</code></pre><h5>Parametry</h5><p>The first argument of the <code>Scheduler</code> class must be the database to be used by the scheduler to communicate with the workers. This can be the <code>db</code> of the app or another dedicated <code>db</code>, perhaps one shared by multiple apps. If you use SQLite it's recommended to use a separate db from the one used by your app in order to keep the app responsive. Once the tasks are defined and the <code>Scheduler</code> is instantiated, all that is needed to do is to start the workers. You can do that in several ways:</p><pre><code>python web2py.py -K myapp</code></pre><p>starts a worker for the app <code>myapp</code>. If you want start multiple workers for the same app, you can do so just passing <code>myapp,myapp</code>. You can pass also the <code>group_names</code> (overriding the one set in your model) with</p><pre><code>python web2py.py -K myapp:group1:group2,myotherapp:group1</code></pre><p>If you have a model called <code>scheduler.py</code> you can start/stop the workers from web2py's default window (the one you use to set the ip address and the port).</p><h5>Terminarz wdrażania</h5><p>One last nice addition: if you use the embedded webserver, you can start the webserver and the scheduler with just one line of code (this assumes you don't want the web2py window popping up, else you can use the "Schedulers" menu instead)</p><pre><code>python web2py.py -a yourpass -K myapp -X</code></pre><p>You can pass the usual parameters (-i, -p, here -a prevents the window from showing up), pass whatever app in the -K parameter and append a -X. The scheduler will run alongside the webserver!</p><p>Windows users looking to create a service should see the Deployment Recipes chapter.</p><h5>Kompletna sygnatura terminarza</h5><p>Scheduler's complete signature is:</p><pre><code class="code">Scheduler(
    db,
    tasks=None,
    migrate=True,
    worker_name=None,
    group_names=None,
    heartbeat=HEARTBEAT,
    max_empty_runs=0,
    discard_results=False,
    utc_time=False
)</code></pre><p>Let's see them in order:</p><ul><li><code>db</code> is the database DAL instance where you want the scheduler tables be placed.</li><li><code>tasks</code> is a dictionary that maps task names into functions. If you do not pass this parameter, function will be searched in the app environment.</li><li><code>worker_name</code> is None by default. As soon as the worker is started, a worker name is generated as hostname-uuid. If you want to specify that, be sure that it's unique.</li><li><code>group_names</code> is by default set to <strong>[main]</strong>. All tasks have a <code>group_name</code> parameter, set to <strong>main</strong> by default. Workers can only pick up tasks of their assigned group.</li></ul><blockquote>NB: This is useful if you have different workers instances (e.g. on different machines) and you want to assign tasks to a specific worker.

NB2: It's possible to assign a worker more groups, and they can be also all the same, as <code>['mygroup','mygroup']</code>. Tasks will be distributed taking into consideration that a worker with group_names <code>['mygroup','mygroup']</code> is able to process the double of the tasks a worker with group_names <code>['mygroup']</code> is.</blockquote><ul><li><code>heartbeat</code> is by default set to 3 seconds. This parameter is the one controlling how often a scheduler will check its status on the <code>scheduler_worker</code> table and see if there are any <strong>ASSIGNED</strong> tasks to itself to process.</li><li><code>max_empty_runs</code> is 0 by default, that means that the worker will continue to process tasks as soon as they are <strong>ASSIGNED</strong>. If you set this to a value of, let's say, 10, a worker will die automatically if it's <strong>ACTIVE</strong> and no tasks are <strong>ASSIGNED</strong> to it for 10 loops. A loop is when a worker searches for tasks, every 3 seconds (or the set <code>heartbeat</code>)</li><li><code>discard_results</code> is False by default. If set to True, no scheduler_run records will be created.</li></ul><blockquote>NB: scheduler_run records will be created as before for <strong>FAILED</strong>, <strong>TIMEOUT</strong> and <strong>STOPPED</strong> tasks's statuses.</blockquote><ul><li><code>utc_time</code> is False by default. If you need to coordinate with workers living in different timezones, or don't have problems with solar/DST times, supplying datetimes from different countries, etc, you can set this to True. The scheduler will honor the UTC time and work leaving the local time aside. Caveat: you need to schedule tasks with UTC times (for start_time, stop_time, and so on.)</li></ul><p>Now we have the infrastructure in place: defined the tasks, told the scheduler about them, started the worker(s). What remains is to actually schedule the tasks</p><h5>Zadania</h5><p>Tasks can be scheduled programmatically or via appadmin. In fact, a task is scheduled simply by adding an entry in the table "scheduler_task", which you can access via appadmin:</p><pre><code>http://127.0.0.1:8000/myapp/appadmin/insert/db/scheduler_task</code></pre><p>The meaning of the fields in this table is obvious. The "args" and "vars"" fields are the values to be passed to the task in JSON format. In the case of the "task_add" above, an example of "args" and "vars" could be:</p><pre><code class="code">args = [3, 4]
vars = {}</code></pre><p>or</p><pre><code class="code">args = []
vars = {'a':3, 'b':4}</code></pre><p>The <code>scheduler_task</code> table is the one where tasks are organized.</p><p>To add tasks via the API, use</p><pre><code>scheduler.queue_task('mytask',...)</code></pre><p>which is documented <a href="#markmin_queue_task_sig">below</a> .</p><h5>Cykl życia zadania</h5><p>All tasks follow a lifecycle</p><p><p style="text-align:center"><img src="http://127.0.0.1:8000/book/default/image/42/ce8edcc3.png" alt="scheduler tasks" /></p></p><p>By default, when you send a task to the scheduler, it is in the <strong>QUEUED</strong> status. If you need it to be executed later, use the <code>start_time</code> parameter (default = now). If for some reason you need to be sure that the task does not get executed after a certain point in time (maybe a request to a web service that shuts down at 1AM, a mail that needs to be sent not after the working hours, etc...) you can set a <code>stop_time</code> (default = None) for it. If your task is NOT picked up by a worker before <code>stop_time</code>, it will be set as <strong>EXPIRED</strong>. Tasks with no <code>stop_time</code> set or picked up <strong>BEFORE</strong> stop_time are <strong>ASSIGNED</strong> to a worker. When a workers picks up a task, its status is set to <strong>RUNNING</strong>.</p><p><strong>RUNNING</strong> tasks may end up:</p><ul><li><strong>TIMEOUT</strong> when more than <code>n</code> seconds passed with <code>timeout</code> parameter (default = 60 seconds).</li><li><strong>FAILED</strong> when an exception is detected,</li><li><strong>COMPLETED</strong> when they successfully complete.</li></ul><p>Values for <code>start_time</code> and <code>stop_time</code> should be datetime objects. To schedule "mytask" to run at 30 seconds from the current time, for example, you would do the following:</p><pre><code class="code">from datetime import timedelta as timed
scheduler.queue_task('mytask',
    start_time=request.now + timed(seconds=30))</code></pre><p>Additionally, you can control how many times a task should be repeated (i.e. you need to aggregate some data at specified intervals). To do so, set the <code>repeats</code> parameter (default = 1 time only, 0 = unlimited). You can influence how many seconds should pass between executions with the <code>period</code> parameter (default = 60 seconds).</p><blockquote>Default behavior: The time period is not calculated between the END of the first round and the START of the next, but from the START time of the first round to the START time of the next cycle). 
This can cause accumulating 'drift' in the start time of a job.
After v 2.8.2, a new parameter <code>prevent_drift</code> was added, defaulting to False. If set to True when queing a task, the start_time parameter will take precedence over the period, preventing drift.</blockquote><p>You can also set how many times the function can raise an exception (i.e. requesting data from a slow web service) and be queued again instead of stopping in <strong>FAILED</strong>  status using the parameter <code>retry_failed</code> (default = 0, -1 = unlimited).</p><p><p style="text-align:center"><img src="http://127.0.0.1:8000/book/default/image/42/7d8b85e4.png" alt="task repeats" /></p></p><p>Summary: you have</p><ul><li><code>period</code> and <code>repeats</code> to get an automatically rescheduled function</li><li><code>timeout</code> to be sure that a function doesn't exceed a certain amount of time</li><li><code>retry_failed</code> to control how many times the task can "fail"</li><li><code>start_time</code> and <code>stop_time</code> to schedule a function in a restricted timeframe</li></ul><h5><code>queue_task</code> i <code>task_status</code> <span class="anchor" id="markmin_queue_task_sig"></span></h5><p>The method:</p><pre><code class="code">scheduler.queue_task(
    function,
    pargs=[],
    pvars={},
    start_time=now, 		#datetime
    stop_time = None,		#datetime
    timeout = 60,               #seconds
    prevent_drift=False,
    period=60,                  #seconds
    immediate=False,
    repeats = 1
)</code></pre><p>allows you to queue tasks to be executed by workers. It returns a row (see <a href="#markmin_queue_task_return">here</a>), and it takes the following parameters:</p><ul><li><code>function</code> (required): It can be a task name or a reference to an actual function.</li><li><code>pargs</code>: are the arguments to be passed to the task, stored as a Python list.</li><li><code>pvars</code> : are the named arguments to be passed to the task, stored as a Python dictionary.</li><li>all other scheduler_task columns can be passed as keyword arguments; the most important are shown.</li></ul><p>For example:</p><pre><code>scheduler.queue_task('demo1', [1,2])</code></pre><p>does the exact same thing as</p><pre><code class="code">scheduler.queue_task('demo1', pvars={'a':1, 'b':2})</code></pre><p>as</p><pre><code class="code">st.validate_and_insert(function_name='demo1', args=json.dumps([1,2]))</code></pre><p>and as:</p><pre><code class="code">st.validate_and_insert(function_name='demo1', vars=json.dumps({'a':1,'b':2}))</code></pre><p>Here is a more complex complete example:</p><pre><code class="code">def task_add(a,b):
    return a+b

scheduler = Scheduler(db, tasks=dict(demo1=task_add))

scheduler.queue_task('demo1', pvars=dict(a=1,b=2),
                     repeats = 0, period = 180)</code></pre><p>Since version 2.4.1 if you pass an additional parameter <code>immediate=True</code> it will force the main worker to reassign tasks. Until 2.4.1, the worker checks for new tasks every 5 cycles (so, <code>5*heartbeats</code> seconds). If you had an app that needed to check frequently for new tasks, to get a <em>snappy</em> behaviour you were forced to lower the <code>heartbeat</code> parameter, putting the db under pressure for no reason. With <code>immediate=True</code> you can force the check for new tasks: it will happen at most as <code>heartbeat</code> seconds are passed</p><p>A call to <code>scheduler.queue_task</code> returns the task <code>id</code> and <code>uuid</code> of the task you queued (can be the one you passed or the auto-generated one), and possible <code>errors</code>: <span class="anchor" id="markmin_queue_task_return"></span></p><pre><code>&lt;Row {'errors': {}, 'id': 1, 'uuid': '08e6433a-cf07-4cea-a4cb-01f16ae5f414'}&gt;</code></pre><p>If there are errors (usually syntax error or input validation errors), you get the result of the validation, and id and uuid will be None</p><pre><code>&lt;Row {'errors': {'period': 'enter an integer greater than or equal to 0'}, 'id': None, 'uuid': None}&gt;</code></pre><h5>Wyniki i dane wyjściowe</h5><p>The table "scheduler_run" stores the status of all running tasks. Each record references a task that has been picked up by a worker.  One task can have multiple runs. For example, a task scheduled to repeat 10 times an hour will probably have 10 runs (unless one fails or they take longer than 1 hour). Beware that if the task has no return values, it is removed from the scheduler_run table as soon as it is finished.</p><p>Possible run statuses are:</p><pre><code>RUNNING, COMPLETED, FAILED, TIMEOUT</code></pre><p>If the run is completed, no exceptions are thrown, and there is no task timeout, the run is marked as <code>COMPLETED</code> and the task is marked as <code>QUEUED</code> or <code>COMPLETED</code> depending on whether it is supposed to run again at a later time. The output of the task is serialized in JSON and stored in the run record.</p><p>When a <code>RUNNING</code> task throws an exception, the run is mark as <code>FAILED</code> and the task is marked as <code>FAILED</code>. The traceback is stored in the run record.</p><p>Similarly, when a run exceeds the timeout, it is stopped and marked as <code>TIMEOUT</code>, and the task is marked as <code>TIMEOUT</code>.</p><p>In any case, the stdout is captured and also logged into the run record.</p><p>Using appadmin, one can check all <code>RUNNING</code> tasks, the output of <code>COMPLETED</code> tasks, the error of <code>FAILED</code> tasks, etc.</p><p>The scheduler also creates one more table called "scheduler_worker", which stores the workers' heartbeat and their status.</p><h5>Zarządzanie procesami</h5><p>Worker fine management is hard. This module tries not to leave behind any platform (Mac, Win, Linux) .</p><p>When you start a worker, you may later want to:</p><ul><li>kill it "no matter what it's doing"</li><li>kill it only if it is not processing tasks</li><li>put it to sleep</li></ul><p>Maybe you have yet some tasks queued, and you want to save some resources. You know you want them processed every hour, so, you'll want to:</p><ul><li>process all queued tasks and die automatically</li></ul><p>All of these things are possible managing <code>Scheduler</code> parameters or the <code>scheduler_worker</code> table. To be more precise, for started workers you can change the <code>status</code> value of any worker to influence its behavior. As for tasks, workers can be in one of the following statuses: ACTIVE, DISABLED, TERMINATE or KILLED.</p><p><strong>ACTIVE</strong> and <strong>DISABLED</strong> are "persistent", while <strong>TERMINATE</strong> or <strong>KILL</strong>, as statuses name suggest, are more "commands" than real statuses. Hitting ctrl+c is equal to set a worker to <strong>KILL</strong></p><p><p style="text-align:center"><img src="http://127.0.0.1:8000/book/default/image/42/bd891eed.png" alt="workers statuses" /></p></p><p>There are a few commodity functions since version 2.4.1 (self-explanatory)</p><pre><code class="code">scheduler.disable()
scheduler.resume()
scheduler.terminate()
scheduler.kill()</code></pre><p>each function take an optional parameter, that can be a string or a list, to manage workers based on their <code>group_names</code>. It defaults to the <code>group_names</code> defined in the scheduler istantiation.</p><p>An example is better than a thousand words: <code>scheduler.terminate('high_prio')</code> will TERMINATE all the workers that are processing the <code>high_prio</code> tasks, while <code>scheduler.terminate(['high_prio', 'low_prio'])</code> will terminate all <code>high_prio</code> and <code>low_prio</code> workers.</p><blockquote>Watch out: if you have a worker processing <code>high_prio</code> and <code>low_prio</code>, <code>scheduler.terminate('high_prio')</code> will terminate the worker alltogether, even if you didn't want to terminate <code>low_prio</code> too.</blockquote><p>Everything that one can do via appadmin one can do programmatically by inserting and updating records in these tables.</p><p>Anyway, one should not update records relative to <code>RUNNING</code> tasks as this may create an un-expected behavior. The best practice is to queue tasks using the "queue_task" method.</p><p>For example:</p><pre><code class="code">scheduler.queue_task(
    function_name='task_add',
    pargs=[],
    pvars={'a':3,'b':4},
    repeats = 10, # run 10 times
    period = 3600, # every 1h
    timeout = 120, # should take less than 120 seconds
    )</code></pre><p>Notice that fields "times_run", "last_run_time" and "assigned_worker_name" are not provided at schedule time but are filled automatically by the workers.</p><p>You can also retrieve the output of completed tasks:</p><pre><code class="code">completed_runs = db(db.scheduler_run.run_status='COMPLETED').select()</code></pre><blockquote>The scheduler is considered experimental because it needs more extensive testing and because the table structure may change as more features are added.</blockquote><h5>Procentowe raportowanie</h5><p>A special "word" encountered in the print statements of your functions clear all the previous output. That word is <code>!clear!</code>. This, coupled with the <code>sync_output</code> parameter, allows to report percentages.</p><p>Here is an example:</p><pre><code>def reporting_percentages():
    time.sleep(5)
    print '50%'
    time.sleep(5)
    print '!clear!100%'
    return 1</code></pre><p>The function <code>reporting_percentages</code> sleeps for 5 seconds, outputs <code>50%</code>. Then, it sleeps other 5 seconds and outputs <code>100%</code>. Note that the output in the scheduler_run table is synced every 2 seconds and that the second print statement that contains <code>!clear!100%</code> gets the <code>50%</code> output cleared and replaced by <code>100%</code> only.</p><pre><code class="code">scheduler.queue_task(reporting_percentages,
                     sync_output=2)</code></pre><h3>Moduły osób trzecich</h3><div class="inxx">import</div><p>web2py is written in Python, so it can import and use any Python module, including third party modules. It just needs to be able to find them. As with any Python application, modules can be installed in the official Python "site-packages" directory, and they can then be imported from anywhere inside your code.</p><p>Modules in the "site-packages" directory are, as the name suggests, site-level packages. Applications requiring site-packages are not portable unless these modules are installed separately. The advantage of having modules in "site-packages" is that multiple applications can share them. Let's consider, for example, the plotting package called "matplotlib". You can install it from the shell using the PEAK <code>easy_install</code> command <sup>[<a href="/book/default/reference/42/easy-install" target="_blank">easy-install</a>]</sup> (or its modern replacement <code>pip</code> <sup>[<a href="/book/default/reference/42/PIP" target="_blank">PIP</a>]</sup> ):</p><pre><code class="code">easy_install py-matplotlib</code></pre><p>and then you can import it into any model/controller/view with:</p><pre><code class="code">import matplotlib</code></pre><p>The web2py source distribution, and the Windows binary distribution has a site-packages in the top-level folder. The Mac binary distribution has a site-packages folder in the folder:</p><code class="code">web2py.app/Contents/Resources/site-packages</code><p>The problem with using site-packages is that it becomes difficult to use different versions of a single module at the same time, for example there could be two applications but each one uses a different version of the same file.  In this example, <code>sys.path</code> cannot be altered because it would affect both applications.</p><p>For this kind of situation, web2py provides another way to import modules in such a way that the global <code>sys.path</code> is not altered: by placing them in the "modules" folder of an application. One side benefit is that the module will be automatically copied and distributed with the application.</p><blockquote>Once a module "mymodule.py" is placed into an app "modules/" folder, it can be imported from anywhere inside a web2py application (without need to alter <code>sys.path</code> with):
<pre><code>import mymodule</code></pre></blockquote><h3>Środowisko wykonawcze</h3><div class="inxx">exec_environment</div><blockquote>While everything discussed here works fine, we recommend instead building your application using components, as described in chapter 12.</blockquote><p>web2py model and controller files are not Python modules in that they cannot be imported using the Python <code>import</code> statement. The reason for this is that models and controllers are designed to be executed in a prepared environment that has been pre-populated with web2py global objects (request, response, session, cache and T) and helper functions. This is necessary because Python is a statically (lexically) scoped language, whereas the web2py environment is created dynamically.</p><p>web2py provides the <code>exec_environment</code> function to allow you to access models and controllers directly. <code>exec_environment</code> creates a web2py execution environment, loads the file into it and then returns a Storage object containing the environment. The Storage object also serves as a namespace mechanism. Any Python file designed to be executed in the execution environment can be loaded using <code>exec_environment</code>. Uses for <code>exec_environment</code> include:</p><ul><li>Accessing data (models) from other applications.</li><li>Accessing global objects from other models or controllers.</li><li>Executing controller functions from other controllers.</li><li>Loading site-wide helper libraries.</li></ul><p>This example reads rows from the <code>user</code> table in the <code>cas</code> application:</p><pre><code class="code">from gluon.shell import exec_environment
cas = exec_environment('applications/cas/models/db.py')
rows = cas.db().select(cas.db.user.ALL)</code></pre><p>Another example: suppose you have a controller "other.py" that contains:</p><pre><code class="code">def some_action():
    return dict(remote_addr=request.env.remote_addr)</code></pre><p>Here is how you can call this action from another controller (or from the web2py shell):</p><pre><code class="code">from gluon.shell import exec_environment
other = exec_environment('applications/app/controllers/other.py', request=request)
result = other.some_action()</code></pre><p>In line 2, <code>request=request</code> is optional. It has the effect of passing the current request to the environment of "other". Without this argument, the environment would contain a new and empty (apart from <code>request.folder</code>) request object. It is also possible to pass a response and a session object to <code>exec_environment</code>. Be careful when passing request, response and session objects --- modification by the called action or coding dependencies in the called action could lead to unexpected side effects.</p><p>The function call in line 3 does not execute the view; it simply returns the dictionary unless <code>response.render</code> is called explicitly by "some_action".</p><p>One final caution: don't use <code>exec_environment</code> inappropriately. If you want the results of actions in another application, you probably should implement an XML-RPC API (implementing an XML-RPC API with web2py is almost trivial). Don't use <code>exec_environment</code> as a redirection mechanism; use the <code>redirect</code> helper.</p><h3>Współpraca</h3><div class="inxx">cooperation</div><p>There are many ways applications can cooperate:</p><ul><li>Applications can connect to the same database and thus share tables. It is not necessary that all tables in the database are defined by all applications, but they must be defined by those applications that use them. All applications that use the same table, but one, must define the table with <code>migrate=False</code>.</li><li>Applications can embed components from other applications using the LOAD helper (described in Chapter 12).</li><li>Applications can share sessions.</li><li>Applications can call each other's actions remotely via XML-RPC.</li><li>Applications can access each other's files via the filesystem (assuming they share the same filesystem).</li><li>Applications can call each other's actions locally using <code>exec_environment</code> as discussed above.</li><li>Applications can import each other's modules using the syntax:</li></ul><pre><code class="code">from applications.otherapp.modules import mymodule</code></pre><p>or</p><pre><code class="code">import applications.otherapp.modules.othermodule</code></pre><ul><li>Applications can import any module in the <code>PYTHONPATH</code> search path, <code>sys.path</code>.</li></ul><p>One app can load the session of another app using the command:</p><pre><code class="code">session.connect(request, response, masterapp='appname', db=db)</code></pre><p>Here "appname" is the name of the master application, the one that sets the initial session_id in the cookie. <code>db</code> is a database connection to the database that contains the session table (<code>web2py_session</code>). All apps that share sessions must use the same database for session storage.</p><h3>Rejestrowanie zdarzeń</h3><p>Python provides logging APIs. Web2py provides a mechanism to configure it so that apps can use it.</p><p>In your application, you can create a logger, for example in a model:</p><pre><code class="code">import logging
logger = logging.getLogger("web2py.app.myapp")
logger.setLevel(logging.DEBUG)</code></pre><p>and you can use it to log messages of various importance</p><pre><code class="code">logger.debug("Just checking that %s" % details)
logger.info("You ought to know that %s" % details)
logger.warn("Mind that %s" % details)
logger.error("Oops, something bad happened %s" % details)</code></pre><p><code>logging</code> is a standard python module described here:</p><pre><code>http://docs.python.org/library/logging.html</code></pre><p>The string "web2py.app.myapp" defines an app-level logger.</p><p>For this to work properly, you need a configuration file for the logger. One is provided by web2py in the "examples" folder "logging.example.conf". You need to copy the file to web2py's directory and rename the file to "logging.conf" and customize it as necessary.</p><p>This file is self documenting, so you should open it and read it.</p><p>To create a configurable logger for application "myapp", you must add myapp to the [loggers] keys list:</p><pre><code class="code">[loggers]
keys=root,rocket,markdown,web2py,rewrite,app,welcome,myapp</code></pre><p>and you must add a [logger_myapp] section, using [logger_welcome] as a starting point.</p><pre><code class="code">[logger_myapp]
level=WARNING
qualname=web2py.app.myapp
handlers=consoleHandler
propagate=0</code></pre><p>The "handlers" directive specifies the type of logging and here it is logging "myapp" to the console.</p><h3>WSGI</h3><div class="inxx">WSGI</div><p>web2py and WSGI have a love-hate relationship. Our perspective is that WSGI was developed as a protocol to connect web servers to web applications in a portable way, and we use it for that purpose. web2py at its core is a WSGI application: <code>gluon.main.wsgibase</code>. Some developers have pushed WSGI to its limits as a protocol for middleware communications and develop web applications as an onion with many layers (each layer being a WSGI middleware developed independently of the entire framework). web2py does not adopt this structure internally. This is because we feel the core functionality of a frameworks (handling cookies, session, errors, transactions, dispatching) can be better optimized for speed and security if they are handled by a single comprehensive layer.</p><p>Yet web2py allows you to use third party WSGI applications and middleware in three ways (and their combinations):</p><ul><li>You can edit the file "wsgihandler.py" and include any third party WSGI middleware.</li><li>You can connect third party WSGI middleware to any specific action in your apps.</li><li>You can call a third party WSGI app from your actions.</li></ul><p>The only limitation is that you cannot use third party middleware to replace core web2py functions.</p><h4>Zewnętrzna warstwa pośrednia</h4><p>Consider the file "wsgibase.py":</p><pre><code class="code">#...
LOGGING = False
#...
if LOGGING:
    application = gluon.main.appfactory(wsgiapp=gluon.main.wsgibase,
                                        logfilename='httpserver.log',
                                        profilerfilename=None)
else:
    application = gluon.main.wsgibase</code></pre><p>When <code>LOGGING</code> is set to <code>True</code>, <code>gluon.main.wsgibase</code> is wrapped by the middleware function <code>gluon.main.appfactory</code>. It provides logging to the "httpserver.log" file. In a similar fashion you can add any third party middleware. We refer to the official WSGI documentation for more details.</p><h4>Wewnętrzna warstwa pośrednia</h4><p>Given any action in your controllers (for example <code>index</code>) and any third party middleware application (for example <code>MyMiddleware</code>, which converts output to upper case), you can use a web2py decorator to apply the middleware to that action. Here is an example:</p><pre><code class="code">class MyMiddleware:
    """converts output to upper case"""
    def __init__(self,app):
        self.app = app
    def __call__(self, environ, start_response):
        items = self.app(environ, start_response)
        return [item.upper() for item in items]

@request.wsgi.middleware(MyMiddleware)
def index():
    return 'hello world'</code></pre><p>We cannot promise that all third party middleware will work with this mechanism.</p><h4>Wywoływanie aplikacji <em>WSGI</em></h4><p>It is easy to call WSGI app from a web2py action. Here is an example:</p><pre><code class="code">def test_wsgi_app(environ, start_response):
    """this is a test WSGI app"""
    status = '200 OK'
    response_headers = [('Content-type','text/plain'),
                        ('Content-Length','13')]
    start_response(status, response_headers)
    return ['hello world!\n']

def index():
    """a test action that calls the previous app and escapes output"""
    items = test_wsgi_app(request.wsgi.environ,
                          request.wsgi.start_response)
    for item in items:
        response.write(item,escape=False)
    return response.body.getvalue()</code></pre><p>In this case, the <code>index</code> action calls <code>test_wsgi_app</code> and escapes the returned value before returning it. Notice that <code>index</code> is not itself a WSGI app and it must use the normal web2py API (such as <code>response.write</code> to write to the socket).</p>