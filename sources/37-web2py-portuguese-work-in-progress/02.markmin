## A linguagem Python
``Python``:inxx

### Sobre Python
Python é uma linguagem de programação de alto nível e de propósito geral.
Sua filosofia de design enfatiza a produtividade do programador e a legibilidade do código. Tem uma sintaxe de núcleo minimalista com muito poucos comandos básicos e semântica simples, porém também conta com uma vasta e compreensível biblioteca padrão, incluindo uma Interface de Programação de Aplicação (API) ``API``:inxx para muitas das funções subjacentes do sistema operacional (SO). O código Python, enquanto minimalista, define objetos internos, como listas vinculadas (``list``), tuplas (``tuple``), tabelas hash (``dict``), e inteiros abitrariamente longos (``long``).

Python suporta múltiplos paradigmas de programação, incluindo orientação a objetos (``class``), imperativa (``def``), e programação funcional (``lambda``). Python tem um sistema de tipagem dinâmica e gerenciamento de memória automático que usa contagem de referências (similar à Perl, Ruby, e Scheme).

Python foi lançado inicialmente por Guido van Rossum em 1991. A linguagem possui um modelo de desenvolvimento aberto e baseado na comunidade, gerenciado pela fundação, sem fins lucrativos, Python Software Foundation. Existem muitos interpretadores e compiladores que implementam a linguagem Python, incluindo um em Java (Jython), mas, nesta breve revisão, nos referimos à implementação da referência C criada por Guido.

Você pode encontrar muitos tutoriais, a documentação oficial e as referências bibliográficas da linguagem no site oficial do Python.``python``:cite

Para referências adicionais sobre Python, podemos recomendar os livros em ref.``guido``:cite  e ref.``lutz``:cite .

Você pode ignorar este capítulo se você já está familiarizado com a linguagem Python.

### Iniciando
``shell``:inxx
As distribuições binárias do web2py para o Microsoft Windows ou Apple OS X são fornecidas com o interpretador Python incorporado no próprio arquivo de distribuição.

Você pode iniciá-lo no Windows com o seguinte comando (digite no prompt do DOS):
``
web2py.exe -S welcome
``:code

No Apple OS X, digite o seguinte comando em uma janela do Terminal (supondo que você esteja na mesma pasta que web2py.app):
``
./web2py.app/Contents/MacOS/web2py -S welcome
``:code

Em um Linux ou outro ambiente Unix, é provável que você já tenha o Python instalado. Em caso afirmativo, em um prompt do shell, digite:
``
python web2py.py -S welcome
``:code

Se você não possui o Python 2.5 (ou posterior 2.x) já instalado, você terá que fazer o download e instalá-lo antes de executar o web2py.

A opção de linha de comando ``-S welcome`` instrui o web2py a executar o shell interativo como se os comandos fossem executados em um controlador para a aplicação ** welcome **, a aplicação scaffolding web2py. Isso expõe quase todas as classes, objetos e funções do web2py. Esta é a única diferença entre a linha de comando interativa web2py e a linha de comando normal do Python.

A interface administrativa também fornece um shell baseado na web para cada aplicação. Você pode acessar a aplicação "welcome" em.
``
http://127.0.0.1:8000/admin/shell/index/welcome
``:code

Você pode experimentar todos os exemplos neste capítulo usando o shell normal ou o shell baseado na web.

### help, dir
``help``:inxx ``dir``:inxx

A linguagem Python fornece dois comandos para obter documentação sobre objetos definidos no escopo atual, ambos integrados e definidos pelo usuário.

Podemos pedir ajuda (``help``) sobre um objeto, por exemplo "1":
``
>>> help(1)
Help on int object:

class int(object)
 |  int(x[, base]) -> integer
 |
 |  Convert a string or number to an integer, if possible.  A floating point
 |  argument will be truncated towards zero (this does not include a string
 |  representation of a floating point number!)  When converting a string, use
 |  the optional base.  It is an error to supply a base when converting a
 |  non-string. If the argument is outside the integer range a long object
 |  will be returned instead.
 |
 |  Methods defined here:
 |
 |  __abs__(...)
 |      x.__abs__() <==> abs(x)
...
``:code

e, como "1" é um número inteiro, obtemos uma descrição sobre a classe ``int`` e todos os seus métodos. Aqui, a saída foi truncada porque é muito longa e detalhada.

Da mesma forma, podemos obter uma lista de métodos do objeto "1" com o comando ``dir``:
``
>>> dir(1)
['__abs__', ..., '__xor__']
``:code

### Tipos
``type``:inxx
Python é uma linguagem dinamicamente tipada, o que significa que as variáveis não têm um tipo e, portanto, não precisam ser declaradas. Os valores, por outro lado, têm um tipo. Você pode consultar uma variável para o tipo de valor que contém:
``
>>> a = 3
>>> print type(a)
<type 'int'>
>>> a = 3.14
>>> print type(a)
<type 'float'>
>>> a = 'hello python'
>>> print type(a)
<type 'str'>
``:code

O Python também inclui, nativamente, estruturas de dados como listas e dicionários.

#### ``str``
``str``:inxx ``ASCII``:inxx ``UTF8``:inxx ``Unicode``:inxx ``encode``:inxx

Python suporta o uso de dois tipos diferentes de strings: strings ASCII e strings Unicode. As strings ASCII são delimitadas por '...', "..." or by '''..''' or """...""". Aspas triplas delimitam strings multilinhas. Strings Unicode são iniciadas com um ``u`` seguido por uma string contendo caracteres Unicode. Uma string Unicode pode ser convertida em uma string ASCII, escolhendo-se uma codificação, por exemplo:
``
>>> a = 'esta é uma string ASCII'
>>> b = u'Esta é uma string Unicode'
>>> a = b.encode('utf8')
``:code

Depois de executar esses três comandos, a resultante ``a`` é uma string ASCII que armazena caracteres codificados em UTF8. Por design, o web2py usa internamente strings codificadas em UTF8.

Também é possível escrever variáveis em strings de várias maneiras:
``
>>> print 'número é ' + str(3)
número é 3
>>> print 'número é %s' % (3)
número é 3
>>> print 'número é %(number)s' % dict(number=3)
número é 3
``:code

A última notação é mais explícita e menos propensa a erros, e é preferível.

Muitos objetos Python, por exemplo números, podem ser serializados em strings usando ``str`` or ``repr``. Esses dois comandos são muito semelhantes, mas produzem saídas ligeiramente diferentes. Por exemplo:
``
>>> for i in [3, 'olá']:
        print str(i), repr(i)
3 3
olá 'olá'
``:code

Para classes definidas pelo usuário, ``str`` and ``repr`` podem ser definidos/redefinidos usando os operadores especiais ``__str__`` and ``__repr__``. Estes são brevemente descritos mais tarde; Para mais, consulte a documentação oficial do Python``pydocs``:cite . ``repr`` sempre tem um valor padrão.

Outra característica importante de uma string Python é que, como uma lista, ela é um objeto iterável.
``
>>> for i in 'olá':
        print i
o
l
á
``:code

#### ``list``
``list``:inxx

Os principais métodos de uma lista Python são append, insert, e delete:
``
>>> a = [1, 2, 3]
>>> print type(a)
<type 'list'>
>>> a.append(8)
>>> a.insert(2, 7)
>>> del a[0]
>>> print a
[2, 7, 3, 8]
>>> print len(a)
4
``:code

Listas podem ser fatiadas:
``
>>> print a[:3]
[2, 7, 3]
>>> print a[1:]
[7, 3, 8]
>>> print a[-2:]
[3, 8]
``:code

e concatenadas:
``
>>> a = [2, 3]
>>> b = [5, 6]
>>> print a + b
[2, 3, 5, 6]
``:code

Uma lista é iterável; você pode fazer um loop por ela:
``
>>> a = [1, 2, 3]
>>> for i in a:
        print i
1
2
3
``:code

Os elementos de uma lista não precisam ser do mesmo tipo; eles podem ser qualquer tipo de objeto Python.

Existe uma situação muito comum na qual uma "list comprehension" pode ser usada. Considere o seguinte código:
``
>>> a = [1,2,3,4,5]
>>> b = []
>>> for x in a:
        if x % 2 == 0:
            b.append(x * 3)
>>> b
[6, 12]
``:code

Este código processa claramente uma lista de itens, seleciona e modifica um subconjunto da lista de entrada e cria uma nova lista de resultados, e esse código pode ser completamente substituído pela seguinte list comprehension:
``
>>> a = [1,2,3,4,5]
>>> b = [x * 3 for x in a if x % 2 == 0]
>>> b
[6, 12]
``:code

#### ``tuple``
``tuple``:inxx

Uma tupla é como uma lista, mas seu tamanho e elementos são imutáveis, enquanto que em uma lista são mutáveis. Se um elemento de tupla é um objeto, os atributos do objeto são mutáveis. Uma tupla é delimitada por parênteses.
``
>>> a = (1, 2, 3)
``:code

Então, enquanto isso funciona para uma lista:
``
>>> a = [1, 2, 3]
>>> a[1] = 5
>>> print a
[1, 5, 3]
``:code

a atribuição de elementos não funciona para uma tupla:
``
>>> a = (1, 2, 3)
>>> print a[1]
2
>>> a[1] = 5
Traceback (most recent call last):
  File "<stdin>", line 1, in <module>
TypeError: 'tuple' object does not support item assignment
``:code

Uma tupla, como uma lista, é um objeto iterável. Observe que uma tupla constituída por um único elemento deve incluir uma vírgula posterior, como mostrado abaixo:
``
>>> a = (1)
>>> print type(a)
<type 'int'>
>>> a = (1,)
>>> print type(a)
<type 'tuple'>
``:code

Tuplas são muito úteis para a embalagem eficiente de objetos devido à sua imutabilidade, e os parênteses geralmente são opcionais:
``
>>> a = 2, 3, 'olá'
>>> x, y, z = a
>>> print x
2
>>> print z
olá
``:code

#### ``dict``
``dict``:inxx

Um dicionário Python (``dict``) é uma tabela hash que mapeia um ojeto chave a um objeto valor. Por exemplo:
``
>>> a = {'k':'v', 'k2':3}
>>> a['k']
v
>>> a['k2']
3
>>> a.has_key('k')
True
>>> a.has_key('v')
False
``:code

As chaves podem ser de qualquer tipo hasheável (int, string ou qualquer objeto cuja classe implemente o método `` __hash__``). Valores podem ser de qualquer tipo. Diferentes chaves e valores no mesmo dicionário não precisam ser do mesmo tipo. Se as chaves são caracteres alfanuméricos, um dicionário também pode ser declarado com a sintaxe alternativa:
``
>>> a = dict(k='v', h2=3)
>>> a['k']
v
>>> print a
{'k':'v', 'h2':3}
``:code

Métodos úteis são ``has_key``, ``keys``, ``values`` e ``items``:
``
>>> a = dict(k='v', k2=3)
>>> print a.keys()
['k', 'k2']
>>> print a.values()
['v', 3]
>>> print a.items()
[('k', 'v'), ('k2', 3)]
``:code

O método ``items`` produz uma lista de tuplas, cada uma contendo uma chave e seu valor associado.

Os elementos de um dicionário e os elementos de uma lista podem ser excluídos com o comando ``del``:
``
>>> a = [1, 2, 3]
>>> del a[1]
>>> print a
[1, 3]
>>> a = dict(k='v', h2=3)
>>> del a['h2']
>>> print a
{'k':'v'}
``:code

Internamente, Python usa o operador ``hash`` para converter objetos em inteiros e usa esse inteiro para determinar onde armazenar o valor.
``
>>> hash("olá mundo")
-1500746465
``:code

### Sobre indentação

Python usa indentação para delimitar blocos de código. Um bloco começa com uma linha que termina em dois pontos, e continua por todas as linhas que têm uma indentação semelhante ou maior que a próxima linha. Por exemplo:
``
>>> i = 0
>>> while i < 3:
>>>    print i
>>>    i = i + 1
>>>
0
1
2
``:code

É comum usar quatro espaços para cada nível de indentação.
É uma boa política não misturar tabulações com espaços, o que pode resultar em confusão (invisível).

### ``for...in``
``for``:inxx
In Python, you can loop over iterable objects:
``
>>> a = [0, 1, 'hello', 'python']
>>> for i in a:
        print i
0
1
hello
python
``:code

One common shortcut is ``xrange``,
which generates an iterable range without storing the entire list of elements.
``
>>> for i in xrange(0, 4):
        print i
0
1
2
3
``:code

This is equivalent to the C/C++/C#/Java syntax:
``
for(int i=0; i<4; i=i+1) { print(i); }
``:code

Another useful command is ``enumerate``, which counts while looping:
``
>>> a = [0, 1, 'hello', 'python']
>>> for i, j in enumerate(a):
        print i, j
0 0
1 1
2 hello
3 python
``:code

There is also a keyword ``range(a, b, c)`` that returns a list of integers starting with the value ``a``, incrementing by ``c``, and ending with the last value smaller than ``b``,  ``a`` defaults to 0 and ``c`` defaults to 1. ``xrange`` is similar but does not actually generate the list, only an iterator over the list; thus it is better for looping.

You can jump out of a loop using ``break``
``
>>> for i in [1, 2, 3]:
         print i
         break
1
``:code

You can jump to the next loop iteration without executing the entire code block with ``continue``
``
>>> for i in [1, 2, 3]:
         print i
         continue
         print 'test'
1
2
3
``:code

### ``while``
``while``:inxx
The ``while`` loop in Python works much as it does in many other programming languages, by looping an indefinite number of times and testing a condition before each iteration. If the condition is ``False``, the loop ends.
``
>>> i = 0
>>> while i < 10:
        i = i + 1
>>> print i
10
``:code

There is no ``loop...until`` construct in Python.

### ``if...elif...else``
``if``:inxx ``elif``:inxx ``else``:inxx
The use of conditionals in Python is intuitive:
``
>>> for i in range(3):
>>>     if i == 0:
>>>         print 'zero'
>>>     elif i == 1:
>>>         print 'one'
>>>     else:
>>>         print 'other'
zero
one
other
``:code

"elif" means "else if". Both ``elif`` and ``else`` clauses are optional. There can be more than one ``elif`` but only one ``else`` statement. Complex conditions can be created using the ``not``, ``and`` and ``or`` operators.
``
>>> for i in range(3):
>>>     if i == 0 or (i == 1 and i + 1 == 2):
>>>         print '0 or 1'
``:code

### ``try...except...else...finally``
``try``:inxx ``except``:inxx ``finally``:inxx ``Exception``:inxx
Python can throw - pardon, raise - Exceptions:
``
>>> try:
>>>     a = 1 / 0
>>> except Exception, e:
>>>     print 'oops: %s' % e
>>> else:
>>>     print 'no problem here'
>>> finally:
>>>     print 'done'
oops: integer division or modulo by zero
done
``:code

If the exception is raised, it is caught by the ``except`` clause, which is executed, while the ``else`` clause is not. If no exception is raised, the ``except`` clause is not executed, but the ``else`` one is. The ``finally`` clause is always executed.

There can be multiple ``except`` clauses for different possible exceptions:
``
>>> try:
>>>     raise SyntaxError
>>> except ValueError:
>>>     print 'value error'
>>> except SyntaxError:
>>>     print 'syntax error'
syntax error
``:code

The ``else`` and ``finally`` clauses are optional.

Here is a list of built-in Python exceptions + HTTP (defined by web2py)
``
BaseException
 +-- HTTP (defined by web2py)
 +-- SystemExit
 +-- KeyboardInterrupt
 +-- Exception
      +-- GeneratorExit
      +-- StopIteration
      +-- StandardError
      |    +-- ArithmeticError
      |    |    +-- FloatingPointError
      |    |    +-- OverflowError
      |    |    +-- ZeroDivisionError
      |    +-- AssertionError
      |    +-- AttributeError
      |    +-- EnvironmentError
      |    |    +-- IOError
      |    |    +-- OSError
      |    |         +-- WindowsError (Windows)
      |    |         +-- VMSError (VMS)
      |    +-- EOFError
      |    +-- ImportError
      |    +-- LookupError
      |    |    +-- IndexError
      |    |    +-- KeyError
      |    +-- MemoryError
      |    +-- NameError
      |    |    +-- UnboundLocalError
      |    +-- ReferenceError
      |    +-- RuntimeError
      |    |    +-- NotImplementedError
      |    +-- SyntaxError
      |    |    +-- IndentationError
      |    |         +-- TabError
      |    +-- SystemError
      |    +-- TypeError
      |    +-- ValueError
      |    |    +-- UnicodeError
      |    |         +-- UnicodeDecodeError
      |    |         +-- UnicodeEncodeError
      |    |         +-- UnicodeTranslateError
      +-- Warning
           +-- DeprecationWarning
           +-- PendingDeprecationWarning
           +-- RuntimeWarning
           +-- SyntaxWarning
           +-- UserWarning
           +-- FutureWarning
           +-- ImportWarning
           +-- UnicodeWarning
``:code

For a detailed description of each of them, refer to the official Python documentation.

web2py exposes only one new exception, called ``HTTP``. When raised, it causes the program to return an HTTP error page (for more on this refer to Chapter 4).

Any object can be raised as an exception, but it is good practice to raise objects that extend one of the built-in exception classes.

### ``def...return``
``def``:inxx ``return``:inxx

Functions are declared using ``def``.  Here is a typical Python function:
``
>>> def f(a, b):
        return a + b
>>> print f(4, 2)
6
``:code

There is no need (or way) to specify types of the arguments or the return type(s). In this example, a function ``f`` is defined that can take two arguments.

Functions are the first code syntax feature described in this chapter to introduce the concept of ''scope'', or ''namespace''.  In the above example, the identifiers ``a`` and ``b`` are undefined outside of the scope of function ``f``:
``
>>> def f(a):
        return a + 1
>>> print f(1)
2
>>> print a
Traceback (most recent call last):
  File "<pyshell#22>", line 1, in <module>
    print a
NameError: name 'a' is not defined
``:code

Identifiers defined outside of function scope are accessible within the function; observe how the identifier ``a`` is handled in the following code:
``
>>> a = 1
>>> def f(b):
        return a + b
>>> print f(1)
2
>>> a = 2
>>> print f(1) # new value of a is used
3
>>> a = 1 # reset a
>>> def g(b):
        a = 2 # creates a new local a
        return a + b
>>> print g(2)
4
>>> print a # global a is unchanged
1
``:code

If ``a`` is modified, subsequent function calls will use the new value of the global ``a`` because the function definition binds the storage location of the identifier ``a``, not the value of ``a`` itself at the time of function declaration; however, if ``a`` is assigned-to inside function ``g``, the global ``a`` is unaffected because the new local ``a`` hides the global value.  The external-scope reference can be used in the creation of ''closures'':
``
>>> def f(x):
        def g(y):
            return x * y
        return g
>>> doubler = f(2) # doubler is a new function
>>> tripler = f(3) # tripler is a new function
>>> quadrupler = f(4) # quadrupler is a new function
>>> print doubler(5)
10
>>> print tripler(5)
15
>>> print quadrupler(5)
20
``:code

Function ``f`` creates new functions; and note that the scope of the name ``g`` is entirely internal to ``f``.  Closures are extremely powerful.

Function arguments can have default values, and can return multiple results:
``
>>> def f(a, b=2):
        return a + b, a - b
>>> x, y = f(5)
>>> print x
7
>>> print y
3
``:code

Function arguments can be passed explicitly by name, and this means that the order of arguments specified in the caller can be different than the order of arguments with which the function was defined:
``
>>> def f(a, b=2):
        return a + b, a - b
>>> x, y = f(b=5, a=2)
>>> print x
7
>>> print y
-3
``:code

Functions can also take a runtime-variable number of arguments:
``
>>> def f(*a, **b):
        return a, b
>>> x, y = f(3, 'hello', c=4, test='world')
>>> print x
(3, 'hello')
>>> print y
{'c':4, 'test':'world'}
``:code

Here arguments not passed by name (3, 'hello') are stored in the tuple ``a``, and arguments passed by name (``c`` and ``test``) are stored in the dictionary ``b``.

In the opposite case, a list or tuple can be passed to a function that requires individual positional arguments by unpacking them:
``
>>> def f(a, b):
        return a + b
>>> c = (1, 2)
>>> print f(*c)
3
``:code

and a dictionary can be unpacked to deliver keyword arguments:
``
>>> def f(a, b):
        return a + b
>>> c = {'a':1, 'b':2}
>>> print f(**c)
3
``:code

#### ``lambda``
``lambda``:inxx

``lambda`` provides a way to create a very short unnamed function very easily:
``
>>> a = lambda b: b + 2
>>> print a(3)
5
``:code

The expression "``lambda`` [a]:[b]" literally reads as "a function with arguments [a] that returns [b]". The ``lambda`` expression is itself unnamed, but the function acquires a name by being assigned to identifier ``a``.  The scoping rules for ``def`` apply to ``lambda`` equally, and in fact the code above, with respect to ``a``, is identical to the function declaration using ``def``:
``
>>> def a(b):
        return b + 2
>>> print a(3)
5
``:code

The only benefit of ``lambda`` is brevity; however, brevity can be very convenient in certain situations.  Consider a function called ``map`` that applies a function to all items in a list, creating a new list:
``
>>> a = [1, 7, 2, 5, 4, 8]
>>> map(lambda x: x + 2, a)
[3, 9, 4, 7, 6, 10]
``:code
This code would have doubled in size had ``def`` been used instead of ``lambda``. The main drawback of ``lambda`` is that (in the Python implementation) the syntax allows only for a single expression; however, for longer functions, ``def`` can be used and the extra cost of providing a function name decreases as the length of the function grows.
Just like ``def``, ``lambda`` can be used to ''curry'' functions: new functions can be created by wrapping existing functions such that the new function carries a different set of arguments:
``
>>> def f(a, b): return a + b
>>> g = lambda a: f(a, 3)
>>> g(2)
5
``:code

There are many situations where currying is useful, but one of those is directly useful in web2py: caching. Suppose you have an expensive function that checks whether its argument is prime:
``
def isprime(number):
    for p in range(2, number):
        if (number % p) == 0:
            return False
    return True
``:code

This function is obviously time consuming.

Suppose you have a caching function ``cache.ram`` that takes three arguments: a key, a function and a number of seconds.
``
value = cache.ram('key', f, 60)
``:code

The first time it is called, it calls the function ``f()``, stores the output in a dictionary in memory (let's say "d"), and returns it so that value is:
``
value = d['key']=f()
``:code

The second time it is called, if the key is in the dictionary and not older than the number of seconds specified (60), it returns the corresponding value without performing the function call.
``
value = d['key']
``:code

How would you cache the output of the function **isprime** for any input?
Here is how:
``
>>> number = 7
>>> seconds = 60
>>> print cache.ram(str(number), lambda: isprime(number), seconds)
True
>>> print cache.ram(str(number), lambda: isprime(number), seconds)
True
``:code

The output is always the same, but the first time ``cache.ram`` is called, ``isprime`` is called; the second time it is not.

-------
Python functions, created with either ``def`` or ``lambda`` allow re-factoring existing functions in terms of a different set of arguments.
``cache.ram`` and ``cache.disk`` are web2py caching functions.
-------

### ``class``
``class``:inxx

Because Python is dynamically typed, Python classes and objects may seem odd. In fact, you do not need to define the member variables (attributes) when declaring a class, and different instances of the same class can have different attributes. Attributes are generally associated with the instance, not the class (except when declared as "class attributes", which is the same as "static member variables" in C++/Java).

Here is an example:
``
>>> class MyClass(object): pass
>>> myinstance = MyClass()
>>> myinstance.myvariable = 3
>>> print myinstance.myvariable
3
``:code

Notice that ``pass`` is a do-nothing command. In this case it is used to define a class ``MyClass`` that contains nothing. ``MyClass()`` calls the constructor of the class (in this case the default constructor) and returns an object, an instance of the class. The ``(object)`` in the class definition indicates that our class extends the built-in ``object`` class. This is not required, but it is good practice.

Here is a more complex class:
``
>>> class MyClass(object):
>>>    z = 2
>>>    def __init__(self, a, b):
>>>        self.x = a
>>>        self.y = b
>>>    def add(self):
>>>        return self.x + self.y + self.z
>>> myinstance = MyClass(3, 4)
>>> print myinstance.add()
9
``:code

Functions declared inside the class are methods. Some methods have special reserved names. For example, ``__init__`` is the constructor. All variables are local variables of the method except variables declared outside methods. For example, ``z`` is a ''class variable'', equivalent to a C++ ''static member variable'' that holds the same value for all instances of the class.

Notice that ``__init__`` takes 3 arguments and ``add`` takes one, and yet we call them with 2 and 0 arguments respectively. The first argument represents, by convention, the local name used inside the method to refer to the current object. Here we use ``self`` to refer to the current object, but we could have used any other name. ``self`` plays the same role as ``*this`` in C++ or ``this`` in Java, but ``self`` is not a reserved keyword.

This syntax is necessary to avoid ambiguity when declaring nested classes, such as a class that is local to a method inside another class.

### Special attributes, methods and operators

Class attributes, methods, and operators starting with a double underscore are usually intended to be private (i.e. to be used internally but not exposed outside the class) although this is a convention that is not enforced by the interpreter.

Some of them are reserved keywords and have a special meaning.

Here, as an example, are three of them:
- ``__len__``
- ``__getitem__``
- ``__setitem__``
They can be used, for example, to create a container object that acts like a list:
``
>>> class MyList(object):
>>>     def __init__(self, *a): self.a = list(a)
>>>     def __len__(self): return len(self.a)
>>>     def __getitem__(self, i): return self.a[i]
>>>     def __setitem__(self, i, j): self.a[i] = j
>>> b = MyList(3, 4, 5)
>>> print b[1]
4
>>> b.a[1] = 7
>>> print b.a
[3, 7, 5]
``:code

Other special operators include ``__getattr__`` and ``__setattr__``, which define the get and set attributes for the class, and ``__sum__`` and ``__sub__``, which overload arithmetic operators. For the use of these operators we refer the reader to more advanced books on this topic. We have already mentioned the special operators ``__str__`` and ``__repr__``.

### File input/output
``file.read``:inxx ``file.write``:inxx

In Python you can open and write in a file with:
``
>>> file = open('myfile.txt', 'w')
>>> file.write('hello world')
>>> file.close()
``:code

Similarly, you can read back from the file with:
``
>>> file = open('myfile.txt', 'r')
>>> print file.read()
hello world
``:code

Alternatively, you can read in binary mode with "rb", write in binary mode with "wb", and open the file in append mode "a", using standard C notation.

The ``read`` command takes an optional argument, which is the number of bytes. You can also jump to any location in a file using ``seek``.
``file.seek``:inxx

You can read back from the file with ``read``
``
>>> print file.seek(6)
>>> print file.read()
world
``:code

and you can close the file with:
``
>>> file.close()
``:code

In the standard distribution of Python, which is known as CPython, variables are reference-counted, including those holding file handles, so CPython knows that when the reference count of an open file handle decreases to zero, the file may be closed and the variable disposed.  However, in other implementations of Python such as PyPy, garbage collection is used instead of reference counting, and this means that it is possible that there may accumulate too many open file handles at one time, resulting in an error before the ''gc'' has a chance to close and dispose of them all.  Therefore it is best to explicitly close file handles when they are no longer needed.  ''web2py'' provides two helper functions, ``read_file()`` and ``write_file()`` inside the ``gluon.fileutils`` namespace that encapsulate the file access and ensure that the file handles being used are properly closed.

-------
When using web2py, you do not know where the current directory is, because it depends on how web2py is configured. The variable ``request.folder`` contains the path to the current application. Paths can be concatenated with the command ``os.path.join``, discussed below.
-------

### ``exec``, ``eval``
``exec``:inxx ``eval``:inxx

Unlike Java, Python is a truly interpreted language. This means it has the ability to execute Python statements stored in strings. For example:
``
>>> a = "print 'hello world'"
>>> exec(a)
'hello world'
``:code

What just happened? The function ``exec`` tells the interpreter to call itself and execute the content of the string passed as argument. It is also possible to execute the content of a string within a context defined by the symbols in a dictionary:
``
>>> a = "print b"
>>> c = dict(b=3)
>>> exec(a, {}, c)
3
``:code

Here the interpreter, when executing the string ``a``, sees the symbols defined in ``c`` (``b`` in the example), but does not see ``c`` or ``a`` themselves. This is different than a restricted environment, since ``exec`` does not limit what the inner code can do; it just defines the set of variables visible to the code.

A related function is ``eval``, which works very much like ``exec`` except that it expects the argument to evaluate to a value, and it returns that value.
``
>>> a = "3*4"
>>> b = eval(a)
>>> print b
12
``:code

### ``import``
``import``:inxx ``random``:inxx
The real power of Python is in its library modules. They provide a large and consistent set of Application Programming Interfaces (APIs) to many system libraries (often in a way independent of the operating system).

For example, if you need to use a random number generator, you can do:
``
>>> import random
>>> print random.randint(0, 9)
5
``:code

This prints a random integer between 0 and 9 (including 9), 5 in the example. The function ``randint`` is defined in the module ``random``. It is also possible to import an object from a module into the current namespace:
``
>>> from random import randint
>>> print randint(0, 9)
``:code

or import all objects from a module into the current namespace:
``
>>> from random import *
>>> print randint(0, 9)
``:code

or import everything in a newly defined namespace:
``
>>> import random as myrand
>>> print myrand.randint(0, 9)
``:code

In the rest of this book, we will mainly use objects defined in modules ``os``, ``sys``, ``datetime``, ``time`` and ``cPickle``.

-------
All of the web2py objects are accessible via a module called ``gluon``, and that is the subject of later chapters. Internally, web2py uses many Python modules (for example ``thread``), but you rarely need to access them directly.
-------

In the following subsections we consider those modules that are most useful.

#### ``os``
``os``:inxx ``os.path.join``:inxx ``os.unlink``:inxx

This module provides an interface to the operating system API. For example:
``
>>> import os
>>> os.chdir('..')
>>> os.unlink('filename_to_be_deleted')
``:code

-------
Some of the ``os`` functions, such as ``chdir``, MUST NOT be used in web2py because they are not thread-safe.
-------
``os.path.join`` is very useful; it allows the concatenation of paths in an OS-independent way:
``
>>> import os
>>> a = os.path.join('path', 'sub_path')
>>> print a
path/sub_path
``:code

System environment variables can be accessed via:
``
>>> print os.environ
``:code

which is a read-only dictionary.

#### ``sys``
``sys``:inxx ``sys.path``:inxx

The ``sys`` module contains many variables and functions, but the one we use the most is ``sys.path``. It contains a list of paths where Python searches for modules. When we try to import a module, Python looks for it in all the folders listed in ``sys.path``. If you install additional modules in some location and want Python to find them, you need to append the path to that location to ``sys.path``.
``
>>> import sys
>>> sys.path.append('path/to/my/modules')
``:code

When running web2py, Python stays resident in memory, and there is only one ``sys.path``, while there are many threads servicing the HTTP requests. To avoid a memory leak, it is best to check if a path is already present before appending:
``
>>> path = 'path/to/my/modules'
>>> if not path in sys.path:
        sys.path.append(path)
``:code

#### ``datetime``
``date``:inxx ``datetime``:inxx ``time``:inxx

The use of the datetime module is best illustrated by some examples:
``
>>> import datetime
>>> print datetime.datetime.today()
2008-07-04 14:03:90
>>> print datetime.date.today()
2008-07-04
``:code

Occasionally you may need to time-stamp data based on the UTC time as opposed to local time. In this case you can use the following function:
``
>>> import datetime
>>> print datetime.datetime.utcnow()
2008-07-04 14:03:90
``:code

The datetime module contains various classes: date, datetime, time and timedelta. The difference between two date or two datetime or two time objects is a timedelta:
``
>>> a = datetime.datetime(2008, 1, 1, 20, 30)
>>> b = datetime.datetime(2008, 1, 2, 20, 30)
>>> c = b - a
>>> print c.days
1
``:code

In web2py, date and datetime are used to store the corresponding SQL types when passed to or returned from the database.

#### ``time``
``time``:inxx

The time module differs from ``date`` and ``datetime`` because it represents time as seconds from the epoch (beginning of 1970).
``
>>> import time
>>> t = time.time()
1215138737.571
``:code

Refer to the Python documentation for conversion functions between time in seconds and time as a ``datetime``.

#### ``cPickle``
``cPickle``:inxx

This is a very powerful module. It provides functions that can serialize almost any Python object, including self-referential objects. For example, let's build a weird object:
``
>>> class MyClass(object): pass
>>> myinstance = MyClass()
>>> myinstance.x = 'something'
>>> a = [1 ,2, {'hello':'world'}, [3, 4, [myinstance]]]
``:code

and now:
``
>>> import cPickle
>>> b = cPickle.dumps(a)
>>> c = cPickle.loads(b)
``:code

In this example, ``b`` is a string representation of ``a``, and ``c`` is a copy of ``a`` generated by de-serializing ``b``.

cPickle can also serialize to and de-serialize from a file:
``
>>> cPickle.dump(a, open('myfile.pickle', 'wb'))
>>> c = cPickle.load(open('myfile.pickle', 'rb'))
``:code
