96b8c924160e22ea18b8608f051af6b5483ac42d
diff --git a/sources/29-web2py-english/06.markmin b/sources/29-web2py-english/06.markmin
index 955039c6c520ec55268671441908c2d094680399..2079bfafa89ce01b8c8a45e02df0b76fd065d656 100644
--- a/sources/29-web2py-english/06.markmin
+++ b/sources/29-web2py-english/06.markmin
@@ -303,7 +303,7 @@ The format attribute will be used for two purposes:
 ``Field constructor``:inxx
 These are the default values of a Field constructor:
 ``
-Field(name, 'string', length=None, default=None,
+Field(fieldname, type='string', length=None, default=None,
       required=False, requires='<default>',
       ondelete='CASCADE', notnull=False, unique=False,
       uploadfield=True, widget=None, label=None, comment=None,
@@ -317,8 +317,38 @@ Not all of them are relevant for every field. "length" is relevant only for fiel
 - ``length`` sets the maximum length of a "string", "password" or "upload" field.  If ``length`` is not specified a default value is used but the default value is not guaranteed to be backward compatible. ''To avoid unwanted migrations on upgrades, we recommend that you always specify the length for string, password and upload fields.''
 - ``default`` sets the default value for the field. The default value is used when performing an insert if a value is not explicitly specified. It is also used to pre-populate forms built from the table using SQLFORM. Note, rather than being a fixed value, the default can instead be a function (including a lambda function) that returns a value of the appropriate type for the field. In that case, the function is called once for each record inserted, even when multiple records are inserted in a single transaction.
 - ``required`` tells the DAL that no insert should be allowed on this table if a value for this field is not explicitly specified.
-- ``requires`` is a validator or a list of validators. This is not used by the DAL, but it is used by SQLFORM. The default validators for the given types are shown in the following table:
+- ``requires`` is a validator or a list of validators. This is not used by the DAL, but it is used by SQLFORM. The default validators for the given types are shown in the table in the next section. 
+``ondelete``:inxx
+- ``ondelete`` translates into the "ON DELETE" SQL statement. By default it is set to "CASCADE". This tells the database that when it deletes a record, it should also delete all records that refer to it. To disable this feature, set ``ondelete`` to "NO ACTION" or "SET NULL".
+- ``notnull=True`` translates into the "NOT NULL" SQL statement. It prevents the database from inserting null values for the field.
+- ``unique=True`` translates into the "UNIQUE" SQL statement and it makes sure that values of this field are unique within the table. It is enforced at the database level.
+- ``uploadfield`` applies only to fields of type "upload". A field of type "upload" stores the name of a file saved somewhere else, by default on the filesystem under the application "uploads/" folder. If ``uploadfield`` is set to True, then the file is stored in a blob field within the same table and the value of ``uploadfield`` is the name of the blob field. This will be discussed in more detail later in the context of SQLFORM.
+- ``uploadfolder`` defaults to the application's "uploads/" folder. If set to a different path, files will uploaded to a different folder. For example,
+``
+Field(...,uploadfolder=os.path.join(request.folder,'static/temp'))
+``:code
+will upload files to the "web2py/applications/myapp/static/temp" folder.
+- ``uploadseparate`` if set to True will upload files under different subfolders of the ''uploadfolder'' folder. This is optimized to avoid too many files under the same folder/subfolder. ATTENTION: You cannot change the value of ``uploadseparate`` from True to False without breaking links to existing uploads. web2py either uses the separate subfolders or it does not. Changing the behavior after files have been uploaded will prevent web2py from being able to retrieve those files. If this happens it is possible to move files and fix the problem but this is not described here.
+- ``uploadfs`` allows you specify a different file system where to upload files, including an Amazon S3 storage or a remote SFTP storage. This option requires PyFileSystem installed. ``uploadfs`` must point to ``PyFileSystem``. ``PyFileSystem``:inxx ``uploadfs``:idxx
+- ``widget`` must be one of the available widget objects, including custom widgets, for example: ``SQLFORM.widgets.string.widget``. A list of available widgets will be discussed later. Each field type has a default widget.
+- ``label`` is a string (or a helper or something that can be serialized to a string) that contains the label to be used for this field in auto-generated forms.
+- ``comment``  is a string (or a helper or something that can be serialized to a string) that contains a comment associated with this field, and will be displayed to the right of the input field in the autogenerated forms.
+- ``writable`` declares whether a field is writable in forms.
+- ``readable`` declares whether a field is readable in forms. If a field is neither readable nor writable, it will not be displayed in create and update forms.
+- ``update`` contains the default value for this field when the record is updated.
+- ``compute`` is an optional function. If a record is inserted or updated, the compute function will be executed and the field will be populated with the function result. The record is passed to the compute function as a ``dict``, and the dict will not include the current value of that, or any other compute field.
+- ``authorize`` can be used to require access control on the corresponding field, for "upload" fields only. It will be discussed more in detail in the context of Authentication and Authorization.
+- ``autodelete`` determines if the corresponding uploaded file should be deleted when the record referencing the file is deleted. For "upload" fields only.
+- ``represent`` can be ``None`` or can point to a function that takes a field value and a row and returns an alternate representation for the field value. Examples:
+``
+db.mytable.name.represent = lambda name,row: name.capitalize()
+db.mytable.other_id.represent = lambda id,row: row.myfield
+db.mytable.some_uploadfield.represent = lambda value,row: \
+    A('get it', _href=URL('download', args=value))
+``:code
 
+``default validators``:inxx
+#### Default validators
 ----------
 **field type** | **default field validators**
 ``string`` | ``IS_LENGTH(length)`` default length is 512
@@ -351,43 +381,17 @@ The ``list:<type>`` fields are special because they are designed to take advanta
 
 The ``json`` field type is pretty much explanatory. It can store any json serializable object. It is designed to work specifically for MongoDB and backported to the other database adapters for portability.
 
--------
-Notice that ``requires=...`` is enforced at the level of forms, ``required=True`` is enforced at the level of the DAL (insert), while ``notnull``, ``unique`` and ``ondelete`` are enforced at the level of the database. While they sometimes may seem redundant, it is important to maintain the distinction when programming with the DAL.
--------
-
-``ondelete``:inxx
+``blob``:inxx
+``blob`` fields are also special. By default, binary data is encoded in base64 before being stored into the actual database field, and it is decoded when extracted. This has the negative effect of using 25% more storage space than necessary in blob fields, but has two advantages. On average it reduces the amount of data communicated between web2py and the database server, and it makes the communication independent of back-end-specific escaping conventions.
 
-- ``ondelete`` translates into the "ON DELETE" SQL statement. By default it is set to "CASCADE". This tells the database that when it deletes a record, it should also delete all records that refer to it. To disable this feature, set ``ondelete`` to "NO ACTION" or "SET NULL".
-- ``notnull=True`` translates into the "NOT NULL" SQL statement. It prevents the database from inserting null values for the field.
-- ``unique=True`` translates into the "UNIQUE" SQL statement and it makes sure that values of this field are unique within the table. It is enforced at the database level.
-- ``uploadfield`` applies only to fields of type "upload". A field of type "upload" stores the name of a file saved somewhere else, by default on the filesystem under the application "uploads/" folder. If ``uploadfield`` is set to True, then the file is stored in a blob field within the same table and the value of ``uploadfield`` is the name of the blob field. This will be discussed in more detail later in the context of SQLFORM.
-- ``uploadfolder`` defaults to the application's "uploads/" folder. If set to a different path, files will uploaded to a different folder. For example,
-``
-Field(...,uploadfolder=os.path.join(request.folder,'static/temp'))
-``:code
-will upload files to the "web2py/applications/myapp/static/temp" folder.
-- ``uploadseparate`` if set to True will upload files under different subfolders of the ''uploadfolder'' folder. This is optimized to avoid too many files under the same folder/subfolder. ATTENTION: You cannot change the value of ``uploadseparate`` from True to False without breaking links to existing uploads. web2py either uses the separate subfolders or it does not. Changing the behavior after files have been uploaded will prevent web2py from being able to retrieve those files. If this happens it is possible to move files and fix the problem but this is not described here.
-- ``uploadfs`` allows you specify a different file system where to upload files, including an Amazon S3 storage or a remote SFTP storage. This option requires PyFileSystem installed. ``uploadfs`` must point to ``PyFileSystem``. ``PyFileSystem``:inxx ``uploadfs``:idxx
-- ``widget`` must be one of the available widget objects, including custom widgets, for example: ``SQLFORM.widgets.string.widget``. A list of available widgets will be discussed later. Each field type has a default widget.
-- ``label`` is a string (or a helper or something that can be serialized to a string) that contains the label to be used for this field in auto-generated forms.
-- ``comment``  is a string (or a helper or something that can be serialized to a string) that contains a comment associated with this field, and will be displayed to the right of the input field in the autogenerated forms.
-- ``writable`` declares whether a field is writable in forms.
-- ``readable`` declares whether a field is readable in forms. If a field is neither readable nor writable, it will not be displayed in create and update forms.
-- ``update`` contains the default value for this field when the record is updated.
-- ``compute`` is an optional function. If a record is inserted or updated, the compute function will be executed and the field will be populated with the function result. The record is passed to the compute function as a ``dict``, and the dict will not include the current value of that, or any other compute field.
-- ``authorize`` can be used to require access control on the corresponding field, for "upload" fields only. It will be discussed more in detail in the context of Authentication and Authorization.
-- ``autodelete`` determines if the corresponding uploaded file should be deleted when the record referencing the file is deleted. For "upload" fields only.
-- ``represent`` can be None or can point to a function that takes a field value and returns an alternate representation for the field value. Examples:
-``
-db.mytable.name.represent = lambda name,row: name.capitalize()
-db.mytable.other_id.represent = lambda id,row: row.myfield
-db.mytable.some_uploadfield.represent = lambda value,row: \
-    A('get it', _href=URL('download', args=value))
-``:code
+``requires``:inxx
+``required``:inxx
+``notnull``:inxx
+Notice that ``requires=...`` is enforced at the level of forms, ``required=True`` is enforced at the level of the DAL (insert), while ``notnull``, ``unique`` and ``ondelete`` are enforced at the level of the database. While they sometimes may seem redundant, it is important to maintain the distinction when programming with the DAL.
 
-``blob``:inxx
-"blob" fields are also special. By default, binary data is encoded in base64 before being stored into the actual database field, and it is decoded when extracted. This has the negative effect of using 25% more storage space than necessary in blob fields, but has two advantages. On average it reduces the amount of data communicated between web2py and the database server, and it makes the communication independent of back-end-specific escaping conventions.
 
+``modify fileds and tables``:inxx
+#### Modify fields and tables
 Most attributes of fields and tables can be modified after they are defined:
 
 ``
@@ -981,22 +985,30 @@ Yes this is unusual and rarely needed.
 #### Rendering rows using represent
 You may wish to rewrite rows returned by select to take advantage of formatting information contained in the represents setting of the fields. 
 
-``rows = db(query).select()
-repr_row = rows.render(0)``:code
+``
+rows = db(query).select()  
+repr_row = rows.render(0)
+``:code
 
 If you don't specify an index, you get a generator to iterate over all the rows:
 
-``for row in rows.render():
-    print row.myfield``:code
+``
+for row in rows.render():
+    print row.myfield
+``:code
 
 Can also be applied to slices:
 
-``for row in rows[0:10].render():
-    print row.myfield``:code
+``
+for row in rows[0:10].render():
+    print row.myfield
+``:code
 
 If you only want to transform selected fields via their "represent" attribute, you can list them in the "fields" argument:
 
-``repr_row = row.render(0, fields=[db.mytable.myfield])``:code
+``
+repr_row = row.render(0, fields=[db.mytable.myfield])
+``:code
 
 Note, it returns a transformed copy of the original Row, so there's no update_record (which you wouldn't want anyway) or delete_record.
 
@@ -1124,7 +1136,7 @@ Given the following action containing a query
 ``SQLTABLE``:inxx
 
 ``
-def index()
+def index():
     return dict(rows = db(query).select())
 ``:code
 
@@ -1554,7 +1566,7 @@ John
 #### ``find``, ``exclude``, ``sort``
 ``find``:inxx ``exclude``:inxx ``sort``:inxx
 
-Some times you need to perform two selects and one contains a subset of a previous select. In this case it is pointless to access the database again. The ``find``, ``exclude`` and ``sort`` objects allow you to manipulate a Rows objects and generate another one without accessing the database. More specifically:
+Some times you need to perform two selects and one contains a subset of a previous select. In this case it is pointless to access the database again. The ``find``, ``exclude`` and ``sort`` objects allow you to manipulate a Rows object and generate another one without accessing the database. More specifically:
 - ``find`` returns a new set of Rows filtered by a condition and leaves the original unchanged.
 - ``exclude`` returns a new set of Rows filtered by a condition and removes them from the original Rows.
 - ``sort`` returns a new set of Rows sorted by a condition and leaves the original unchanged.
@@ -2244,7 +2256,7 @@ db.mytable.myfield.contains(['value1','value2'], all=True)
 ``
 or any value from the list
 ``
-db.mytable.myfield.contains(['value1','value2'], all=false)
+db.mytable.myfield.contains(['value1','value2'], all=False)
 ``
 
 There is a also a ``regexp`` method that works like the ``like`` method but allows regular expression syntax for the look-up expression. It is only supported by PostgreSQL and SQLite.
@@ -3169,10 +3181,10 @@ Web2py provides a script that does this work for you:
 
 ``
 cd web2py
-python scripts/cpdb.py \
-   -f applications/app/databases \
-   -y 'sqlite://storage.sqlite' \
-   -Y 'postgres://username:password@localhost/mydb' \
+python scripts/cpdb.py \\
+   -f applications/app/databases \\
+   -y 'sqlite://storage.sqlite' \\
+   -Y 'postgres://username:password@localhost/mydb' \\
    -d ../gluon
 ``
 
diff --git a/sources/29-web2py-english/07.markmin b/sources/29-web2py-english/07.markmin
index b26be5b1dc2e788b90e546acbe5d61ac4c2633c9..fd144f277cf9fb28dca53bdf6c58944bd94cb5c7 100644
--- a/sources/29-web2py-english/07.markmin
+++ b/sources/29-web2py-english/07.markmin
@@ -147,9 +147,9 @@ the latter does not need the ``request`` and ``session`` arguments (although you
 
 The process function takes some extra argument that ``accepts`` does not take:
 - ``message_onsuccess``
-- ``onsuccess``: if equal to 'flash' (default) and the form is accepted it will flash the above `message_onsuccess``
+- ``onsuccess``: if equal to 'flash' (default) and the form is accepted it will flash the above ``message_onsuccess``
 - ``message_onfailure``
-- ``onfailure``: if equal to 'flash' (default) and the form fails validation, it will flash the above `message_onfailure``
+- ``onfailure``: if equal to 'flash' (default) and the form fails validation, it will flash the above ``message_onfailure``
 - ``next`` indicates where to redirect the user after the form is accepted.
 ``onsuccess`` and ``onfailure`` can be functions like ``lambda form: do_something(form)``.
 
@@ -251,6 +251,8 @@ def edit_dog():
     return dict(form=form)
 ``:code
 
+``record_changed`` works only with a SQLFORM and not with a FORM.
+
 #### Forms and redirection
 
 The most common way to use forms is via self-submission, so that the submitted field variables are processed by the same action that generated the form. Once the form is accepted, it is unusual to display the current page again (something we are doing here only to keep things simple). It is more common to redirect the visitor to a "next" page.
diff --git a/sources/29-web2py-english/08.markmin b/sources/29-web2py-english/08.markmin
index a9e6193e7079f6220e62ee7f6977a93a882ca384..67fc2f5c7e9e93dc6c9524d6281687c06a001a32 100644
--- a/sources/29-web2py-english/08.markmin
+++ b/sources/29-web2py-english/08.markmin
@@ -296,7 +296,7 @@ Note that ``<imapdb>.define_tables()`` returns a dictionary of strings mapping D
 If you want to set you own tablename/mailbox configuration and skip the automatic name configuration, you can pass a custom dictionary to the adapter in this way:
 
 ``
-imapdb.define_tables({"inbox": "MAILBOX", "trash", "SPAM"})
+imapdb.define_tables({"inbox":"MAILBOX", "trash":"SPAM"})
 ``:code
 
 To handle the different native mailbox names for the user interface,  the following attributes give access to the adapter auto mailbox mapped names (which native mailbox has what table name and vice versa):
diff --git a/sources/29-web2py-english/11.markmin b/sources/29-web2py-english/11.markmin
index d99f996ed9a1a34fa1bcc58d0d4bfe91227ba316..1b6117e15f700af3ae111d9df5b73445d49a714d 100644
--- a/sources/29-web2py-english/11.markmin
+++ b/sources/29-web2py-english/11.markmin
@@ -333,7 +333,7 @@ jQuery(document).ready(function(){
    jQuery('input.delete').prop('onclick',
      'if(this.checked) if(!confirm(
         "{{=T('Sure you want to delete this object?')}}"))
-      this.checked=false;');
+      this.checked=False;');
 });
 ``:code
 
diff --git a/sources/29-web2py-english/14.markmin b/sources/29-web2py-english/14.markmin
index 3751629f19bc5c3cf60689ab7e9951ffc9269738..54f5b7aee622be1ce5ae2cb36e52feb831a06955 100644
--- a/sources/29-web2py-english/14.markmin
+++ b/sources/29-web2py-english/14.markmin
@@ -589,7 +589,9 @@ Create a file called "yourapp/private/dropbox.key" and in it write
 ``
 <APP_KEY>:<APP_SECRET>:app_folder
 ``
-where ``<APP_KEY>`` and ``<APP_SECRET>`` are your key and secret.
+where ``<APP_KEY>`` and ``<APP_SECRET>`` are your key and secret. The third part could be ``app_folder`` or ``dropbox`` or ``auto``.
+
+Install the dropbox sdk from "https://www.dropbox.com/developers/core/sdks/python".
 
 Then in "models/db.py" do:
 
