96b8c924160e22ea18b8608f051af6b5483ac42d
diff --git a/sources/29-web2py-english/06.markmin b/sources/29-web2py-english/06.markmin
index 955039c6c520ec55268671441908c2d094680399..2079bfafa89ce01b8c8a45e02df0b76fd065d656 100644
--- a/sources/29-web2py-english/06.markmin
+++ b/sources/29-web2py-english/06.markmin
@@ -303,7 +303,7 @@ The format attribute will be used for two purposes:
 ``Field constructor``:inxx
 These are the default values of a Field constructor:
 ``
-Field(name, 'string', length=None, default=None,
+Field(fieldname, type='string', length=None, default=None,
       required=False, requires='<default>',
       ondelete='CASCADE', notnull=False, unique=False,
       uploadfield=True, widget=None, label=None, comment=None,
@@ -317,8 +317,38 @@ Not all of them are relevant for every field. "length" is relevant only for fiel
 - ``length`` sets the maximum length of a "string", "password" or "upload" field.  If ``length`` is not specified a default value is used but the default value is not guaranteed to be backward compatible. ''To avoid unwanted migrations on upgrades, we recommend that you always specify the length for string, password and upload fields.''
 - ``default`` sets the default value for the field. The default value is used when performing an insert if a value is not explicitly specified. It is also used to pre-populate forms built from the table using SQLFORM. Note, rather than being a fixed value, the default can instead be a function (including a lambda function) that returns a value of the appropriate type for the field. In that case, the function is called once for each record inserted, even when multiple records are inserted in a single transaction.
 - ``required`` tells the DAL that no insert should be allowed on this table if a value for this field is not explicitly specified.
-- ``requires`` is a validator or a list of validators. This is not used by the DAL, but it is used by SQLFORM. The default validators for the given types are shown in the following table:
+- ``requires`` is a validator or a list of validators. This is not used by the DAL, but it is used by SQLFORM. The default validators for the given types are shown in the table in the next section. 
+``ondelete``:inxx
+- ``ondelete`` translates into the "ON DELETE" SQL statement. By default it is set to "CASCADE". This tells the database that when it deletes a record, it should also delete all records that refer to it. To disable this feature, set ``ondelete`` to "NO ACTION" or "SET NULL".
+- ``notnull=True`` translates into the "NOT NULL" SQL statement. It prevents the database from inserting null values for the field.
+- ``unique=True`` translates into the "UNIQUE" SQL statement and it makes sure that values of this field are unique within the table. It is enforced at the database level.
+- ``uploadfield`` applies only to fields of type "upload". A field of type "upload" stores the name of a file saved somewhere else, by default on the filesystem under the application "uploads/" folder. If ``uploadfield`` is set to True, then the file is stored in a blob field within the same table and the value of ``uploadfield`` is the name of the blob field. This will be discussed in more detail later in the context of SQLFORM.
+- ``uploadfolder`` defaults to the application's "uploads/" folder. If set to a different path, files will uploaded to a different folder. For example,
+``
+Field(...,uploadfolder=os.path.join(request.folder,'static/temp'))
+``:code
+will upload files to the "web2py/applications/myapp/static/temp" folder.
+- ``uploadseparate`` if set to True will upload files under different subfolders of the ''uploadfolder'' folder. This is optimized to avoid too many files under the same folder/subfolder. ATTENTION: You cannot change the value of ``uploadseparate`` from True to False without breaking links to existing uploads. web2py either uses the separate subfolders or it does not. Changing the behavior after files have been uploaded will prevent web2py from being able to retrieve those files. If this happens it is possible to move files and fix the problem but this is not described here.
+- ``uploadfs`` allows you specify a different file system where to upload files, including an Amazon S3 storage or a remote SFTP storage. This option requires PyFileSystem installed. ``uploadfs`` must point to ``PyFileSystem``. ``PyFileSystem``:inxx ``uploadfs``:idxx
+- ``widget`` must be one of the available widget objects, including custom widgets, for example: ``SQLFORM.widgets.string.widget``. A list of available widgets will be discussed later. Each field type has a default widget.
+- ``label`` is a string (or a helper or something that can be serialized to a string) that contains the label to be used for this field in auto-generated forms.
+- ``comment``  is a string (or a helper or something that can be serialized to a string) that contains a comment associated with this field, and will be displayed to the right of the input field in the autogenerated forms.
+- ``writable`` declares whether a field is writable in forms.
+- ``readable`` declares whether a field is readable in forms. If a field is neither readable nor writable, it will not be displayed in create and update forms.
+- ``update`` contains the default value for this field when the record is updated.
+- ``compute`` is an optional function. If a record is inserted or updated, the compute function will be executed and the field will be populated with the function result. The record is passed to the compute function as a ``dict``, and the dict will not include the current value of that, or any other compute field.
+- ``authorize`` can be used to require access control on the corresponding field, for "upload" fields only. It will be discussed more in detail in the context of Authentication and Authorization.
+- ``autodelete`` determines if the corresponding uploaded file should be deleted when the record referencing the file is deleted. For "upload" fields only.
+- ``represent`` can be ``None`` or can point to a function that takes a field value and a row and returns an alternate representation for the field value. Examples:
+``
+db.mytable.name.represent = lambda name,row: name.capitalize()
+db.mytable.other_id.represent = lambda id,row: row.myfield
+db.mytable.some_uploadfield.represent = lambda value,row: \
+    A('get it', _href=URL('download', args=value))
+``:code
 
+``default validators``:inxx
+#### Default validators
 ----------
 **field type** | **default field validators**
 ``string`` | ``IS_LENGTH(length)`` default length is 512
@@ -351,43 +381,17 @@ The ``list:<type>`` fields are special because they are designed to take advanta
 
 The ``json`` field type is pretty much explanatory. It can store any json serializable object. It is designed to work specifically for MongoDB and backported to the other database adapters for portability.
 
--------
-Notice that ``requires=...`` is enforced at the level of forms, ``required=True`` is enforced at the level of the DAL (insert), while ``notnull``, ``unique`` and ``ondelete`` are enforced at the level of the database. While they sometimes may seem redundant, it is important to maintain the distinction when programming with the DAL.
--------
-
-``ondelete``:inxx
+``blob``:inxx
+``blob`` fields are also special. By default, binary data is encoded in base64 before being stored into the actual database field, and it is decoded when extracted. This has the negative effect of using 25% more storage space than necessary in blob fields, but has two advantages. On average it reduces the amount of data communicated between web2py and the database server, and it makes the communication independent of back-end-specific escaping conventions.
 
-- ``ondelete`` translates into the "ON DELETE" SQL statement. By default it is set to "CASCADE". This tells the database that when it deletes a record, it should also delete all records that refer to it. To disable this feature, set ``ondelete`` to "NO ACTION" or "SET NULL".
-- ``notnull=True`` translates into the "NOT NULL" SQL statement. It prevents the database from inserting null values for the field.
-- ``unique=True`` translates into the "UNIQUE" SQL statement and it makes sure that values of this field are unique within the table. It is enforced at the database level.
-- ``uploadfield`` applies only to fields of type "upload". A field of type "upload" stores the name of a file saved somewhere else, by default on the filesystem under the application "uploads/" folder. If ``uploadfield`` is set to True, then the file is stored in a blob field within the same table and the value of ``uploadfield`` is the name of the blob field. This will be discussed in more detail later in the context of SQLFORM.
-- ``uploadfolder`` defaults to the application's "uploads/" folder. If set to a different path, files will uploaded to a different folder. For example,
-``
-Field(...,uploadfolder=os.path.join(request.folder,'static/temp'))
-``:code
-will upload files to the "web2py/applications/myapp/static/temp" folder.
-- ``uploadseparate`` if set to True will upload files under different subfolders of the ''uploadfolder'' folder. This is optimized to avoid too many files under the same folder/subfolder. ATTENTION: You cannot change the value of ``uploadseparate`` from True to False without breaking links to existing uploads. web2py either uses the separate subfolders or it does not. Changing the behavior after files have been uploaded will prevent web2py from being able to retrieve those files. If this happens it is possible to move files and fix the problem but this is not described here.
-- ``uploadfs`` allows you specify a different file system where to upload files, including an Amazon S3 storage or a remote SFTP storage. This option requires PyFileSystem installed. ``uploadfs`` must point to ``PyFileSystem``. ``PyFileSystem``:inxx ``uploadfs``:idxx
-- ``widget`` must be one of the available widget objects, including custom widgets, for example: ``SQLFORM.widgets.string.widget``. A list of available widgets will be discussed later. Each field type has a default widget.
-- ``label`` is a string (or a helper or something that can be serialized to a string) that contains the label to be used for this field in auto-generated forms.
-- ``comment``  is a string (or a helper or something that can be serialized to a string) that contains a comment associated with this field, and will be displayed to the right of the input field in the autogenerated forms.
-- ``writable`` declares whether a field is writable in forms.
-- ``readable`` declares whether a field is readable in forms. If a field is neither readable nor writable, it will not be displayed in create and update forms.
-- ``update`` contains the default value for this field when the record is updated.
-- ``compute`` is an optional function. If a record is inserted or updated, the compute function will be executed and the field will be populated with the function result. The record is passed to the compute function as a ``dict``, and the dict will not include the current value of that, or any other compute field.
-- ``authorize`` can be used to require access control on the corresponding field, for "upload" fields only. It will be discussed more in detail in the context of Authentication and Authorization.
-- ``autodelete`` determines if the corresponding uploaded file should be deleted when the record referencing the file is deleted. For "upload" fields only.
-- ``represent`` can be None or can point to a function that takes a field value and returns an alternate representation for the field value. Examples:
-``
-db.mytable.name.represent = lambda name,row: name.capitalize()
-db.mytable.other_id.represent = lambda id,row: row.myfield
-db.mytable.some_uploadfield.represent = lambda value,row: \
-    A('get it', _href=URL('download', args=value))
-``:code
+``requires``:inxx
+``required``:inxx
+``notnull``:inxx
+Notice that ``requires=...`` is enforced at the level of forms, ``required=True`` is enforced at the level of the DAL (insert), while ``notnull``, ``unique`` and ``ondelete`` are enforced at the level of the database. While they sometimes may seem redundant, it is important to maintain the distinction when programming with the DAL.
 
-``blob``:inxx
-"blob" fields are also special. By default, binary data is encoded in base64 before being stored into the actual database field, and it is decoded when extracted. This has the negative effect of using 25% more storage space than necessary in blob fields, but has two advantages. On average it reduces the amount of data communicated between web2py and the database server, and it makes the communication independent of back-end-specific escaping conventions.
 
+``modify fileds and tables``:inxx
+#### Modify fields and tables
 Most attributes of fields and tables can be modified after they are defined:
 
 ``
@@ -981,22 +985,30 @@ Yes this is unusual and rarely needed.
 #### Rendering rows using represent
 You may wish to rewrite rows returned by select to take advantage of formatting information contained in the represents setting of the fields. 
 
-``rows = db(query).select()
-repr_row = rows.render(0)``:code
+``
+rows = db(query).select()  
+repr_row = rows.render(0)
+``:code
 
 If you don't specify an index, you get a generator to iterate over all the rows:
 
-``for row in rows.render():
-    print row.myfield``:code
+``
+for row in rows.render():
+    print row.myfield
+``:code
 
 Can also be applied to slices:
 
-``for row in rows[0:10].render():
-    print row.myfield``:code
+``
+for row in rows[0:10].render():
+    print row.myfield
+``:code
 
 If you only want to transform selected fields via their "represent" attribute, you can list them in the "fields" argument:
 
-``repr_row = row.render(0, fields=[db.mytable.myfield])``:code
+``
+repr_row = row.render(0, fields=[db.mytable.myfield])
+``:code
 
 Note, it returns a transformed copy of the original Row, so there's no update_record (which you wouldn't want anyway) or delete_record.
 
@@ -1124,7 +1136,7 @@ Given the following action containing a query
 ``SQLTABLE``:inxx
 
 ``
-def index()
+def index():
     return dict(rows = db(query).select())
 ``:code
 
@@ -1554,7 +1566,7 @@ John
 #### ``find``, ``exclude``, ``sort``
 ``find``:inxx ``exclude``:inxx ``sort``:inxx
 
-Some times you need to perform two selects and one contains a subset of a previous select. In this case it is pointless to access the database again. The ``find``, ``exclude`` and ``sort`` objects allow you to manipulate a Rows objects and generate another one without accessing the database. More specifically:
+Some times you need to perform two selects and one contains a subset of a previous select. In this case it is pointless to access the database again. The ``find``, ``exclude`` and ``sort`` objects allow you to manipulate a Rows object and generate another one without accessing the database. More specifically:
 - ``find`` returns a new set of Rows filtered by a condition and leaves the original unchanged.
 - ``exclude`` returns a new set of Rows filtered by a condition and removes them from the original Rows.
 - ``sort`` returns a new set of Rows sorted by a condition and leaves the original unchanged.
@@ -2244,7 +2256,7 @@ db.mytable.myfield.contains(['value1','value2'], all=True)
 ``
 or any value from the list
 ``
-db.mytable.myfield.contains(['value1','value2'], all=false)
+db.mytable.myfield.contains(['value1','value2'], all=False)
 ``
 
 There is a also a ``regexp`` method that works like the ``like`` method but allows regular expression syntax for the look-up expression. It is only supported by PostgreSQL and SQLite.
@@ -3169,10 +3181,10 @@ Web2py provides a script that does this work for you:
 
 ``
 cd web2py
-python scripts/cpdb.py \
-   -f applications/app/databases \
-   -y 'sqlite://storage.sqlite' \
-   -Y 'postgres://username:password@localhost/mydb' \
+python scripts/cpdb.py \\
+   -f applications/app/databases \\
+   -y 'sqlite://storage.sqlite' \\
+   -Y 'postgres://username:password@localhost/mydb' \\
    -d ../gluon
 ``
 
