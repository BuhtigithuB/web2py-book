## Rdzeń

### Opcje linii poleceń

Możliwe jest zrezygnowanie z interfejsu UI i rozpoczęcie pracy z web2py bezpośrednio
z linii poleceń przez wpisanie czegoś takiego:
``hasło``:inxx

``
python web2py.py -a 'your password' -i 127.0.0.1 -p 8000
``:code

Podczas startu web2py tworzony jest plik o nazwie "parameters_8000.py", w którym zapisywane
jest szyfrowane hasło. Jeśli użyje się "<ask>" jako hasła, web2py poprosi o podanie hasła.

Dla dodatkowego bezpieczeństwa można wystartować web2py poleceniem:
``
python web2py.py -a '<recycle>' -i 127.0.0.1 -p 8000
``:code

W tym przypadku web2py ponownie wykorzystuje przechowywane zaszyfrowane hasło.
Jeśli hasło nie zostało podane lub jeśli plik "parameters_8000.py" został usunięty,
nie jest dostępny internetowy interfejs administracyjny.

``PAM``:inxx
W niektórych systemach Unix/Linux, jeśli hasło to
``
<pam_user:some_user>
``:code

web2py używa hasła PAM konta systemu operacyjnego ``some_user`` do uwierzytelniania
administratora, chyba że jest zablokowany przez konfigurację PAM.

-------
Platforma web2py zwykle działa z CPython (implementaja C interpretera Python stworzona
przez Guido van Rossum), ale również może działać z PyPy i Jython. Ta ostatnia
implementacja umożliwia używanie web2py w kontekście infrastruktury Java EE.
W celu umożliwienia stosowania Jythona, wystarczy zamienić wyrażenie "python web2py.py ..."
na "jython web2py.py". Szczegółowe informacje o instalacji Jython, modułu zxJDBC
wymaganego do dostępu do bazy danych można znaleźć w rozdziale 14.
-------

Skrypt "web2py.py" może przyjmować wiele argumentów linii poleceń określających
maksymalną liczbę wątków, udostępniających SSL itd. W celu uzyskania pełnego wykazu
wpisz:

``linia poleceń``:inxx
``
>>> python web2py.py -h
Usage: python web2py.py

web2py Web Framework startup script. ATTENTION: unless a password
is specified (-a 'passwd'), web2py will attempt to run a GUI.
In this case command line options are ignored.

Options:
  --version             show program's version number and exit
  -h, --help            show this help message and exit
  -i IP, --ip=IP        IP address of the server (e.g., 127.0.0.1 or ::1);
                        Note: This value is ignored when using the
                        'interfaces' option.
  -p PORT, --port=PORT  port of server (8000)
  -a PASSWORD, --password=PASSWORD
                        password to be used for administration (use -a
                        "<recycle>" to reuse the last password))
  -c SSL_CERTIFICATE, --ssl_certificate=SSL_CERTIFICATE
                        file that contains ssl certificate
  -k SSL_PRIVATE_KEY, --ssl_private_key=SSL_PRIVATE_KEY
                        file that contains ssl private key
  --ca-cert=SSL_CA_CERTIFICATE
                        Use this file containing the CA certificate to
                        validate X509 certificates from clients
  -d PID_FILENAME, --pid_filename=PID_FILENAME
                        file to store the pid of the server
  -l LOG_FILENAME, --log_filename=LOG_FILENAME
                        file to log connections
  -n NUMTHREADS, --numthreads=NUMTHREADS
                        number of threads (deprecated)
  --minthreads=MINTHREADS
                        minimum number of server threads
  --maxthreads=MAXTHREADS
                        maximum number of server threads
  -s SERVER_NAME, --server_name=SERVER_NAME
                        server name for the web server
  -q REQUEST_QUEUE_SIZE, --request_queue_size=REQUEST_QUEUE_SIZE
                        max number of queued requests when server unavailable
  -o TIMEOUT, --timeout=TIMEOUT
                        timeout for individual request (10 seconds)
  -z SHUTDOWN_TIMEOUT, --shutdown_timeout=SHUTDOWN_TIMEOUT
                        timeout on shutdown of server (5 seconds)
  --socket-timeout=SOCKET_TIMEOUT
                        timeout for socket (5 second)
  -f FOLDER, --folder=FOLDER
                        location of the applications folder (also known as directory) 
  -v, --verbose         increase --test verbosity
  -Q, --quiet           disable all output
  -D DEBUGLEVEL, --debug=DEBUGLEVEL
                        set debug output level (0-100, 0 means all, 100 means
                        none; default is 30)
  -S APPNAME, --shell=APPNAME
                        run web2py in interactive shell or IPython (if
                        installed) with specified appname (if app does not
                        exist it will be created). APPNAME like a/c/f (c,f
                        optional)
  -B, --bpython         run web2py in interactive shell or bpython (if
                        installed) with specified appname (if app does not
                        exist it will be created). Use combined with --shell
  -P, --plain           only use plain python shell; should be used with
                        --shell option
  -M, --import_models   auto import model files; default is False; should be
                        used with --shell option
  -R PYTHON_FILE, --run=PYTHON_FILE
                        run PYTHON_FILE in web2py environment; should be used
                        with --shell option
  -K SCHEDULER, --scheduler=SCHEDULER
                        run scheduled tasks for the specified apps: expects a
                        list of app names as -K app1,app2,app3 or a list of
                        app:groups as -K app1:group1:group2,app2:group1 to
                        override specific group_names. (only strings, no
                        spaces allowed. Requires a scheduler defined in the
                        models
  -X, --with-scheduler  run schedulers alongside webserver
  -T TEST_PATH, --test=TEST_PATH
                        run doctests in web2py environment; TEST_PATH like
                        a/c/f (c,f optional)
  -C, --cron            trigger a cron run manually; usually invoked from a
                        system crontab
  --softcron            triggers the use of softcron
  -Y, --run-cron        start the background cron process
  -J, --cronjob         identify cron-initiated command
  -L CONFIG, --config=CONFIG
                        config file
  -F PROFILER_FILENAME, --profiler=PROFILER_FILENAME
                        profiler filename
  -t, --taskbar         use web2py gui and run in taskbar (system tray)
  --nogui               text-only, no GUI
  -A ARGS, --args=ARGS  should be followed by a list of arguments to be passed
                        to script, to be used with -S, -A must be the last
                        option
  --no-banner           Do not print header banner
  --interfaces=INTERFACES
                        listen on multiple addresses: "ip1:port1:key1:cert1:ca
                        _cert1;ip2:port2:key2:cert2:ca_cert2;..."
                        (:key:cert:ca_cert optional; no spaces; IPv6 addresses
                        must be in square [] brackets)
  --run_system_tests    runs web2py tests
``:code

------
Uwaga: Opcja ``-W``, używana do instalacji usługi Windows, została usunięta.
Proszę zobaczyć [[nssm w rozdziale Deployment Recipes ../13/#nssm]]
------

Opcje pisane małymi literami są używane do konfiguracji serwera internetowego.
Opcja ``-L`` informuje web2py aby czytał opcje konfiguracyjne z pliku, ``-W``
instaluje web2py jako usługę Windows, podczas gdy opcje ``-S``, ``-P`` i ``-M``
uruchamiają interaktywną powłokę Pythona. Opcja ``-T`` wyszukuje i uruchamia
kontroler doctests w środowisku wykonawczym web2py. Poniższy przykład uruchamia
doctests ze wszystkich kontrolerów w aplikacji "welcome":
``
python web2py.py -vT welcome
``:code

jeśli uruchomi się web2py jako usługę Windows przez opcję ``-W``, to nie jest wygodne
przekazywanie konfiguracji przy użyciu argumentów linii poleceń. Z tego powodu
w folderze web2py znajduje się prosty plik konfiguracyjny "options_std.py" dla
wewnętrznego serwera internetowego:

``
import socket
import os

ip = '0.0.0.0'
port = 80
interfaces = [('0.0.0.0', 80)]
               #,('0.0.0.0',443,'ssl_private_key.pem','ssl_certificate.pem')]
password = '<recycle>'  # ## <recycle> means use the previous password
pid_filename = 'httpserver.pid'
log_filename = 'httpserver.log'
profiler_filename = None
ssl_certificate = None  # 'ssl_certificate.pem'  # ## path to certificate file
ssl_private_key = None  # 'ssl_private_key.pem'  # ## path to private key file
#numthreads = 50 # ## deprecated; remove
minthreads = None
maxthreads = None
server_name = socket.gethostname()
request_queue_size = 5
timeout = 30
shutdown_timeout = 5
folder = os.getcwd()
extcron = None
nocron = None
``:code

Plik ten zawiera wartości domyślne web2py. Jeśli edytuje się ten plik, to musi się
go importować jawnie z użyciem opcji ``-L`` linii poleceń. Działa to tylko gdy
uruchomi się web2py jako usługę Windows.

### Proces przetwarzania

Proces przetwarzania danych w web2py jest następujący:
- Żądanie HTTP dociera do serwera internetowego (wbudowanego serwera Rocket lub innego serwera połączonego z web2py poprzez WSGI lub inny adapter). Serwer internetowy obsługuje każde żądanie w oddzielnym wątku, równolegle.
- Nagłówek żądania HTTP jest parsowany i przekazywany do dyspozytora (''ang. dispatcher'') (wyjaśnionego dalej w tym rozdziale).
- Dyspozytor decyduje, która z zainstalowanych aplikacji będzie obsługiwać żądanie i odwzorowuje PATH_INFO z adresu URL na wywołanie funkcji. Każdy adres URL odpowiada jednemu wywołaniu funkcji.
- Żądania dla plików w folderze statycznym są obsługiwane bezpośrednio a większe pliki są automatycznie strumieniowane do klienta.
- Żądania pozostałe (nie dotyczące plików statycznych) są odwzorowywane do akcje (tj. funkcji w pliku kontrolera z żądanej aplikacji).
- Przed wywołaniem akcji dzieje się kilka rzeczy: jeśli żądanie zawiera nagłówek ciasteczka dla aplikacji, pobierany jest obiekt sesji; jeśli nie, tworzony jest id sesji (ale plik sesji jest zapisywany później); tworzone jest środowisko dla żądania; w tym środowisku wykonywane są modele.
- Na koniec, we wstępnie zbudowanym środowisku wykonywana jest akcja kontrolera.
- Jeśli akcja zwraca ciąg znakowy, to jest on zwracany klientowi (lub jeśli akcja zwraca obiekt helpera HTML web2py, to jest on serializowany i zwracany klientowi).
- Jeśli akcja zwraca element iterowalny, to zostaje na nim zastosowana pętla i strumień danych przesyłany klientowi.
- Jeśli akcja zwraca słownik, web2py próbuje zlokalizować widok do renderowana słownika. Widok musi mieć tą sama nazwę co akcja (chyba, że określono to inaczej) i to samo rozszerzenie, co żądana strona (domyślnie .html); w przypadku błędu web2py może zastosować widok ogólny (jeśli jest dostępny i włączony). Widok widzi każdą zmienną zdefiniowana w modelach, jak również te zmienne w słowniku zwracane przez akcje, ale nie ma tu zmiennych globalnych zdefiniowanych w kontrolerze.
- Cały kod wykonywany jest w pojedynczej transakcji bazy danych, chyba że określono to inaczej.
- Jeśli kod użytkownika powiedzie się, transakcja jest zatwierdzana.
- Jeśli kod użytkownika nie powiedzie się, w bilecie zostaje jest zapisany komunikat z ostatniego wywołania (''ang. traceback'') i uzytkownikowi zostaje wysłany identyfikator biletu. Tylko administrator systemu może wyszukiwać i odczytywać w bilecie komunikat z ostatniego wywołania.

Istnieje kilka uwag, o których warto pamiętać:
- Modele w tym samym folderze (podfolderze) są wykonywane w alfabetycznej kolejności.
- Każda zmienna zdefiniowana w modelu będzie widoczna dla innych modeli w kolejności alfabetycznej, dla kontrolerów i widoków.
``models_to_run``:inxx
- Modele w podfolderach są wykonywane warunkowo . Na przykład, jeśli użytkownik wysyła żądanie "/a/c/f", gdzie "a" to aplikacja, "c" to kontroler a "f" to funkcja
(akcja), to następnie wykonywane są następujące modele:

``
applications/a/models/*.py
applications/a/models/c/*.py
applications/a/models/c/f/*.py
``
Zachowanie takie jest wymuszane domyślnie. Zmieniając listę wyrażeń regularnych
``response.models_to_run`` można wymusić takie zachowanie, jakie się chce (zobacz
do [[response #response_models_to_run]] w celu poznania szczegółów)

- Wykonywany jest żądany kontroler i wywoływana jest potrzebna funkcja. Oznacza to, że dla każdego żądania  dla określonego kontrolera wykonywany jest również cały kod na najwyższym poziomie w tym kontrolerze.
- Widok jest wywoływany tylko wtedy, gdy akcja zwraca słownik.
- Jeżeli widok nie zostanie znaleziony, web2py spróbuje użyć widoku ogólnego. Domyślnie, widok ogólne są wyłączone, lecz aplikacja 'welcome' zawiera linię w /models/db.py do ich włączenie, ale tylko na localhost. Mogą one być włączone dla każdego typu i każdej akcji (za pomocą ``response.generic_patterns``). Ogólnie, ogólne widoki są narzędziem programistycznym i zazwyczaj nie powinny być wykorzystywane w środowisku produkcyjnym. Jeśli chce się aby jakieś akcje wykorzystywały widok ogólny, trzeba umieścić je na liście ``response.generic_patterns`` (omówionej w rozdziale Usługi).

Możliwe zachowania akcji są następujące:

**Zwracanie ciąga znakowego**
``
def index(): return 'data'
``

**Zwracanie słownika dla widoku**:
``
def index(): return dict(key='value')
``

**Zwracanie wszystkich lokalnych zmiennych**:
``
def index(): return locals()
``

**Przekierowanie użytkowników do innej strony**:
``
def index(): redirect(URL('other_action'))
``

**Zwracanie strony HTTP innej niż "200 OK"**:
``
def index(): raise HTTP(404)
``

**Zwracanie helpera** (na przykład FORM):
``
def index(): return FORM(INPUT(_name='test'))
``
(jest to najczęściej stosowane dla wywołań zwrotnych Ajax i komentarzy, patrz rozdział 12)

Gdy akcja zwraca słownik, to może zawierać kod generowany przez helpery, w tym
formularze oparte na tabelach bazy danych lub formularze z fabryki, na przykład:

``
def index(): return dict(form=SQLFORM.factory(Field('name')).process())
``
(Wszystkie formularze generowane przez web2py wykorzystują zgłoszenia zwrotne
(''ang. postback''), patrz rozdział 3)

### Rozdzielanie
``mapowanie url``:inxx ``odwzorowywanie url``:inxx ``rozdzielanie``:inxx

Platforma web2py odwzorowuje adres URL formularza o postaci:

``
http://127.0.0.1:8000/a/c/f.html
``:code

do funkcji ``f()`` w kontrolerze "c.py" w aplikacji"a". Jeśli ``f`` nie jest podana,
web2py stosuje domyślnie funkcję ``index`` kontrolera. Jeśli ``c`` nie jest podany,
web2py stosuje domyślnie kontroler "default.py" a przy braku ``a``, web2py wykorzystuje
domyślnie aplikację ``init``. Jeśli nie ma aplikacji ``init``, web2py próbuje uruchomić
aplikację ``welcome``. Jest to pokazane na poniższym obrazie:

[[image @///image/pl5700.png center 480px]]

Domyślnie, każde nowe żądanie tworzy nową sesję. Ponadto, ciasteczko sesji jest
zwracane do przeglądarki klienta w celu śledzenia sesji.

Rozszerzenie ``.html`` jest opcjonalne i jest rozszerzeniem domyślnym. Rozszerzenie
determinuje rozszerzenie widoku, który renderuje wyjście funkcji kontrolera ``f()``.
Pozwala aby ta sama zawartość była serwowana w wielu formatach (html, xml, json, rss itd.).

-------
Funkcje posiadające argumenty lub rozpoczynające się dwoma znakami podkreślenia
nie są publicznie widoczne i mogą tylko być wywoływane przez inne funkcje.
-------

``pliki statyczne``:inxx
Istnieje wyjątek zrobiony dla adresów URL formularzy o postaci:
``
http://127.0.0.1:8000/a/static/filename
``:code

Nie ma kontrolera o nazwie "static". web2py interpretuje to jako żądanie dla pliku
o nazwie "filename" w podfolderze "static" aplikacji "a".

``PARTIAL CONTENT``:inxx ``IF_MODIFIED_SINCE``:inxx
Po pobraniu plików statycznych, web2py nie tworzy sesji, ani nie wystawia ciasteczka
lub wykonuje modele. web2py zawsze strumieniuje pliki statyczne kawałkami o rozmiarze
1MB i wysyła PARTIAL CONTENT, gdy klient wysyła żądanie RANGE dla podzbioru pliku.

Platforma web2py również obsługuje protokół IF_MODIFIED_SINCE i nie wysyła pliku,
jeśli jest on już przechowywany w pamięci podręcznej przeglądarki i jeśli plik
ten nie został zmieniony od czasu przesłania go do przeglądarki.

Podczas linkowania do plików audio lub wideo w folderze statycznym, jeśli chce się
wymusić na przeglądarce aby pobierała pliki audio lub wideo, a nie je strumieniowała
w odtwarzaczu medialnym, trzeba dodać ``?attachment`` do adresu URL. To poinformuje
web2py aby ustawił nagłówek ``Content-Disposition`` odpowiedzi HTTP na "attachment".
Na przykład:

``
<a href="/app/static/my_audio_file.mp3?attachment">Download</a>
``:code

Po kliknięciu powyższego odnośnika, przeglądarka poprosi użytkownika aby pobrał
plik MP3 zamiast go strumieniować w odtwarzaczu audio. Tak jak opisano [[poniżej #response]],
można również bezpośrednio ustawiać nagłówki odpowiedzi HTTP przypisując ``dict``
nazw nagłówków i ich wartości do ``response.headers``.

``request.application``:inxx ``request.controller``:inxx ``request.function``:inxx ``GET``:inxx ``POST``:inxx ``request.args``:inxx
web2py odwzorowuje żądania GET i POST formularza:
``
http://127.0.0.1:8000/a/c/f.html/x/y/z?p=1&q=2
``:code

do funkcji ``f`` w kontrolerze "c.py" w aplikacji ``a`` i przechowuje parametry
adresu URL w zmiennej ``request`` jak niżej:
``
request.args = ['x', 'y', 'z']
``:code

i:
``
request.vars = {'p':1, 'q':2}
``:code

i:
``
request.application = 'a'
request.controller = 'c'
request.function = 'f'
``:code

W powyższym przykładzie zarówno ``request.args[i]`` jak i ``request.args(i)`` mogą
być używane do pobrania i-tego elementu ``request.args``, ale gdy pierwszy zgłasza
wyjątek jeśli na liście nie występuje index, to drugi zwraca w takim przypadku None.

``request.url``:inxx
``
request.url
``:code

przechowuje pełny adres URL bieżącego żądania (nie dołączając zmiennych GET).

``request.ajax``:inxx ``request.cid``:inxx

``
request.ajax
``:code

domyślnie wartość False, ale True jeśli web2py stwierdzi, że akcja została wywołana
przez żądanie Ajax.

Jeśli żądanie jest żądaniem Ajax i jeśli zostało zainicjowane przez komponent
web2py, nazwę komponentu można znaleźć w:

``
request.cid
``:code

Komponenty omówione są bardziej szczegółowo w rozdziale 12.

``request.get_vars``:inxx ``request.post_vars``:inxx ``request.vars``:inxx
Jeśli żądanie HTTP jest typu GET, to ``request.env.request_method`` zostaje
ustawiona na "GET", jeśli natomiast typu POST, to na "POST". 
Parametry zapytania z adresu URL są przechowywane w zmiennej ``request.get_vars``.
Zmienna ``request.post_vars`` zawiera wszystkie parametry przekazane do ciała żądania (zazwyczaj POST, PUT lub DELETE).
Słownik ``request.vars`` zawiera je oba (``get_vars`` i ``post_vars``)

Platforma web2py przechowuje zmienne środowiskowe WSGI i web2py w zmiennej
``request.env``, na przykład:
``
request.env.path_info = 'a/c/f'
``:code

a nagłówki HTTP w zmiennych środowiskowych, na przykład:
``
request.env.http_host = '127.0.0.1:8000'
``:code

-------
Proszę zwrócić uwagę, że web2py sprawdza wszystkie adresy URL, aby zapobiegać
atakom z przeglądaniem katalogów.
-------

Adresy URL mogą zawierać tylko znaki alfanumeryczne, znaki podkreślenia i ukośniki.
Parametr ``args`` nie może zawierać występujących po sobie kropek. Spacje są
zamieniane na znaki podkreślenia przed walidacją. Jeśli składnia adresu URL jest
nieprawidłowa, web2py zwraca komunikat błędu 400 HTTP``http-w``:cite ``http-o``:cite .

Jeśli adres URL zgodny jest z żądaniem dla plików statycznych, web2py po prostu
czyta  i zwraca (strumieniuje) żądany plik.

Jeśli adres URL nie żąda pliku statycznego, web2py przetwarza żądanie w następującej kolejności:
- Analizuje ciasteczka.
- Tworzy środowisko.
- Inicjuje obiekty  ``request``, ``response``, ``cache``.
- Otwiera isteniejący obiekt  ``session`` lub tworzy nowy.
- Wykonuje modele należące do żądanej aplikacji.
- Wykonuje żądaną funkcję akcji kontrolera.
- Jeśli funkcja zwraca słownik, wykonuje związany widok.
- W razie sukcesu zatwierdza wszystkie otwarte transakcje.
- Zapisuje sesję.
- Zwraca odpowiedź HTTP.

Proszę zauważyć, że kontroler i widok są wykonywane w różnych kopiach tego samego
środowiska, dlatego widok nie widzi kontrolera, ale widzi modele i zmienne zwracane
przez funkcje akcji kontrolera.

Jeśli zostaje wywołany wyjątek (inny niż HTTP), web2py wykonuje następujące rzeczy:
- Zapisuje komunikat z ostatniego wywołania (traceback) w pliku błędu i przypisuje mu numer biletu.
- Wycofuje wszystkie otwarte transakcje bazy danych.
- Zwraca stronę błędu raportującą numer biletu.

Jeśli wyjątek jest wyjątkiem ``HTTP``, to zakłada się, że zamierzone zachowanie
(na przykład, przekierowanie ``HTTP``) i wszystkie otwarte transakcje bazy danych
zostały zatwierdzone. Zachowanie późniejsze jest określone przez sam wyjątek ``HTTP``.
Klasa wyjątku ``HTTP`` nie jest standardowym wyjątkiem Pythona – jest zdefiniowana
przez web2py.

### Biblioteki

Biblioteki web2py są dostępne dla aplikacji użytkownika jako obiekty globalne.
Na przykład obiekty ``request``, ``response``, ``session``, ``cache``, klasy helperów,
walidatorów, API DAL oraz  funkcje ``T`` i ``redirect``.

Obiekty te sa zdefiniowane w nastęþujacych plikach rdzenia:
``
web2py.py
gluon/__init__.py    gluon/highlight.py   gluon/restricted.py  gluon/streamer.py
gluon/admin.py       gluon/html.py        gluon/rewrite.py     gluon/template.py
gluon/cache.py       gluon/http.py        gluon/rocket.py      gluon/storage.py
gluon/cfs.py         gluon/import_all.py  gluon/sanitizer.py   gluon/tools.py
gluon/compileapp.py  gluon/languages.py   gluon/serializers.py gluon/utils.py
gluon/contenttype.py gluon/main.py        gluon/settings.py    gluon/validators.py
gluon/dal.py         gluon/myregex.py     gluon/shell.py       gluon/widget.py
gluon/decoder.py     gluon/newcron.py     gluon/sql.py         gluon/winservice.py
gluon/fileutils.py   gluon/portalocker.py gluon/sqlhtml.py     gluon/xmlrpc.py
gluon/globals.py     gluon/reserved_sql_keywords.py
``:code

------
Proszę zauważyć, że wiele z tych modułów, w szczególności ``dal`` (warstwa abstrakcji
bazy danych), ``template`` (język szablonowania), ``rocket`` (serwer internetowy)
i ``html`` (helpery) nie mają zależności i mogą być używane poza web2py.
-----

Skompresowane przez gzip archiwum tar aplikacji dostarczane wraz z web2py to
``
welcome.w2p
``:code

Aplikacja ta jest tworzona podczas instalacji i nadpisywana podczas aktualizacji.

-------
Podczas pierwszego uruchomienia web2py tworzy dwa nowe foldery: deposit i applications.
Folder deposit jest używany jako tymczasowy magazyn dla instalowania i odinstalowywania
aplikacji.

Podczas pierwszego uruchomienia web2py i po aktualizacji, aplikacja "welcome" jest
pakowana do pliku "welcome.w2p" aby mogła być używana jako aplikacja szkieletowa.
-------

Kiedy web2py zostaje uaktualniany, to dostarczany jest wraz z plikiem o nazwie
"NEWINSTALL". Jeśli web2py odnajdzie ten plik, to rozumie, że uaktualnienie zostało
zrealizowane, dlatego usuwa plik "welcome.w2p" i tworzy w jego miejsce nowy, o tej
samej nazwie.

Aktualna wersja web2py jest zapisywana w polu "VERSION" i spełnia standardową notację
wersjonowania, wg której identyfikator budowania jest znacznikiem czasowym budowania.

Jednostkowe testy web2py znajduja się w
``
gluon/tests/
``:code

Istnieją handlery  do połączeń z różnymi serwerami internetowymi:
``
cgihandler.py       # nie zalecany
gaehandler.py       # dla Google App Engine
fcgihandler.py      # dla FastCGI
wsgihandler.py      # dla WSGI
isapiwsgihandler.py # dla IIS
modpythonhandler.py # przestarzały
``:code

("fcgihandler" wywołuje "gluon/contrib/gateways/fcgi.py" stworzony przez Allana Saddi) i

``
anyserver.py
``

który jest skryptem do współdziałania z wieloma serwerami internetowymi, co opisane
zostało w rozdziale 13.

W katalogu "examples" znajdują się trzy przykładowe pliki:
``
options_std.py
routes.parametric.example.py
routes.patterns.example.py
``:code

Wszystkie te pliki trzeba skopiować do głównego katalogu (tam gdzie jest plik web2py.py
lub web2py.exe) i można je edytować, zgodnie ze swoimi potrzebami.
Pierwszy jest opcjonalnym plikiem konfiguracyjnym, który może być przekazany do web2py.py
przy pomocy opcji ``-L``. Drugi jest przykładem pliku mapującego adres URL. Będzie
ładowany automatycznie, jeśli zmieni się jego nazwę na "routes.py". Trzeci jest
alternatywna składnią dla mapowania adresów URL i może być też przemianowany na
"routes.py" (lub skopiowany do tego pliku).

Pliki
``
app.example.yaml
queue.example.yaml
``:code

są przykładowymi plikami konfiguracyjnymi używanymi do wdrożeń na Google App Engine.
Można przeczytać więcej na ten temat w rozdziale "Receptury wdrożeniowe" i na stronach
dokumentacji Google.

Istnieją również dodatkowe biblioteki, niektóre opracowane przez osoby trzecie:

**feedparser**``feedparser``:cite  opracowana przez by Marka Pilgrima dla odczytu kanałów RSS i Atom:
``
gluon/contrib/__init__.py
gluon/contrib/feedparser.py
``:code

**markdown2**``markdown2``:cite  opracowana przez Trenta Micka dla znaczników wiki:
``
gluon/contrib/markdown/__init__.py
gluon/contrib/markdown/markdown2.py
``:code

**markmin** język znaczników:
``
gluon/contrib/markmin
``:code
(patrz [[składnia MARKMIN ../05/#markmin_syntax]] w celu uzyskania wiecej informacji)

**fpdf** stworzona przez Mariano Reingart dla generowania dokumentów PDF:
``
gluon/contrib/fpdf
``
Nie są one udokumentowane w tej książce, ale są hostowane i udokumentowane tutaj:
``
http://code.google.com/p/pyfpdf/
``

**pysimplesoap** jest implementacją lekkiego serwerem SOAP stworzona przez  Mariano Reingarta:

``
gluon/contrib/pysimplesoap/
``:code

**simplejsonrpc** jest lekkim klientem JSON-RPC stworzonym przez Mariano Reingarta: ``jsonrpc``:inxx

``
gluon/contrib/simplejsonrpc.py
``

**memcache**``memcache``:cite  API Pythona stworzone przez Evana Martina:
``
gluon/contrib/memcache/__init__.py
gluon/contrib/memcache/memcache.py
``

**redis_cache** ``redis``:inxx jest modułem pamięci podręcznej dla bazy danych redis:
``
gluon/contrib/redis_cache.py
``

**gql**, port DAL dla Google App Engine:
``
gluon/contrib/gql.py
``:code

**memdb**, port DAL górnej części memcache:
``
gluon/contrib/memdb.py
``:code

**gae_memcache** to API wykorzystujące memcache dla Google App Engine:
``
gluon/contrib/gae_memcache.py
``:code

**pyrtf**``pyrtf``:cite  do generowania dokumentów Rich Text Format (RTF), opracowana przez Simona Cusacka i  poprawiona przez Granta Edwardsa:
``
gluon/contrib/pyrtf/
``:code

**PyRSS2Gen**``pyrss2gen``:cite  opracowana przez Dalke Scientific Software do generowania kanałów RSS:
``
gluon/contrib/rss2.py
``:code

**simplejson**``simplejson``:cite  standardowa biblioteka do paesowania i pisania obiektów JSON opracowana przez Boba Ippolito:
``
gluon/contrib/simplejson/
``:code

**Google Wallet** ``googlewallet``:cite
dostarcza przyciski "pay now" linkujący Google jako procesor płatności:
``
gluon/contrib/google_wallet.py
``:code

**Stripe.com** ``stripe``:cite dostarcza proste API do przyjmowania płatności kartami kredytowymi::
``
gluon/contrib/stripe.py
``:code

**AuthorizeNet** ``authorizenet``:cite dostarcza API do przyjmowania płatności kartami kredytowymi poprzez sieć Authorize.net
``
gluon/contrib/AuthorizeNet.py
``:code

**Dowcommerce** ``dowcommerce``:cite API przetwarzania kart kredytowych:
``
gluon/contrib/DowCommerce.py
``:code

**PaymentTech** API przetwarzania kart kredytowych::

``
gluon/contrib/paymentech.py
``:code

**PAM**``PAM``:cite  API uwierzytelniania stworzone przez Chrisa AtLee:
``
gluon/contrib/pam.py
``:code

Klasyfikator Bayesian do wypełniania bazy danych danymi fikcyjnymi w celach testowych:
``
gluon/contrib/populate.py
``:code

Plik z API do uruchamiania na Heroku.com : ``heroku``:inxx

``
gluon/contrib/heroku.py
``:code

Plik umożliwiający interakcje z paskiem zadań w Windows, gdy web2py jest uruchomiony jako usługa:
``
gluon/contrib/taskbar_widget.py
``:code

Opcjonalne **login_methods** i login_forms używane do uwierzytelniania:
``
gluon/contrib/login_methods/__init__.py
gluon/contrib/login_methods/basic_auth.py
gluon/contrib/login_methods/browserid_account.py
gluon/contrib/login_methods/cas_auth.py
gluon/contrib/login_methods/dropbox_account.py
gluon/contrib/login_methods/email_auth.py
gluon/contrib/login_methods/extended_login_form.py
gluon/contrib/login_methods/gae_google_account.py
gluon/contrib/login_methods/ldap_auth.py
gluon/contrib/login_methods/linkedin_account.py
gluon/contrib/login_methods/loginza.py
gluon/contrib/login_methods/oauth10a_account.py
gluon/contrib/login_methods/oauth20_account.py
gluon/contrib/login_methods/oneall_account.py
gluon/contrib/login_methods/openid_auth.py
gluon/contrib/login_methods/pam_auth.py
gluon/contrib/login_methods/rpx_account.py
gluon/contrib/login_methods/x509_auth.py
``:code

Paltforma web2py zawiera również folder z przydatnymi skryptami, w tym
``
scripts/setup-web2py-fedora.sh
scripts/setup-web2py-ubuntu.sh
scripts/setup-web2py-nginx-uwsgi-ubuntu.sh
scripts/setup-web2py-heroku.sh
scripts/update-web2py.sh
scripts/make_min_web2py.py
...
scripts/sessions2trash.py
scripts/sync_languages.py
scripts/tickets2db.py
scripts/tickets2email.py
...
scripts/extract_mysql_models.py
scripts/extract_pgsql_models.py
...
scripts/access.wsgi
scripts/cpdb.py
``:code

Skrypty ``setup-web2py-*`` są szczególnie przydatne, ponieważ próbują realizować
od podstaw pełną instalację i konfigurację środowiska produkcyjnego web2py.
Niektóre z nich zostały omówione w rozdziale 14, ale wszystkie z nich zawierają
wewnątrz opis dokumentacyjny, który wyjaśnia ich przeznaczenie i używanie.

Wreszcie web2py zawiera pliki wymagane do budowy dystrybucji binarnej.
``
Makefile
setup_exe.py
setup_app.py
``:code

Są to skrypty konfiguracyjne odpowiednio dla **py2exe** i **py2app** i są tylko
wymagane przy budowaniu dystrybucji binarnej web2py. NIGDY NIE ZAJDZIE POTRZEBA
ICH URUCHOMIENIA.

Aplikacje web2py zawierają dodatkowe pliki, zwłaszcza biblioteki JavaScript osób
trzecich, takie jak jQuery, calendar i Codemirror. Ich autorzy są wymienieniu
w plikach tych bibliotek.

### Aplikacje

Aplikacje stworzone w web2py są złożone z następujących części (znajdujących sie w swoich katalogach):
- **models** (modele) opisuje reprezentację danych w tabelach bazy danych i relacje pomiędzy tabelami;
- **controllers** (kontrolery) opisuje logikę aplikację i proces przetwarzania;
- **views** (widoki) opisuje jak dane powinny być prezentowane użytkownikowi przy użyciu HTML i JavaScript;
- **languages** (języki) opisują jak przetłumaczyć ciągy tekstowe w aplikacji na różne obsługiwane języki;
- **static files** (pliki statyczne) nie wymagają przetwarzania (np. obrazy, arkusze stylów CSS itd.);
- **ABOUT** i **README** - te pliki są oczywiste;
- **errors** (błędy) przechowuje sie tu raporty o błędach wygenerowane przez aplikację;
- **sessions** (sesje) przechowuje się tu informacje odnoszące się do każdego określonego użytkownika;
- **databases** (bazy danych) przechowuje się tu bazy danych SQLite i dodatkowe tabelaryczne informacje;
- **cache** (pamięc podręczna) przechowuje się tu buforowane elementy aplikacje;
- **modules** (moduły) są tu opcjonalne moduły Pythona;
- **private** (prywatne) pliki, które są dostępne dla kontrolerów ale nie bezpośrednio dla programisty;
- **uploads** (przesłane) pliki są dostępne dla modeli ale nie bezpośrednio dla programisty (np. pliki przesłane na serwer przez użytkowników aplikacji).
- **tests** (testy) jest katalogiem do przechowywania skrytów testów, wyposażenia i makiet.

Modele, widoki, kontrolery, języki i pliki statyczne są dostępne poprzez interfejs
administracyjny [design]. Pliki ABOUT i README oraz katalog errors są również dostępne
przez interfejs administracyjny za pośrednictwem odpowiednich elementów menu. Pliki
sesji, pamięci podręcznej, modułów i pliki prywatne są dostępne przez aplikacje,
ale nie za pomocą interfejsu administracyjnego.

Wszystko jest uporządkowane w jasne struktury katalogów, które są replikowane dla
każdej zainstalowanej aplikacji web2py, choć użytkownik nie potrzebuje bezpośredniego
dostępu do systemu plików:

``o aplikacji``:inxx ``licecja``:inxx ``pamięć podręczna``:inxx ``kontrolery``:inxx ``bazy danych``:inxx ``błedy``:inxx ``języki``:inxx ``modele``:inxx ``moduły``:inxx ``prywatne pliki``:inxx ``sesje``:inxx ``pliki statyczne``:inxx ``testy``:inxx ``pliki przesłane``:inxx ``widoki``:inxx ``__init__.py``:inxx
``
__init__.py  ABOUT        LICENSE    models    views
controllers  modules      private    tests     cron
cache        errors       upload     sessions  static
``:code

Plik "__init__.py" to pusty plik wymagany w celu umożliwienia Pythonowi (i web2py)
importowanie modułów w katalogu ``modules``.

Proszę zwrócić uwagę, że aplikacja **admin** po prostu dostarcza interfejs internetowy
dla aplikacji web2py w systemie plików serwera. Aplikacje web2py mogą być również
tworzone i programowane z poziomu linii poleceń lub poprzez wybrany edytor tekstowy
(np. w IDE) – nie jest konieczne korzystanie z interfejsu **admin** w przeglądarce.
Nową aplikację można utworzyć ręcznie przez replikowanie powyższej struktury katalogów,
np. "applications/newapp/" (lub po prostu rozpakowanie pliku ``welcome.w2p`` do
katalogu nowej aplikacji). Pliki aplikacji mogą być również stworzone i edytowane
z poziomu linii poleceń bez konieczności korzystania z interfejsu **admin**.

### API

Modele, kontrolery i widoki są wykonywane w środowisku, w którym następujące obiekty
są już za nas zaimportowane:

**Obiekty globalne:** ``request``:inxx ``response``:inxx ``session``:inxx ``cache``:inxx

``
request, response, session, cache
``:code

**Umiędzynarodowienie :** ``T``:inxx ``umiędzynarodowienie``:inxx

``
T
``:code

**Nawigacja:** ``redirect``:inxx ``HTTP``:inxx

``
redirect, HTTP
``:code


**Helpery:** ``helpery``:inxx

``
XML, URL, BEAUTIFY

A, B, BODY, BR, CENTER, CODE, COL, COLGROUP,
DIV, EM, EMBED, FIELDSET, FORM, H1, H2, H3, H4, H5, H6,
HEAD, HR, HTML, I, IFRAME, IMG, INPUT, LABEL, LEGEND,
LI, LINK, OL, UL, META, OBJECT, OPTION, P, PRE,
SCRIPT, OPTGROUP, SELECT, SPAN, STYLE,
TABLE, TAG, TD, TEXTAREA, TH, THEAD, TBODY, TFOOT,
TITLE, TR, TT, URL, XHTML, xmlescape, embed64

CAT, MARKMIN, MENU, ON
``:code

**Formularze i tabele**

``
SQLFORM (SQLFORM.factory, SQLFORM.grid, SQLFORM.smartgrid)
``

**Walidatory:** ``walidatory``:inxx

``
CLEANUP, CRYPT, IS_ALPHANUMERIC, IS_DATE_IN_RANGE, IS_DATE,
IS_DATETIME_IN_RANGE, IS_DATETIME, IS_DECIMAL_IN_RANGE,
IS_EMAIL, IS_EMPTY_OR, IS_EXPR, IS_FLOAT_IN_RANGE, IS_IMAGE,
IS_IN_DB, IS_IN_SET, IS_INT_IN_RANGE, IS_IPV4, IS_LENGTH,
IS_LIST_OF, IS_LOWER, IS_MATCH, IS_EQUAL_TO, IS_NOT_EMPTY,
IS_NOT_IN_DB, IS_NULL_OR, IS_SLUG, IS_STRONG, IS_TIME,
IS_UPLOAD_FILENAME, IS_UPPER, IS_URL
``:code

**Baza danych:** ``DAL``:inxx

``
DAL, Field
``:code

W celu zachowania wstecznej kompatybilności ``SQLDB=DAL`` i ``SQLField=Field``.
Zachęcamy do stosowania nowej składni ``DAL`` i ``Field``, zamiast starej.

W bibliotekach są zdefiniowane inne obiekty i moduły, ale nie są one importowane
automatycznie, ponieważ używane są rzadko.

Podstawowe encje API w środowisku wykonawczym web2py, to ``request``, ``response``,
``session``, ``cache``, ``URL``, ``HTTP``, ``redirect`` i ``T``. Są one omówione niżej.

Kilka obiektów i funkcji, w tym **Auth**, **Crud** i **Service** są zdefiniowane
w "gluon/tools.py" i jeśli są potrzebne, to muszą zostać zaimportowane:
``
from gluon.tools import Auth, Crud, Service
``:code
Są one importowane w ``db.py`` w aplikacji szkieletowej.

#### Dostęp do API z modułów Pythona

Twoje modele lub kontrolery mogą importować moduły Pythona, które do działania
wymagają zastosowania jakichś interfejsów API web2py API. Sposobem na to jest
ich zaimportowanie:

``
from gluon import *
``

W rzeczywistości, każdy moduł Pythona, jeśli nawet nie został zaimportowany przez
aplikację web2py, może importować API web2py, jeśli web2py jest w ``sys.path``.

Choć jest jedno zastrzeżenie. Web2py definiuje niektóre obiekty globalne (request,
response, session, cache, T), które mogą istnieć tylko wtedy, gdy obecne jest żądanie
HTTP (lub zostało ono sfałszowane). Dlatego moduły mogą z nich korzystać tylko wtedy,
gdy są wywoływane z aplikacji. Z tego powodu są one umieszczane w kontenerze wywołującym
``current``, który jest obiektem lokalnego wątku. Oto przykład.

Utwórz moduł "/myapp/modules/test.py" zawierający:
``
from gluon import *
def ip(): return current.request.client
``
Teraz w kontrolerze "myapp" możesz napisać
``
import test
def index():
    return "Twój ip to " + test.ip()
``

Zwróć uwagę na kilka rzeczy:

- Wyrażenie ``import test`` wyszukuje moduł najpierw w folderze bieżącej aplikacji,
  następnie w folderach wykazanych w ``sys.path``. Dlatego moduły poziomu aplikacji
  zawsze mają pierwszeństwo przed modułami Pythona. Umożliwia to, aby różne aplikacje
  korzystały bez konfliktu z różnych wersji swoich modułów.

- Różni użytkownicy mogą wywoływać równocześnie tą sama akcję ``index``, która
  wywołuje funkcję w module bez powodowania konfliktu, ponieważ obiekt ``current.request``
  jest innym obiektem w każdym wątku. Wystarczy zachować ostrożność, aby nie przejść do
  ``current.request`` poza funkcjami lub klasami w module (czyli na najwyższym poziomie).

- Wyrażenie ``import test`` jest skrótem wyrażenia ``from applications.appname.modules import test``.
  Używając dłuższej składni można zaimportować moduły z innej aplikacji.

W celu jednolitości z normalnym zachowaniem Pythona, web2py domyślnie nie przeładowuje
modułów po wprowadzeniu zmian. Lecz można to zmienić. Aby włączyć możliwość automatycznego
przeładowywania modułów, trzeba użyć funkcję ``track_changes`` w sposób następujący
(zwykle w pliku modelu, przed jakimkolwiek wyrażeniem import):

``
from gluon.custom_import import track_changes; track_changes(True)
``:code

Od teraz, za każdym razem, moduł jest importowany, importer sprawdza, czy plik
źródłowy Pythona (.py) został zmieniony. Jeśli tak, to moduł zostanie przeładowany. 

------
Nie wywołuj track_changes w samych modułach.
------

Śledzenie zmian obywa się tylko dla modułów, które są przechowywane w aplikacji.
Moduły importujące ``current`` uzyskują dostęp do:
- ``current.request``
- ``current.response``
- ``current.session``
- ``current.cache``
- ``current.T``
oraz każdej innej zmiennej aplikacji wybranej do przechowywania w current.
Na przykład. możnaby zrobić taki model

``
auth = Auth(db)
from gluon import current
current.auth = auth
``

co spowoduje, że teraz wszystkie moduły mogą mieć dostęp do ``current.auth``.

Wyrażenia ``current`` i ``import`` tworzą pełnowartościowy mechanizm do budowania
rozszerzalnych i mogących być wielokrotnie używanych modułów dla aplikacji.

-------
Uważaj! Biorąc ``from gluon import current``, dobrze jest użyć ``current.request``
i którykolwiek z innych obiektów lokalnego wątku, ale nigdy nie należy przypisywać
go do zmiennych globalnych w module, tak jak tu
``
request = current.request # ŹLE! NIEBEZPIECZNIE!
``
ani też nie należy przypisywać go do atrybutu klasy
``
class MyClass:
    request = current.request # ŹLE! NIEBEZPIECZNIE!
``
To dlatego, że obiekt lokalnego wątku musi być ekstrahowany w czasie wykonania.
Natomiast zmienne globalne są definiowane tylko raz, podczas importowania modelu
po raz pierwszy.
-------

Inne zastrzeżenie dotyczy operacji z pamięcią podręczną. Nie można używać obiektu
``cache`` do dekorowania funkcji w modułach, dlatego że nie zachowuje się on zgodnie
z oczekiwaniami. Aby buforować funkcje ``f`` w module musi się użyć ``lazy_cache``:

``
from gluon.cache import lazy_cache

@lazy_cache('key', time_expire=60, cache_model='ram')
def f(a,b,c,): ....
``:code

Pamiętaj, że klucz jest określany przez użytkownika, ale musi on być jednoznacznie
powiązany z funkcją. Jeśli zostanie pominięty, to web2py określi go automatycznie.

### Obiekt ``request``
``request``:inxx ``Storage``:inxx ``request.cookies``:inxx ``user_agent``:inxx

Obiekt ``request`` jest instancją wszechobecnej klasy web2py o nazwie ``gluon.storage.Storage``,
która rozszerza klasę ``dict`` Pythona. W zasadzie jest to słownik, ale wartości
jego elementów mogą być również dostępne jako atrybuty:
``
request.vars
``:code

jest tym samym, co:
``
request['vars']
``:code

W przeciwieństwie do słownika, jeśli atrybut (lub klucz) nie istnieje, to nie jest
zgłaszany wyjątek. Zamiast tego zwracane jest ``None``.

-----
Czasem jest to przydatne do tworzenia własnych obiektów Storage. Można to zrobić
następująco:
``
from gluon.storage import Storage
my_storage = Storage() # pusty obket storage
my_other_storage = Storage(dict(a=1, b=2)) # konwersja słownika do Storage
``:code
-----

Obiekt ``request`` ma następujące elementy (atrybuty), z których niektóre również są dostępne w instancji klasy ``Storage``:
- ``request.cookies``: obiekt ``Cookie.SimpleCookie()`` zawierający ciasteczka przekazywane przez żądania HTTP. Działa on jak słownik ciasteczek. Każde ciasteczko jest obiektem Morsel ``morsel``:cite;
- ``request.env``: obiekt ``Storage`` zawierający zmienne środowiskowe przekazywane do kontrolera, w tym zmienne nagłówka HTTP z żądania HTTP i standardowe parametry WSGI. Wszystkie zmienne środowiskowe są konwertowane na małe litery a kropki na znaki podkreślenia w celi łatwiejszego zapamiętania;
- ``request.application``: nazwa żądanej aplikacji;
- ``request.controller``: nazwa żądanego kontrolera;
- ``request.function``: nazwa żądanej funkcji;
- ``request.extension``: rozszerzenie żądanej akcji. Domyślną wartością jest "html". Jeśli kontroler zwraca słownik i nie określa widoku, to jest używany do określenia rozszerzenia pliku widoku, który będzie renderował słownik (parsowany w ``request.env.path_info``);
- ``request.folder``: słownik aplikacji. Na przykład, jeśli aplikacją jest "welcome", ``request.folder`` zostaje ustawione na ścieżkę bezwzględną "/path/to/welcome". W programie należy zawsze używać tej zmiennej oraz funkcji ``os.path.join`` do budowy ścieżek do plików, do których potrzeba uzyskać dostęp. Chociaż web2py zawsze używa ścieżek bezwzględnych, to dobrą praktyką jest niezmienianie nigdy jawnie bieżącego folderu roboczego (cokolwiek nim jest) ponieważ nie jest to bezpieczne dla wątku;
- ``request.now``: obiekt ``datetime.datetime`` przechowujący datę i czas bieżącego żądania;
- ``request.utcnow``: obiekt ``datetime.datetime`` przechowujący datę i czas UTC bieżącego żądania;
- ``request.args``: lista parametrów ścieżki URL występujących po nazwie funkcji kontrolera; ekwiwalent ``request.env.path_info.split('/')[3:]``
- ``request.vars``: obiekt ``gluon.storage.Storage`` zawierający wszystkie parametry żądania;
- ``request.get_vars``: obiekt ``gluon.storage.Storage`` zawierający tylko parametry przekazane do ciąga zapytania (żądanie dla ``/a/c/f?var1=1&var2=2`` będzie się kończyć ciągiem ``{var1: "1", var2: "2"}``);
- ``request.post_vars``: obiekt ``gluon.storage.Storage`` zawierający tylko parametry przekazane do ciała żądania (zwykle w żądaniach POST, PUT, DELETE);
- ``request.client``: adres IP klienta, zgodnie z ustaleniem ``request.env.http_x_forwarded_for``, jeśli obecne, a jeśli nie to przez ``request.env.remote_addr``. Chociaż jest to użyteczne, to jednak nie należy temu ufać, ponieważ ``http_x_forwarded_for`` może być sfałszowane;
- ``request.is_local``: ``True`` jeśli klientem jest localhost, w przeciwnym razie ``False``. Powinno działać na proxy, jeśli proxy obsługuje ``http_x_forwarded_for``;
- ``request.is_https``: ``True`` jeśli żądanie używa protokołu HTTPS, w przeciwnym razie ``False``;
- ``request.body``: strumień plikowy tylko do odczytu zawierający ciało żądania HTTP. Jest on automatycznie parsowany w celu pobrania ``request.post_vars`` i następnie przewinięty. Można go odczytać poprzez ``request.body.read()``;
- ``request.ajax`` True jeśli funkcja jest wywoływana poprzez żądanie Ajax;
- ``request.cid`` jest to identyfikator komponentu, który wygenerował żądanie Ajax (jeśli miało to miejsce). Więcej informacji na ten temat znajduje się w rozdziale 12;
- ``request.requires_https()`` uniemożliwia dalsze wykonywanie kodu, jeśli żądanie nie jest realizowane poprzez HTTPS i przekierowuje odwiedzającego do bieżącej strony poprzez HTTPS.
- ``request.restful`` jest to nowy i bardzo przydatny dekorator, który może być wykorzystany do zmiany zachowania akcji web2py przez oddzielne żądania GET/POST/PUSH/DELETE. Jest to omówione w rozdziale 10.
- ``request.user_agent()`` analizuje pole user_agent w nagłówku żądania i zwraca informację w formie słownika. Jest to przydatne do wykrywania urządzeń mobilnych. Wykorzystuje kod "gluon/contrib/user_agent_parser.py" stworzony przez Rossa Peoples. Aby zobaczyć jak to działa, spróbuj osadzić w widoku następujący kod:
``
{{=BEAUTIFY(request.user_agent())}}
``:code

- ``request.global_settings`` ``request.global_settings``:inxx zawiera ustawienia ogólnosystemowe web2py. Są one ustawiane automatycznie i nie ma potrzeby zmieniania ich. Na przykład ``request.global_settings.gluon_parent`` zawiera pełną ścieżkę do folderu web2py, ``request.global_settings.is_pypy`` określa czy web2py jest uruchomiony na PyPy;

- ``request.wsgi`` jest to hak, który umożliwia wywołanie aplikacji WSGI osób trzecich z poziomu akcji.

Ostatnio dołączono:
- ``request.wsgi.environ``
- ``request.wsgi.start_response``
- ``request.wsgi.middleware``
ich użycie jest omówione na końcu tego rozdziału.

Jako przykład, następujące adres na typowym systemie:

``
http://127.0.0.1:8000/examples/default/status/x/y/z?p=1&q=2
``:code

da w wyniku następujący obiekt ``request``:
``request``:inxx ``env``:inxx

----------
**variable** | **value**
``request.application`` | ``examples``
``request.controller`` | ``default``
``request.function`` | ``status``
``request.extension`` | ``html``
``request.view`` | ``status``
``request.folder`` | ``applications/examples/``
``request.args`` | ``['x', 'y', 'z']``
``request.vars`` | ``<Storage {'p': 1, 'q': 2}>``
``request.get_vars`` | ``<Storage {'p': 1, 'q': 2}>``
``request.post_vars`` | ``<Storage {}>``
``request.is_local`` | ``False``
``request.is_https`` | ``False``
``request.ajax`` | ``False``
``request.cid`` | ``None``
``request.wsgi`` | ``<hook>``
``request.env.content_length`` | ``0``
``request.env.content_type`` | ````
``request.env.http_accept`` | ``text/xml,text/html;``
``request.env.http_accept_encoding`` | ``gzip, deflate``
``request.env.http_accept_language`` | ``en``
``request.env.http_cookie`` | ``session_id_examples=127.0.0.1.119725``
``request.env.http_host`` | ``127.0.0.1:8000``
``request.env.http_referer`` | ``http://web2py.com/``
``request.env.http_user_agent`` | ``Mozilla/5.0``
``request.env.path_info`` | ``/examples/simple_examples/status``
``request.env.query_string`` | ``remote_addr:127.0.0.1``
``request.env.request_method`` | ``GET``
``request.env.script_name`` | ````
``request.env.server_name`` | ``127.0.0.1``
``request.env.server_port`` | ``8000``
``request.env.server_protocol`` | ``HTTP/1.1``
``request.env.server_software`` | ``Rocket 1.2.6``
``request.env.web2py_path`` | ``/Users/mdipierro/web2py``
``request.env.web2py_version`` | ``Version 2.4.1``
``request.env.wsgi_errors`` | ``<open file, mode 'w' at >``
``request.env.wsgi_input`` | ````
``request.env.wsgi_url_scheme`` | ``http``
--------

To jakie zmienne środowiskowe zostaną zdefiniowane zależy od serwera internetowego.
Tutaj założyliśmy użycie wbudowanego serwera WSGI Rocket. Ten zestaw zmiennych nie
różni zbyt od tego, jaki otrzymuje się przy użyciu serwera internetowego Apache.

Zmienne ``request.env.http_*`` z nagłówka żądania HTTP są parsowane.

Zmienne ``request.env.web2py_*`` ze środowiska serwera internetowego nie są parsowane,
ale są tworzone przez web2py. W przypadku naszej aplikacji trzeba znać lokalizację
i wersję oraz czy jest ona uruchomiona na Google App Engine (ponieważ może być konieczna
specyficzna optymalizacja).

Warto również zwrócić uwagę na zmienne ``request.env.wsgi_*``. Są one specyficzne
dla adaptera wsgi.

### Obiekt ``response``
``response``:inxx
``response.body``:inxx
``response.cookies``:inxx
``response.download``:inxx
``response.files``:inxx
``response.flash``:inxx
``response.headers``:inxx
``response.meta``:inxx
``response.menu``:inxx
``response.postprocessing``:inxx
``response.render``:inxx
``response.static_version``:inxx
``response.status``:inxx
``response.stream``:inxx
``response.subtitle``:inxx
``response.title``:inxx
``response.toolbar``:inxx
``response.view``:inxx
``response.delimiters``:inxx
``response.js``:inxx
``response.write``:inxx
``response.include_files``:inxx
``response.include_meta``:inxx
``response.optimize_css``:inxx
``response.optimize_js``:inxx
``response._caller``:inxx
``response.models_to_run``:inxx

Obiekt ``response`` jest inną instancją klasy ``Storage``. Zawiera co następuje:

- ``response.body``: obiekt ``StringIO`` w którym web2py zapisuje ciało strony wyjściowej. NIGDY NIE ZMIENIAJ TEJ ZMIENNEJ;
- ``response.cookies``: podobne do ``request.cookies`` z tą różnicą, że zamiast
  ciasteczek przesłanych od klienta zawiera ciasteczka ciasteczka wysłane przez serwer
  do klienta. Ciasteczko sesji jest obsługiwane automatycznie.
- ``response.download(request, db)``: metoda używana do implementowania funkcji
  kontrolera umożliwiającej pobieranie przesyłanych plików. Metoda ``response.download``
  oczekuje aby ostatni ``arg`` w ``request.args`` był zakodowaną nazwą pliku (np.
  nazwą pliku generowaną w czasie przesyłania i zapisana w polu upload). Ekstrahuje
  ona nazwę przesyłanego pliku oraz nazwę tabeli, jak również oryginalną nazwę pliku.
  Metoda ``response.download`` pobiera dwa opcjonalne argumenty: ``chunk_size`` ustawia
  rozmiar w bajtach dla pakietowego przesyłania strumieniowego (domyślnie to 64K)
  a ``attachments`` określa czy pobrany plik powinien być traktowany jako załącznik czy
  też nie (domyślnie to ``True``). Trzeba mieć na uwadze, że ``response.download``
  jest specjalnie przeznaczony dla pobieranie plików związanych z polami upload w
  ``db``. Używaj ``response.stream`` (patrz niżej) dla innych typów pobieranych plików
  i strumieniowania. Proszę również zwrócić uwagę, że nie jest konieczne użycie
  ``response.download`` w celu uzyskania dostępu do plików przesyłanych do folderu
  /static – pliki statyczne mogą (i na ogół powinny) być dostępne bezpośrednio poprzez
  adres URL (np. /app/static/files/myfile.pdf);
- ``response.files``: lista plików ``.css``, ``.js``, ``.coffee`` i ``.less``
  wymaganych przez stronę. Będą one automatycznie linkowane w sekcji standardowego
  widoku "layout.html" za pomocą "web2py_ajax.html". W celu dołączenia nowych plików
  CSS, JS, COFFEE lub LESS wystarczy je dołączyć do tej listy. Będą obsługiwane
  duplikaty. Kolejność jest ważna;
- ``response.include_files()`` generuje znaczniki sekcji head pliku html w celu
  dołączenia wszystkich ``response.files`` (używanych w "views/web2py_ajax.html");
- ``response.flash``: opcjonalny parametr, który może zostać zawarty w widokach.
  Zwykle używany do powiadamiania użytkownika o czymś co się stało.
- ``response.headers``: słownik dla nagłówków odpowiedzi HTTP. Platforma web2py
  ustawia domyślnie kilka nagłówków, w tym "Content-Length", "Content-Type" i "X-Powered-By"
  (ustawiany na ``web2py``). Platforma web2py ustawia również nagłówki "Cache-Control",
  "Expires" i "Pragma" w celu zapobiegania buforowaniu po stronie klienta, z wyjątkiem
  żądań dla plików statycznych, dla których buforowanie po stronie klienta jest włączone.
  Nagłówki ustawiane przez web2py mogą być nadpisywane lub usuwane oraz mogą być dodawane
  nowe nagłówki (np. ``response.headers['Cache-Control'] = 'private'``). Nagłówek może
  zostać usunięty przez usunięcie jego klucza ze słownika, np. ``del response.headers['Custom-Header']``,
  jednak domyślne nagłówki web2py zostaną po prostu dodane ponownie przed zwróceniem
  odpowiedzi. Aby uniknąć tego problemu, potrzeba ustawić wartość nagłówka na None,
  np. w celu usunięcia domyśłnego nagłówka Content-Type, trzeba ustawić ``response.headers['Content-Type'] = None``;
- ``response.menu``: opcjonalny parametr, który może być zawarty w widokach, zwykle
  używany do przekazania nawigacyjnego drzewa menu do widoku. Może być renderowany
  przez helper MENU;
- ``response.meta``: obiekt klasy Storage, który zawiera opcjonalne informacje
  ``<meta>``, takie jak ``response.meta.author``, ``.description`` lub ``.keywords``.
  Zawartość każdej zmiennej meta jest automatycznie umieszczana w odpowiednim znaczniku
  ``META`` przez kod w widoku "views/web2py_ajax.html", który jest dołączany przez
  domyślny widok "views/layout.html";
- ``response.include_meta()`` generuje ciąg znakowy zawierający wszystkie serializowane
  nagłówki ``response.meta`` (używane w widoku "views/web2py_ajax.html");
- ``response.postprocessing``: jest to lista funkcji, domyślnie pusta. Funkcje te
  są wykorzystywane do filtrowania obiektu odpowiedzi na wyjściu akcji, zanim wyjście
  zostanie zrenderowane przez widok. Listę ta można wykorzystać do implementacji
  innych języków szablonowania;
- ``response.render(view, vars)``: metoda używana do wywołania widoku w sposób
  jawny wewnątrz kontrolera. Opcjonalny parametr ``view`` jest nazwą pliku widoku,
  ``vars`` jest słownikiem nazwanych wartości przekazywanych do widoku;
- ``response.session_file``: plik strumienia zawierający sesję;
- ``response.session_file_name``: nazwa pliku w którym będą zapisywane sesje;
- ``response.session_id``: identyfikator bieżącej sesji. Jest ustalany automatycznie. NIGDY NIE ZMIENIAJ TEJ ZMIENNEJ;
- ``response.session_id_name``: nazwa ciasteczka sesji dla tej aplikacji. NIGDY NIE ZMIENIAJ TEJ ZMIENNEJ;
- ``response.static_version``: numer wersji dla zarządzania statycznymi aktywami;  
- ``response.status``: kod stanu HTTP, który ma być przekazany do odpowiedzi. Domyślnie, to 200 (OK);
- ``response.stream(file, chunk_size, request=request, attachment=False, filename=None)``:
  gdy kontroler to zwraca, web2py strumieniuje z powrotem zawartość pliku do klienta
  w blokach o wielkości określonej w ``chunk_size``. Parametr ``request`` jest wymagany
  do korzystania z początku fragmentu w nagłówku HTTP. Parametr ``file``powinien być
  ścieżką do pliku (z powodu wstecznej kompatybilności, może to być również obiekt
  otwartego pliku, lecz nie jest to zalecane). Jak wspomniano powyżej, metoda
  ``response.download`` powinna być używana do pobierania przechowywanych plików
  poprzez pole upload. Metodę ``response.stream`` można wykorzystywać w innych przypadkach,
  takich jak zwracanie pliku tymczasowego lub obiektu StringIO utworzonego przez kontroler.
  Jeśli parametr ``attachment`` to True, nagłówek Content-Disposition zostanie ustawiony
  na "attachment", a jeśli ``filename`` jest też dostarczone, to zostanie dodany również
  nagłówek Content-Disposition (ale tylko wtedy, gdy ``attachment`` ma wartość True).
  Jeśli nic nie zawarto w ``response.headers``, to następujące nagłówki odpowiedzi
  zostaną automatycznie ustawione: Content-Type, Content-Length, Cache-Control, Pragma
  i Last-Modified (trzy ostatnie będą ustawione w celu umożliwienia przeglądarce buforowania
  pliku). Aby nadpisać któryś z tych automatycznych ustawień, wystarczy ustawić go
  w ``response.headers`` przed wywołaniem ``response.stream``;
- ``response.subtitle``: opcjonalny parametr, który może zostać zawarty w widokach.
  Powinien zawierać podtytuł strony;
- ``response.title``: opcjonalny parametr, który może zostać zawarty w widokach.
  Powinien zawierać tytuł strony i powinien być renderowany wewnątrz znacznika title
  HTML w sekcji header.
- ``response.toolbar``: funkcja umożliwiająca osadzenie paska narzędziowego na
  stronie do celów debugowania ``{{=response.toolbar()}}``. Ten pasek narzędziowy
  wyświetla żądania, odpowiedzi, zmienne sesji oraz czas dostępu do bazy danych
  w każdym zapytaniu;
- ``response._vars``: ta zmienna jest dostępna tylko w widoku, nie w akcji. Zawiera
  wartości zwracane przez akcję do widoku;
- ``response._caller``: jest to funkcja opakowująca wszystkie wywołania akcji.
  Domyślnie jest to funkcja identyczna, ale może zostać zmodyfikowana w celu wyłapania
  specjalnych typów wyjątków i ich dodatkowym zarejestrowaniu w dzienniku;
  ``
  response._caller = lambda f: f()
  ``
- ``response.optimize_css``: można ustawić na "concat,minify,inline" w celu łączenia,
  minifikacji i łączenia w jedną linię kodu plików CSS dołączonych przez web2py;
- ``response.optimize_js``: można ustawić na "concat,minify,inline" w celu łączenia,
  minifikacji i łączenia w jedną linię kodu plików CSS dołączonych przez web2py; 
- ``response.view``: nazwa szablonu widoku, który musi renderować stronę. Domyślnie
  ustawione jest na:
  ``
  "%s/%s.%s" % (request.controller, request.function, request.extension)
  ``:code
  lub jeżeli powyższy plik nie może zostać zlokalizowany, to na
  ``
  "generic.%s" % (request.extension)
  ``:code
  Można zmienić wartość tej zmiennej w celu zmodyfikowania pliku widoku związanego
  z określona akcją.

- ``response.delimiters`` domyślnie to ``('{{','}}')``. Pozwala to na zmianę
  separatora kodu osadzanego w widokach;
- ``response.xmlrpc(request, methods)``: gdy kontroler to zwraca, funkcja udostępnia
  metody poprzez XML-RPC``xmlrpc``:cite . Funkcja ta jest przestarzała ponieważ dostępne
  są lepsze mechanizmy opisane w rozdziale 10;
- ``response.write(text)``: metoda do wpisywania tekstu do ciała strony wyjściowej;
- ``response.js`` może zawierać kod JavaScript. Kod ten będzie wykonywany tylko
  jeśli odpowiedź jest odbierana przez komponent web2py, tak jak opisano to w rozdziale 12;
- ``response.models_to_run`` [[response_models_to_run]] zawiera listę wyrażeń regularnych wybierających to co modele uruchamiają;
-- Domyślnie jest ustawiane dla ładowania plików /a/models/*.py, /a/models/c/*.py
  i /a/models/c/f/*.py gdy żądany jest ``/a/c/f``. Można ustawić np. ``response.models_to_run = ['myfolder/']``
  aby wymuszać tylko modele wewnątrz podfolderu ``models/myfolder`` aplikacji;
-- NB: ``response.models_to_run`` jest listą wyrażeń regularnych a nie listą ścieżek
   do pliku. Wyrażenia regularne są względne w stosunku do folderu models/, tak więc
   każdemu plikowi modelu odpowiada jedna ścieżka do pliku, który ma być wykonany.
   Należy również zwrócić uwagę, że to nie może wpływać na żadne modele które zostały
   już ewaluowane, ponieważ zostały wcześniej posortowane alfabetycznie. Tak jest,
   jeśli warunkowy model dla kontrolera orange to orange/orange_model.py i ustawiono
   wyrażenie regularne na [.*], którego zmiany nie wpływają na żaden poprzednio odrzucony
   model do załadowania, taki jak apple/apple_model.py – dopasowuje to nowe wyrażenie
   regularne, ale będzie to ewaluowane i odrzucane zanim orange/orange_model.py zmieni
   wyrażenie regularne;
-- Oznacza to, że jeśli chce się użyć models_to_run w celu udostępnienia warunkowych
   modeli pomiędzy kontrolerami, to trzeba umieścić model w podfolderze, w którym
   elementy są sortowane malejąco, taki jak zzz i następnie użycie wyrażenia regularnego
   'zzz'.

Ponieważ ``response`` jest obiektem ``gluon.storage.Storage``, to może być zastosowane
do przechowywania innych atrybutów, które chce się przekazać do widoku. Chociaż
nie ma technicznych ograniczeń, naszym zaleceniem jest przechowywanie tylko zmiennych,
które mają być renderowane przez wszystkie strony z ogólnym układem ("layout.html").

W każdym razie, zdecydowanie sugerujemy aby utrzymywać zmienne wymienione tutaj:
``
response.title
response.subtitle
response.flash
response.menu
response.meta.author
response.meta.description
response.meta.keywords
response.meta.*
``:code

ponieważ w ten sposób łatwiej jest zamienić standardowy plik "layout.html", na taki,
który stosuje ten sam zestaw zmiennych.

W starszych wersjach web2py używano ``response.author`` zamiast ``response.meta.author``
i podobne do innych meta atrybutów.

### Obiekt ``session``
``session``:inxx ``session.connect``:inxx ``session.forget``:inxx ``session.secure``:inxx
Obiekt ``session`` jest jedną z instancji klasy ``Storage``. Cokolwiek zostanie
zapisywane w ``session``, na przykład:
``
session.myvariable = "hello"
``:code

może być odzyskane w późniejszym czasie:
``
a = session.myvariable
``:code

tak długo, jak kod jest wykonywany w ramach tej samej sesji przez tego samego
użytkownika (o ile użytkownik nie usunie ciasteczek sesji a sesja nie wygasła).
Ponieważ ``session`` jest obiektem ``Storage``, próba uzyskania dostępu do atrybutu
(klucza), który nie został ustawiony nie zgłasza wyjątku, zamiast tego zwraca ``None``.

Obiekt sesji ma trzy ważne metody. Jedna z nich, to ``forget``:
``
session.forget(response)
``:code

Informuje ona web2py, aby nie zapisywał sesji. Powinna być stosowana w tych kontrolerach,
których akcje są wywoływane często i nie ma potrzeby śledzenia aktywności użytkownika.
Metoda ``session.forget()`` zapobiega przed przepisywaniem pliku sesji niezależnie
od tego czy był on modyfikowany. Metoda ``session.forget(response)`` dodatkowo
otwiera i zamyka plik sesji. Rzadko trzeba korzystać z tej metody, ponieważ sesje
nie są zapisywana, gdy nie zostały zmienione. Jednakże, jeśli strona wykonuje wiele
jednoczesnych żądań Ajax, to dobrym pomysłem na wywoływanie akcji poprzez Ajax jest
wywołanie ``session.forget(response)`` (zakładając, że sesja nie jest potrzebna
dla akcji). W przeciwnym razie każda akcja Ajax będzie musiała czekać na zakończenie
poprzedniej akcji (i odblokowanie pliku sesji) przed kontynuowaniem, co spowalnia
ładowanie strony. Należy mieć na uwadze, że sesje nie zostają zablokowane, gdy są
przechowywane w bazie danych.

Inna metoda to:

``
session.secure()
``:code

który informuje web2py, aby ustawił ciasteczko sesji jako bezpieczne ciasteczko.
Powinno się to ustawiać, jeśli aplikacja używa połączenia https. Przez ustawienie
ciasteczka sesji jako bezpiecznego, serwer prosi przeglądarkę aby nie odsyłał z
powrotem ciasteczka do serwera, chyba że przez połączenie https.

Następną metodą jest ``connect``.
Domyślnie sesje są przechowywane w systemie plików a ciasteczko jest używane do
przechowywania i pobierania ``session.id``. Używając metody connect jest możliwe
poinformowanie web2y aby przechowywał sesje w bazie danych albo w ciasteczkach,
eliminując konieczność dostępu do systemu plików w zarządzaniu sesją.

Na przykład, aby **przechować sesje w bazie danych**:

``
session.connect(request, response, db, masterapp=None)
``:code

gdzie ``db`` jest nazwą otwartego połączenia z bazą danych (tak jak zwrócił to DAL).
Powiadamia to web2py, że chce się przechować sesje w bazie danych a nie w systemie
plików. Metoda ``session.connect`` musi być wywołana po ``db=DAL(...)``, ale przed
jakąkolwiek logika wymagajacą sesji, na przykład, konfiguracją ``Auth``.

web2py tworzy tabelę:
``
db.define_table('web2py_session',
                 Field('locked', 'boolean', default=False),
                 Field('client_ip'),
                 Field('created_datetime', 'datetime', default=now),
                 Field('modified_datetime', 'datetime'),
                 Field('unique_key'),
                 Field('session_data', 'text'))
``:code

i zapisze speklowane sesje w polu ``session_data``.

Opcja ``masterapp=None`` (domyślnie) informuje web2py aby próbował odzyskać istniejącą
sesję z nazwą w ``request.application``, w uruchomionej aplikacji.

Jeśli chce się aby dwie lub więcej aplikacji współdzieliły sesje, trzeba ustawić
``masterapp`` na nazwę głównej aplikacji.

Aby zamiast tego **zapisać sesje w ciasteczkach** można zrobić:

``
session.connect(request,response,cookie_key='yoursecret',compression_level=None)
``:code

Tutaj ``cookie_key`` to symetryczny klucz szyfrowania.
``compression_level`` jest opcjonalnym poziomem szyfrowania ``zlib`.

Natomiast sesje w ciasteczku są często zalecane z powodu skalowalności, gdyż mają
ograniczoną wielkość. Duże sesje będą powodować załamanie się ciasteczek.

Można sprawdzić stan swojej aplikacji w dowolnym momencie przez wydrukowanie zmiennych
systemowych  ``request``, ``session`` i ``response``. Jednym sposobem na wykonanie
tego jest utworzenie dedykowanej akcji:
``
def status():
    return dict(request=request, session=session, response=response)
``:code

W widoku "generic.html" osiąga się to używając ``{{=response.toolbar()}}``.

#### Nie przechowuj w sesji klas zdefiniowanych przez użytkownika

Zmienne przechowywane w sesji są zachowywane pomiędzy żądaniami dzięki  serializacji.

Sesje są pobierane przed wykonaniem kodu modułu, a więc przed zdefiniowaniem klas.
Dlatego klasy zdefiniowane przez użytkownika nie mogą zostać speklowane. 

Klasy zdefiniowane w modułach są również szarą strefą i nie powinny być umieszczane
w pamięci. Będą one działać przez większość czasu ale w końcu mogą załamać sesję.
Tak jest ponieważ, na przykład, jeśli zrestartuje się serwer internetowy w chwili
pobierania sesji przez użytkownika, to może się zdarzyć, że moduł zostanie zaimportowany.
Ten sam problem wystąpi podczas uruchamiania przez serwer internetowy nowego procesu
roboczego oraz w środowisku rozproszonym.

#### Oddzielne sesje

Jeśli sesje są przechowywane w systemie plików i ma się ich wiele, to system plików
może stać się wąskim gardłem. Jedno z rozwiązań jest następujące:
``
session.connect(request, response, separate=True)
``:code

Ustawiając ``separate=True`` web2py będzie przechowywał sesje nie w folderze "sessions/"
ale w podfolderze folderu "sessions/". Podfolder będzie tworzony automatycznie.
Sesje z tym samym przedrostkiem będą zapisywane w tym samym podfolderze. Znowu trzeba
mieć na uwadze, że powyższe wyrażenie musi być wywołane przed jakąkolwiek logiką,
którą może wymagać sesja.

### Obiekt ``cache``
``cache``:inxx ``cache.ram``:inxx ``cache.disk``:inxx
Globalny obiekt ``cache`` jest również dostępny w środowisku uruchomieniowym web2py.
Ma on dwa atrybuty:
- ``cache.ram``: pamięć podręczna aplikacji w głównej pamięci;
- ``cache.disk``: pamięć podręczna aplikacji na dysku.
Atrybut ``cache`` jest wywoływalny, co pozwala na stosowanie go jako dekoratora
akcji lub widoków.

Powyższy przykład buforuje funkcję ``time.ctime()`` w RAM:
``
def cache_in_ram():
    import time
    t = cache.ram('time', lambda: time.ctime(), time_expire=5)
    return dict(time=t, link=A('click me', _href=request.url))
``:code

Wyjście funkcji ``lambda: time.ctime()`` jest buforowane w RAM przez 5 sekund.
Ciąg ``'time'`` został tu użyty jako klucz.

Poniższy przykład buforuje funkcję ``time.ctime()`` na dysku:
``
def cache_on_disk():
    import time
    t = cache.disk('time', lambda: time.ctime(), time_expire=5)
    return dict(time=t, link=A('click me', _href=request.url))
``:code

Wyjście funkcji ``lambda: time.ctime()`` jest buforowane na dysku (z wykorzystaniem
modułów shelve) na 5 sekund.

Trzeba mieć na uwadze, że drugi argument ``cache.ram`` i ``cache.disk`` musi być
funkcją lub wywoływalnym obiektem. Jeśli chce się buforować istniejący obiekt,
a nie wyjście funkcji, można po prostu zwrócić to przez funkcję lambda:
``
cache.ram('myobject', lambda: myobject, time_expire=60*60*24)
``:code

Następny przykład buforuje funkcję ``time.ctime()`` zarówno w RAM jak i na dysku:
``
def cache_in_ram_and_disk():
    import time
    t = cache.ram('time', lambda: cache.disk('time',
                       lambda: time.ctime(), time_expire=5),
                       time_expire=5)
    return dict(time=t, link=A('click me', _href=request.url))
``:code

Wyjście ``lambda: time.ctime()`` jest buforowane na dysku (z wykorzystaniem moduły
shelve) a następnie w RAM na 5 sekund. Najpierw web2py przeszukuje pamięć RAM
i jeśli nic tam nie znajdzie, to przeszukuje dysk. Jeśli nie ma tego co potrzeba
ani w pamieci RAM ani na dysku, to wykonywana jest funkcja ``lambda: time.ctime()``
i pamięć podręczna zostaje zaktualizowana. Technika ta jest użyteczna w środowisku
wieloprocesorowym. Dwa czasy nie muszą być takie same.

W poniższym przykładzie buforowane jest wyjście kontrolera funkcji (ale nie widoku)
w pamięci RAM:

``buforowanie kontrolera``:inxx
``
@cache(request.env.path_info, time_expire=5, cache_model=cache.ram)
def cache_controller_in_ram():
    import time
    t = time.ctime()
    return dict(time=t, link=A('click me', _href=request.url))
``:code

Słownik zwracany przez ``cache_controller_in_ram`` jest buforowany w RAM na 5 sekund.
Proszę zwrócić uwagę, że wynik wyboru bazy danych nie może być buforowany bez wykonania
najpierw serializacji. Lepszym sposobem jest buforowanie wybranej bazy danych bezpośrednio
przy wykorzystaniu argumentu ``select`` metody ``cache``.

Poniższy przykład buforuje wyjście funkcji kontrolera (ale nie widoku) na dysk:
``
@cache(request.env.path_info, time_expire=5, cache_model=cache.disk)
def cache_controller_on_disk():
    import time
    t = time.ctime()
    return dict(time=t, link=A('click to reload',
                              _href=request.url))
``:code

Słownik zwracany przez ``cache_controller_on_disk`` jest buforowany na dysku przez
5 sekund. Trzeba pamiętać, że web2py nie może buforować słownika, który zawiera
niepeklowane obiekty.

Możliwe jest również buforowanie widoku. Renderowanie widoku w funkcji kontrolera
to trik polegający na tym, aby kontroler zwracał ciąg znakowy. Jest to realizowane
przez zwracanie ``response.render(d)`` gdzie ``d`` jest słownikiem, który chcemy
przekazać do widoku. Poniższy przykład buforuje w RAM wyjście funkcji kontrolera
(łącznie z renderowanym widokiem):

``buforowanie widoku``:inxx
``
@cache(request.env.path_info, time_expire=5, cache_model=cache.ram)
def cache_controller_and_view():
    import time
    t = time.ctime()
    d = dict(time=t, link=A('click to reload', _href=request.url))
    return response.render(d)
``:code
Funkcja ``response.render(d)`` zwraca zrenderowany widok jako ciąg znakowy,
który jest teraz buforowany przez 5 sekund. Jest to najlepszy i najszybszy sposób buforowania.
------
Zalecamy stosowanie [[@cache.action #cache_action]] obsługiwane w web2py > 2.4.6 
------

Proszę zwrócić uwagę, że ``time_expire`` jest używany do porównania bieżącego czasu
z czasem żądanego obiektu, który był ostatnio zapisany w pamięci podręcznej. Nie ma
to wpływu na przyszłe żądania. Umożliwia aby ``time_expire`` był ustawiany dynamicznie
podczas żądania obiektu, a nie ustalany podczas zapisywania obiektu. Na przykład:
``
message = cache.ram('message', lambda: 'Hello', time_expire=5)
``:code

Załóżmy teraz, że następujące wywołanie jest wykonane na 10 sekund przed powyższym wywołaniem:
``
message = cache.ram('message', lambda: 'Goodbye', time_expire=20)
``:code

Ponieważ ``time_expire`` jest ustawione na 20 sekund w drugim wywołaniu i tylko
10 sekund upłynęło od komunikaty, który był zapisany pierwszy, wartość "Hello"
będzie pobierana z pamięci podręcznej i nie zostanie zaktualizowana na "Goodbye".
5 sekundowa wartość ``time_expire`` w pierwszym wywołaniu nie ma wpływu na drugie
wywołanie.

Ustawienie ``time_expire=0`` (lub na wartość ujemną) wymusza, aby buforowana pozycja
była odświeżana  (ponieważ czas jaki upłynął od ostatniego zapisu zawsze będzie > 0)
a ustawienie ``time_expire=None`` wymusza pobieranie wartości buforowanej, niezależnie
od czasu jaki upłynął od ostatnie zapisu (jeśli ``time_expire`` ma zawsze wartość
``None``, to element buforowany będzie nigdy nie wygasający).

Z pamięci podręcznej można usunąć jedna lub więcej zmiennych poleceniem
``cache clear``:inxx

``
cache.ram.clear(regex='...')
``:code

gdzie ``regex`` jest wyrażeniem regularnym dopasowującym wszystkie klucze, jakie
chce się usunąć z pamięci podręcznej. Można również usunąć pojedynczy element stosując:
``
cache.ram(key, None)
``:code

gdzie ``key`` jest kluczem buforowanego elementu.

Możliwe jest również określenie innych mechanizmów buforowania, takie jak memcache.
Memcache jest dostępny poprzez ``gluon.contrib.memcache`` i został omówiony w rozdziale 14.

------
Bądź ostrożny podczas buforowania, pamiętając, że buforowanie jest zwykle dokonywane
na poziomie aplikacji, a nie na poziomie użytkownika. Jeśli potrzeba, na przykład,
buforować zawartość specyficzną dla użytkownika, to trzeba wybrać klucz, który zawiera
identyfikator użytkownika.
------

------
Aplikacja interfejsu administracyjnego aplikacji umożliwia wyświetlanie przycisków
pamięci podręcznej (i czyszczenia pamięci podręcznej). Dostęp do nich można uzyskać
z poziomu ekranu zarządzania bazą danych.
------

[[cache_action]]
#### ``cache.action``
W web2py domyślnie zakłada się, że zwracana zawartość nie będzie buforowana, gdyż
zmniejsza to złe skutki niewłaściwego buforowania po stronie klienta.

Na przykład, gdy wyświetla się formularz użytkownikowi lub listę rekordów, strona
internetowa nie powinna być buforowana, gdyż inni użytkownicy mogą w tym czasie
wprowadzać nowe rekordy do tabeli, która się wyświetla.

Zamiast tego, jeśli wyświetlana jest strona, której zawartość nie będzie się nigdy
zmieniać (lub zmieniać rzadko, np. raz na tydzień), to warto tą strona przechować,
ale jeszcze lepiej jest powiadomić klienta, że strona ta jest niezmienna.

Osiąga się to przez wysyłanie wraz ze stroną kilku specjalnych nagłówków. Gdy
przeglądarka klienta odbierze taką zawartość, to przechowa ją w pamięci podręcznej
przeglądarki i nie będzie żądać ponownie takiej strony od serwera. Jest to **główny**
mechanizm przyśpieszania witryn o dostępie publicznym.

W wersjach web2py > 2.4.6 wprowadzono nowy dekortor ``cache.action`` umożliwiający
bardziej inteligentną obsługę takich sytuacji.
Dekorator ``cache.action`` może zostać użyty do:
- ustawiania inteligentnych nagłówków buforowania;
- odpowiedniego buforowania wyników.
------
NB: Jest stosowane dla jednego lub drugiego celu albo obu naraz.
------
Użycie request.env.path_info jako klucza w buforowaniu widoku poprzez
``@cache(request.env.path_info, time_expire=300, cache_model=cache.ram)`` sprawia
kilka problemów, np.:
+ Zmienne URL nie są obsługiwane
  -- Buforowanie wyniku ''/app/default/index?**search=foo**'' : przez następne
     300 sekund ''/app/default/index?**search=bar**'' zwróci dokładnie ta samą rzecz
     co ''/app/default/index?**search=foo**'';
+ Użytkownik nie jest obsługiwany
  -- Jakiś użytkownik uzyskuje często dostęp do strony i wybiera ją z pamięci podręcznej.
     Jednakże, buforowany był wynik ''/app/default/index'' przy wykorzystaniu request.env.path_info
     jako klucz, tak więc inny użytkownik będzie widział stronę, która nie była przeznaczona dla niego;
  -- Buforowana została strona użytkownika "Bill", gdy "Bill" uzyskał dostęp do strony z pulpitu.
     Teraz próbuje on uzyskać dostęp z telefonu komórkowego: jeśli przygotowany był szablon dla
     użytkowników mobilnych, który jest inny od standardowego, to "Joe" nie zobaczy go;
+ Język nie jest obsługiwany
  -- Podczas buforowania strony, jeśli użyje się funkcji T() dla tych samych
     elementów, strona zostanie zapisana wraz z ustalonym tłumaczeniem;
+ Metoda żądania nie jest obsługiwana
  -- Gdy buforuje się stronę, to należy je buforować tylko wtedy, gdy jest ona
     wynikiem operacji GET
+ Kod stan strony nie jest obsługiwany
  -- Gdy buforuje się stronę po raz pierwszy, czasami może pójść coś nie tak
     i zwracana jest piękna strona 404.
     Przecież nie chcesz buforować błędów.

Zamiast pisać dużo kodu szablonowego rozwiązującego te wszystkie problemy, wystarczy
utworzyć ``cache.action``.
Inteligentnie używa to nagłówki buforowania pozwalając przeglądarce buforować wynik:
jeśli przekaże się do buforowania model, to rozwiązany zostanie automatycznie klucz,
w najlepszy sposób, tak że różne wersje tej samej strony mogą być przechowywane
i pobierane odpowiednio (np. jedna w języku angielskim a druga w polskim).

Pobiera to kilka parametrów, z inteligentnymi wartościami domyślnymi:

- time_expire : domyślnie 300 sekund;
- cache_model : domyślnie None. Oznacza to, że @cache.action będzie **tylko** zmieniał nagłówki, aby pozwolić przeglądarce klienta buforować tą zawartość;
    -- jeśli przekaże się, np., ``cache.ram``, to wynik zostanie też zapisany w pamięci podręcznej;
- prefix : jeśli chce się poprzedzić klucz auto-generated przedrostkiem (przydatne przy usuwaniu go później przez np. ``cache.ram.clear(prefix*)``);
- session : jeśli chce się wziąść po uwagę sesję, domyślnie False;
- vars : jeśli chce się wziąć pod uwagę zmienne URL, domyślnie True;
- lang : jeśli chce się wziąć pod język, domyślnie True;
- user_agent : jeśli chce się wziąć pod uwagę rodzaj przeglądarki użytkownika (''ang. user agent''), domyślnie False;
- public : jeśli chce się buforować tą samą stronę dla wszystkich odwiedzających, tak że będzie zawsze dostępna, domyślnie True;
- valid_statuses : domyślnie None. cache.client będzie buforował tylko strony z metodą GET, których kod stanu rozpoczyna się os 1,2 lub 3; 
  Można przekazać listę kodów stanu (jeśli chce się aby strony były buforowane z tymi stanami, np. status_codes=[200] spowoduje buforowanie tylko strony, których kod stanu wynosi 200) 
- quick : domyślnie None, ale można przekazać listę liter w celu ustawienia właściwej  funkcjonalności:
  -- **S**ession, **V**ars, **L**ang, **U**ser_agent, **P**ublic
     np. ``@cache.action(time_expire=300, cache_model=cache.ram, quick='SVP')`` to to samo co
     ``@cache.action(time_expire=300, cache_model=cache.ram, session=True, vars=True, public=True)``

**Obsługiwanie**, opisane wyżej, oznacza np. dla **zmiennych**, że chcąc buforować różne strony,
gdy **zmienne** są różne, to ''/app/default/index?**search=foo**'' nie będzie takie
samo jak ''/app/default/index?**search=bar**''.
To zachowanie jest nadpisywane przez kilka ustawień, tak więc np., jeśli ustawi
się ``session=True, public=True``, to drugie wyrazenie zostanie odrzucone.

Stosuj to mądrze!

[[URL]]
### Funkcja ``URL``
``URL``:inxx ``funkcja URL``:inxx
Funkcja ``URL`` jest jedna z najważniejszych funkcji w web2py. Generuje wewnętrzne
ścieżki URL dla akcji i plików statycznych.

Oto przykład:

``
URL('f')
``:code

jest mapowane na

``
/[application]/[controller]/f
``:code

Proszę zwrócić uwagę, że wyjście funkcji ``URL`` zależy od nazwy bieżącej aplikacji,
wywoływanego kontrolera i innych parametrów. Platforma web2py obsługuje mapowanie
URL i odwrotne mapowanie URL. Mapowanie URL pozwala przedefiniować format zewnętrznych
adresów URL. Jeśli używa się funkcji ``URL`` do generowania wszystkich zewnętrznych
adresów URL, to następnie trzeba dodać lub zmienić mapowania URL, co zabezpieczy
nie działającym linkom w aplikacji web2py.

Do funkcji ``URL` można przekazać dodatkowe parametry, tj. dodatkowe warunki
w ścieżce adresu URL (args) i zmienne zapytań URL (vars):

``
URL('f', args=['x', 'y'], vars=dict(z='t'))
``:code

jest mapowane na

``
/[application]/[controller]/f/x/y?z=t
``:code

Atrybuty ``args`` są automatycznie parsowane, dekodowane i w końcu zapisywane
w ``request.args``. Podobnie ``vars`` są parsowane, dekodowane i zapisywane w
``request.vars``. ``args`` i ``vars`` dostarczają podstawowe mechanizmy, przy pomocy
których web2py wymienia informację z przeglądarką klienta.

Jeśli ``args`` zawiera tylko jeden element, to nie ma potrzeby przekazywania go w liście.

Można również użyć funkcji ``URL`` do generowania adresów URL dla akcji w innych
kontrolerach i aplikacjach:

``
URL('a', 'c', 'f', args=['x', 'y'], vars=dict(z='t'))
``:code

jest mapowane na 

``
/a/c/f/x/y?z=t
``

Możliwe jest też określenie aplikacji, kontrolera i funkcji przy użyciu nazwanych
argumentów:

``
URL(a='a', c='c', f='f')
``:code

Jeśli brak jest nazwy aplikacji ''a'', to przyjmowana jest bieżąca aplikacja.

``
URL('c', 'f')
``:code

Jeśli brak jest nazwy kontrolera ''c'', to przyjmowany jest bieżący kontroler.

``
URL('f')
``:code

Zamiast przekazywania nazwy funkcji kontrolera możliwe jest przekazywanie samej
funkcji

``
URL(f)
``:code

Z wyżej omówionych powodów, należy zawsze używać funkcji ``URL`` do generowania
adresów URL plików statycznych aplikacji. Pliki statyczne przechowywane są w podfolderze
``static`` (tam kierowane są pliki podczas przesyłania ich za pośrednictwem interfejsu
administracyjnego). Platforma web2py udostępnia wirtualny kontroler 'static', którego
zadaniem jest pobieranie plików z podfolderu ``static``, ustalenie typu zawartości
i strumieniowanie pliku dla klienta. Poniższy przykład generuje adres URL dla pliku
statycznego "image.png":

``
URL('static', 'image.png')
``:code

jest mapowane na

``
/[application]/static/image.png
``:code

Jeśli plik statyczny znajduje się w podfolderze folderu ``static``, można dołączyć
podfolder (podfoldery) jako część atrybutu filename. Na przykład, aby wygenerować:

``
/[application]/static/images/icons/arrow.png
``

trzeba użyć:

``
URL('static', 'images/icons/arrow.png')
``:code

Nie ma potrzeby kodowania (zabezpieczania znakami ucieczki) argumentów ``args``
i ``vars`` - jest to czynione automatycznie.

Domyślnie rozszerzenie odpowiadające bieżącemu żądaniu (które można znaleźć
w ``request.extension``) jest dołączane do funkcji, chyba że request.extension
to html (domyślnie). Można to przesłonić dołączając jawnie rozszerzenie jako
część nazwy funkcji ``URL(f='name.ext')`` lub jako wartość argumentu extension:
``
URL(..., extension='css')
``:code

Bieżące rozszerzenie może być zmazane:
``
URL(..., extension=False)
``:code

#### Bezwzględne adresy URL

Domyślnie funkcja ``URL`` generuje względne adresy URL. Jednakże, można również
generować bezwzględne adresy URL określając argumenty ``scheme`` i ``host`` (jest
to przydatne, na przykład, przy wstawianiu adresów URL w wiadomościach email):

``
URL(..., scheme='http', host='www.mysite.com')
``:code

Można automatycznie dołączyć schemat i host bieżącego żądania przez ustawienie
tych argumentów na ``True``.

``
URL(..., scheme=True, host=True)
``:code

Funkcja ``URL`` akceptuje również argument ``port`` do określania portu serwera,
jeśli to konieczne.

#### Adresy URL z podpisem cyfrowym
``adresy URL z podpisem cfrowym``:inxx

Podczas generowania adresu URL, ma się możliwość jego cyfrowego podpisania.
Dołącza to zmienną GET ``_signature``, która może być zweryfikowana przez serwer.
Można to zrobić w dwojaki sposób.

Można przekazać do funkcji URL następujące argumenty:
- ``hmac_key``: klucz do podpisania adresu URL (ciąg znakowy);
- ``salt``: opcjonalny ciąg znakowy będący solą (ciągiem zaburzającym) haszowanie podpisu;
- ``hash_vars``: opcjonalna lista nazw zmiennych z ciąga zapytania URL (czyli zmiennych GET), które będą dołączone do sygnatury. Można to również ustawić na ``True`` (wartość domyślna) aby dołączać wszystkie zmienne lub na ``False`` aby nie dołączać żadnych zmiennych.

Oto przykład zastosowania:

``
KEY = 'mykey'

def one():
    return dict(link=URL('two', vars=dict(a=123), hmac_key=KEY))

def two():
    if not URL.verify(request, hmac_key=KEY): raise HTTP(403)
    # do something
    return locals()
``:code

Sprawia to, że akcja ``two`` jest dostępna tylko poprzez adres URL podpisany cyfrowo.
Adres URL podpisany cyfrowo wygląda podobnie do tego:
``
'/welcome/default/two?a=123&_signature=4981bc70e13866bb60e52a09073560ae822224e9'
``

Trzeba mieć na uwadze, że podpis cyfrowy jest weryfikowany przez funkcje ``URL.verify``.
Funkcja ``URL.verify`` również pobiera argumenty ``hmac_key``, ``salt`` i ``hash_vars``
opisane powyżej a ich wartości muszą pasować do wartości, które zostały przekazane
do funkcji ``URL`` podczas tworzenia podpisu cyfrowego.

Druga i bardziej zaawansowana i bardziej powszechna metoda cyfrowego podpisywania
adresów URL to powiązanie tego z uwierzytelnianiem. Najlepiej wyjaśnić to na przykładzie:

``
@auth.requires_login()
def one():
    return dict(link=URL('two', vars=dict(a=123), user_signature=True)

@auth.requires_signature()
def two():
    # do something
    return locals()
``:code

W tym przypadku ``hmac_key`` jest generowany automatycznie i udostępniany w sesji.
Umożliwia to, aby akcja ``two`` delegowała kontrole dostępu do akcji ``one``.
Jeśli odnośnik został wygenerowany i podpisany, to jest prawidłowy, w innym razie
nie. Jeśli odnośnik zostanie skradziony przez innego użytkownika, to będzie nieprawidłowy.

Dobrą praktyka jest podpisywanie cyfrowo zawsze wywołań zwrotnych Ajax. Jeśli używa
się funkcji ``LOAD`` web2py, to ma się do dyspozycji argument ``user_signature``
służący temu celowi:

``
{{=LOAD('default', 'two', vars=dict(a=123), ajax=True, user_signature=True)}}
``

### ``HTTP`` i ``redirect``
``HTTP``:inxx ``redirect``:inxx

Platforma web2py definiuje tylko jeden nowy wyjątek o nazwie ``HTTP``. Ten wyjątek
może być wywołany gdziekolwiek w modelu, kontrolerze lub widoku poleceniem:

``
raise HTTP(400, "my message")
``:code

Powoduje to, że przepływ sterowania przechodzi z kodu użytkownika z powrotem do
web2py i zwraca odpowiedź HTTP podobną do tego:
``
HTTP/1.1 400 BAD REQUEST
Date: Sat, 05 Jul 2008 19:36:22 GMT
Server: Rocket WSGI Server
Content-Type: text/html
Via: 1.1 127.0.0.1:8000
Connection: close
Transfer-Encoding: chunked

my message
``:code

Pierwszy argument funkcji ``HTTP`` to kod stanu HTTP. Drugi argument to ciąg
znakowy, który będzie zwracany jako ciało odpowiedzi. Dodatkowe nazwane argumenty
są używane do budowy nagłówka odpowiedzi HTTP.
Na przyklad:
``
raise HTTP(400, 'my message', test='hello')
``:code

generuje:
``
HTTP/1.1 400 BAD REQUEST
Date: Sat, 05 Jul 2008 19:36:22 GMT
Server: Rocket WSGI Server
Content-Type: text/html
Via: 1.1 127.0.0.1:8000
Connection: close
Transfer-Encoding: chunked
test: hello

my message
``:code

Jeśli nie chce się zatwierdzić transakcji otwartej bazy danych, to należy ją
wycofać przed wywołaniem wyjątku.

Wszystkie wyjątki inne niż ``HTTP`` powodują, że web2py cofa wszystkie otwarte
transakcje bazy danych, rejestruje komunikat dotyczący ostatniego wywołania
(''ang. traceback''), wydaje bilet odwiedzającemu i zwraca standardową stronę błędu.

Oznacza to, że dla przepływu sterowania między stronami może zostać użyty tylko
wyjątek ``HTTP``. Inne wyjątki muszą zostać wyłapane przez aplikację, w przeciwnym
razie są one biletowane przez web2py.

Polecenie:
``
redirect('http://www.web2py.com')
``:code

jest po prostu skrótem dla:
``
raise HTTP(303,
           'Nastąpi przekierowanie <a href="%s">tutaj</a>' % location,
           Location='http://www.web2py.com')
``:code

Nazwane argumenty metody inicjatora ``HTTP`` są tłumaczone na dyrektywy nagłówka
HTTP, w tym przypadku, docelowe miejsce przekierowania. Wyrażenie ``redirect``
pobiera drugi opcjonalny argument, który jest kodem stanu HTTP dla przekierowania
(domyślnie 303). Zmień ten numer na 307 dla tymczasowego przekierowania lub na 301
dla stałego przekierowania.

Najczęstszym sposobem użycia przekierowania jest przekierowanie do innej strony
tej samej aplikacji i (opcjonalnie) przekazanie parametrów:

``
redirect(URL('index', args=(1,2,3), vars=dict(a='b')))
``:code

W rozdziale 12 omówimy komponenty web2py. Wykonują one żądania Ajax dla akcji web2py.
Jeśli wywoływana akcja wykonuje przekierowanie, to można spowodować, że żądanie Ajax
nastąpi po przekierowaniu albo że cała strona wykona przekierowanie żądania Ajax.
W tym drugim przypadku można ustawić:

``
redirect(...,client_side=True)
``:code


### Umiędzynarodowienie i pluralizacja za pomocą ``T``
``T``:inxx ``umiędzynarodowienie``:inxx

Obiekt ``T`` jest tłumaczem językowym. Stanowi pojedynczą globalną instancję klasy
``gluon.language.translator`` web2py. Wszystkie stałe łańcuchowe (i tylko stałe
łańcuchowe) powinny być oznaczone przez ``T``, na przykład:
``
a = T("hello world")
``:code

Ciągi znakowe oznaczone przez ``T`` są identyfikowane przez web2py jako wymagające
tłumaczenia i będą tłumaczone gdy kod (w modelu, kontrolerze lub widoku) będzie
wykonywany. Jeśli ciąg znakowy do tłumaczenia nie jest stała lecz zmienną, to będzie
dodany do pliku tłumaczenia w czasie wykonania (z wyjątkiem GAE)w celu późniejszego
przetłumaczenia.

Obiekt ``T`` może również zawierać zmienne interpolowane i obsługiwać wiele
równoważnych składni:
``
a = T("hello %s", ('Tim',))
a = T("hello %(name)s", dict(name='Tim'))
a = T("hello %s") % ('Tim',)
a = T("hello %(name)s") % dict(name='Tim')
``:code

Zalecana jest ostatnia składnia ponieważ czyni tłumaczenie najłatwiejszym.
Pierwszy ciąg jest tłumaczony zgodnie z żądanym plikiem językowym, a zmienna
``name`` jest zamieniana niezależnie od języka.

Można łączyć tłumaczone ciągi ze zwykłymi ciągami znakowymi:
``
T("blah ") + name + T(" blah")
``:code

Poniższy kod jest również dozwolony i często stosowany:

``
T("blah %(name)s blah", dict(name='Tim'))
``:code

lub alternatywna składnia
``
T("blah %(name)s blah") % dict(name='Tim')
``:code

W obu przypadkach ciąg tłumaczony występujący przed nazwą zmiennej jest podstawiany
w wyrażeniu "%(name)s". Poniższej alternatywy NIE NALEŻY STOSOWAĆ:
``
T("blah %(name)s blah" % dict(name='Tim'))
``:code

ponieważ ciąg tłumaczony będzie występował po podstawieniu.

#### Ustalenie języka

Żądany język jest określany w polu "Accept-Language" nagłówka HTTP, ale ten wybór
może być zastąpiony programowo przez żądanie określonego pliku, na przykład:
``
T.force('pl-pl')
``:code

który czyta plik językowy "languages/pl-pl.py". Pliki językowe mogą być tworzone
i edytowane poprzez interfejs administracyjny.

Można też wymusić język w każdym tłumaczonym ciągu:

``
T("Hello World", language="pl-pl")
``:code

--------------
W przypadku wielu wymaganych języków, na przykład "pl-pl, fr-ft", web2py próbuje
zlokalizować pliki tłumaczeń "pl-pl.py" i "fr-fr.py". Jeżeli żaden z wymaganych
plików nie zostanie znaleziony, to następuje próba odnalezienia plików "pl.py"
i "pl.py". Jeżeli te pliki nie będą odnalezione, to wybrany zostanie domyślny plik
"default.py". Jeżeli i ten plik nie będzie odnaleziony, to tłumaczenie nie nastąpi.
Bardziej ogólna zasada jest taka, że web2py próbuje dopasować kolejno nazwy plików
"xx-xy-yy.py", "xx-xy.py", "xx.py", "default.py" dla każdego z akceptowanych języków
"xx-xy-yy", próbując znaleźć najbardziej zbliżona nazwę do preferencji językowej
odwiedzającego.
-------------

Tłumaczenie można całkowicie wyłączyć poprzez

``
T.force(None)
``:code

Zwykle, ciąg tłumaczenia jest ewaluowany leniwie podczas renderowania widoku.
Dlatego metoda ``force`` translatora nie będzie wywoływana wewnątrz widoku.

Możliwe jest wyłączenie leniwej ewaluacji poprzez
``
T.lazy = False
``:code

W ten sposób ciągi są tłumaczone natychmiast przez operator ``T`` na podstawie
aktualnie akceptowanego lub wymuszanego języka.

Możliwe jest też wyłączenie leniwej ewaluacji dla pojedynczych ciągów:

``
T("Hello World", lazy=False)
``:code

Powszechnie spotykany problem jest następujący. Oryginalna aplikacja jest w języku
angielskim. Załóżmy, że jest plik tłumaczenia (na przykład polski, "pl-pl.py")
a klient HTTP deklaruje, że jego akceptowanym językiem jest zarówno angielski (en)
jak i polski (pl-pl) w tej kolejności. Ma miejsce niepożądana sytuacja: web2py nie
wie, że domyślny plik tłumaczenia ("default.py") został napisany w języku  angielskim (en).
Dlatego preferować będzie dla wszystkiego tłumaczenie polskie  (pl-pl) ponieważ
może znaleźć tylko plik "pl-pl.py". Gdyby nie znalazł tego pliku, to wybrałby
domyślny plik językowy d"default.py" (angielski).

Istnieją dwa rozwiązania tego problemu: utworzenie tłumaczenia dla języka angielskiego,
co byłoby powtórzeniem istniejącego pliku "default.py" albo rozwiązanie lepsze –
powiadomienie web2py o tym, że powinien zostać zastosowany język angielski (język
w którym zakodowano aplikację). Można to zrobić tak:
``
T.set_current_languages('en', 'en-en')
``:code

Wyrażenie to przechowuje w ``T.current_languages`` listę języków, które nie wymagają
tłumaczenia i wymusza przeładowanie plików językowych.

Trzeba pamiętać, że "pl" i "pl-pl" są różnymi językami z punktu widzenia web2py.
Do obsługi obydwu potrzeba dwóch różnych plików językowych, o nazwach zawsze pisanych
małymi literami. To samo odnosi się do innych języków.

Aktualnie akceptowany język jest przechowywany w
``
T.accepted_language
``:code

#### Tłumaczenie zmiennych

T(...) tłumaczy nie tylko łańcuchy tekstowe ale też może tłumaczyć wartości przechowywane w zmiennych:
``
>>> a="test"
>>> print T(a)
``:code

W tym przypadku słowo "test" jest tłumaczone ale, jeśli jego tłumaczenie nie zostanie
znalezione i jeśli system plików jest zapisywalny, to zostanie ono dodane w pliku
językowym do listy słów w celu przetłumaczenia.

Proszę zauważyć, że może to dać w wyniku wiele plików IO i że można to wyłączyć:

``
T.is_writable = False
``:code

zabezpieczając T przed dynamiczną aktualizacją plików językowych.

#### Komentarze i tłumaczenia złożone

Zdarza się, że ten sam łańcuch tekstowy występujący w różnych kontekstach w aplikacji,
wymaga różnych tłumaczeń opartych na kontekście. Aby to umożliwić, można dodać
komentarze do oryginalnego łańcucha tekstowego. Komentarze nie będą renderowane
ale zostaną wykorzystane przez web2py do określenia najbardziej właściwego tłumaczenia.
Na przykład:

``
T("hello world ## first occurrence")
T("hello world ## second occurrence")
``:code

Tekst występujący po znakach ``##``, to komentarz.

#### Silnik liczby mnogiej

Począwszy od wersji 2.0, web2py zawiera zaawansowany system pluralizacji (PS).
Oznacza to, że gdy tekst oznaczony do tłumaczenia zależy od zmiennej numerycznej,
to może zostać przetłumaczony na podstawie wartości numerycznej. Na przykład
w angielskim możemy zrenderować:

``
x book(s)
``

z

``
a book (x==1)
5 books (x==5)
``

W języku angielskim jest jedna liczba pojedyncza i jedna liczba mnoga. Formę liczby
mnogiej tworzy się przez dodanie końcówki "-s" lub "-es" albo używając formy wyjątkowej.
web2py dostarcza sposób definiowania zasad liczby mnogiej dla każdego języka, jak
również wyjątków od domyślnych reguł. W rzeczywistości web2py już zna zasady tworzenia
liczby mnogiej dla wielu języków. Wie, na przykład, że w języku słoweńskim są 3
formy liczby mnogiej (dla x==1, x==3 albo x==4 i x>4). Zasady te są zakodowane w
pliku "gluon/contrib/plural_rules/*.py" i można tworzyć nowe pliki. Jawne zasady
tworzenia liczby mnogiej dla słów są tworzone przez edytowanie plików pluralizacyjnych
w interfejsie administracyjnym.

Domyślnie PS nie jest aktywowany. Jest on wywoływany przez argument ``symbols``
funkcji ``T``. Na przykład:

``
T("You have %s %%{book}", symbols=10)
``:code

Teraz PS jest aktywowany dla słowa "book" i dla liczby 10.
W wyniku w języku angielskim otrzyma się: "You have 10 books". Proszę zwrócić uwagę,
że "books" to liczba mnoga rzeczownika "book".

PS składa się z 3 elementów:
- wyrażenia zastępczego ``%%{}`` do zaznaczania słów na wejściu funkcji ``T``;
- reguły rozstrzygająca, którą formę słowa należy zastosować ("rules/plural_rules/*.py");
- słownika z formami liczby mnogiej danego słowa ("app/languages/plural-*.py").

Wartością symboli może być pojedyncza zmienna, lista (krotka) zmiennych lub słownik.

Wyrażenie zastępcze ``%%{}`` składa sie z 3 elementów:

``
%%{[<modifier>]<word>[<parameter>]},
``

gdzie:

``
<modifier>::= ! | !! | !!!
<word> ::= każde słowo lub fraza w liczbie pojedynczej pisane małymi literami (!)
<parameter> ::= [index] | (key) | (number)
``

Na przykład:

- ``%%{word}`` jest równoważne ``%%{word[0]}`` (jeśli nie zostały zastosowane jakieś modyfikatory);
- ``%%{word[index]}`` stosuje się gdy parametr symbols jest krotką. Wyrażenie symbols[index] daje liczbę używaną do podejmowania decyzji o tym, która forma słowa ma być wybrana;
- ``%%{word(key)}`` jest używane do pobierania parametru numerycznego z wyrażenia symbols[key];
- ``%%{word(number)}`` umożliwia bezpośrednie ustawienie ``number`` (np.: ``%%{word(%i)}``);
- ``%%{?word?number}`` zwraca "word" jeśli ``number==1``, w przeciwnym razie zwraca ``number``;
- ``%%{?number} or %%{??number}`` zwraca ``number`` jeśli ``number!=1``, w przeciwnym razie zwraca nothing

``T("blabla %s %%{word}", symbols=var)``

``%%{word}`` domyślnie oznacza ``%%{word[0]}``,
gdzie ``[0]`` jest indeksem elementu w krotce symbols.

``T("blabla %s %s %%{word[1]}", (var1, var2))``
PS zostaje zastosowany odpowiednio do "word" i "var2".

Można użyć kilka wyrażeń zastępczych ``%%{}`` o tym samym indeksie:

``T("%%{this} %%{is} %s %%{book}", var)``

lub

``T("%%{this[0]} %%{is[0]} %s %%{book[0]}", var)``

Jest generowane na:

``
var  output
------------------
 1   this is 1 book
 2   these are 2 books
 3   these are 2 books
``

Podobnie można przekazać słownik do parametru symbols:

``
T("blabla %(var1)s %(wordcnt)s %%{word(wordcnt)}",
  dict(var1="tututu", wordcnt=20))
``

co wytworzy:

``
blabla tututu 20 words
``

Można zamienić "1" na każde słowo, które chce się okreśłic w wyrażeniu
zastępczym ``%%{?word?number}``.
Na przykład:

``T("%%{this} %%{is} %%{?a?%s} %%{book}", var)``

wytworzy:

``
var  output
------------------
 1   this is a book
 2   these are 2 books
 3   these are 3 books
 ...
``

Wenątrz ``%%{...}`` można też użyć następujące modyfikatory:

- ``!`` aby kapitalizować tekst (odpowiednik ``string.capitalize``);
- ``!!`` aby kapitalizować każde słowo (odpowiednik ``string.title``)
- ``!!!`` aby kapitalizować każdy znak (odpowiednik ``string.upper``)

Trzeba pamiętać, że można użyć znak ukośnika jako znak ucieczki dla znaków ``!`` i ``?``.

#### Tłumaczenia i pluralizacja a MARKMIN

Można również użyć zaawansowanej składni MARKMIN wewnątrz ciągów tłumaczeń przez zamienienie

``
T("hello world")
``:code

na

``
T.M("hello world")
``

Teraz łańcuch tekstowy akceptuje znaczniki MARKMIN, jak opisano to w [[rozdziale 5 ../05#markmin_syntax]]

### Ciasteczka

``cookies``:inxx

Do obsługi ciasteczek web2py wykorzystuje moduły ciasteczek Pythona.

Ciasteczka z przeglądarki przechowywane są w ``request.cookies`` a ciasteczka
przesłane przez serwer znajdują się w ``response.cookies``.

Ciasteczka można ustawić w następujący sposób:
``
response.cookies['mycookie'] = 'somevalue'
response.cookies['mycookie']['expires'] = 24 * 3600
response.cookies['mycookie']['path'] = '/'
``:code

Druga linia informuje przeglądarkę aby zachowała ciasteczko przez 24 godziny.
Trzecia linia informuje przeglądarkę, aby przesłała ciasteczko z powrotem do
jakiejś aplikacji (ścieżka URL) w bieżącej domenie. Trzeba pamiętać, że jeśli
nie określa się ścieżki do ciasteczka, to przeglądarka przyjmie ścieżkę URL z
żądania HTTP, tak więc ciasteczko zwracane jest tylko do serwera, gdy żądana
jest ta sama ścieżka URL.

Ciasteczko można zabezpieczyć przez:
``
response.cookies['mycookie']['secure'] = True
``:code

Informuje to przeglądarkę aby wysłała ciasteczko z powrotem do serwera tylko
poprzez HTTPS a nie HTTP.

Ciasteczko można pobrać w ten sposób:
``
if request.cookies.has_key('mycookie'):
    value = request.cookies['mycookie'].value
``:code

Jeżeli sesje są włączone, web2py w tle ustawia następujące ciasteczko i używa go
do obsługi sesji:
``
response.cookies[response.session_id_name] = response.session_id
response.cookies[response.session_id_name]['path'] = "/"
``:code

Proszę zwrócić uwagę, że jeśli pojedyncza aplikacja zawiera wiele poddomen i chce
się udostępnić sesję pomiędzy wszystkimi poddomenami (np. sub1.yourdomain.com,
sub2.yourdomain.com itd.), należy jawnie ustawić domenę ciasteczka sesji w następujący
sposób:
``
if not request.env.remote_addr in ['127.0.0.1', 'localhost']:
    response.cookies[response.session_id_name]['domain'] = ".yourdomain.com"
``:code

Powyższy sposób może być przydatny, jeśli, na przykład, chce się aby użytkownik
mógł się logować równocześnie do wszystkich poddomen.

### Aplikacja **init**
``init``:inxx

Podczas wdrażania web2py chce się ustawić domyślną aplikację, czyli aplikację,
która będzie uruchamiana przy pustej ścieżce URL, tak jak tu:
``
http://127.0.0.1:8000
``:code

Domyślnie, przy pustej ścieżce, web2py wyszukuje aplikacji o nazwie **init**.
Jeżeli jej nie znajdzie, to wyszukuje aplikacji **welcome**.

``default_application``:inxx
Nazwę domyślnej aplikacji można zmienić z **init** na inną, ustawiając odpowiednio
``default_application`` w pliku routes.py:
``
default_application = "myapp"
``:code

Uwaga: ``default_application`` po raz pierwszy pojawiło się w web2py w wersji 1.83.

Oto cztery sposoby na ustawienie domyślnej aplikacji:
- Wywołanie domyślnej aplikacji "init".
- Ustawienie ``default_application`` w routes.py na pożądaną nazwę aplikacji.
- Wykonanie odwołania symbolicznego z "applications/init" do folderu swojej aplikacji.
- Użycie przepisania adresu URL, co omówione jest w następnym rozdziale.

### Przepisywanie URL
``url rewrite``:inxx
``routes_in``:inxx
``routes_out``:inxx

W web2py istnieje możliwość przepisania ścieżki URL przychodzących żądań przed
wywołaniem akcji kontrolera (mapowania URL) i odwrotnie, web2py może przepisać
ścieżkę URL generowaną przez funkcję ``URL`` (odwrotne mapowanie URL). Jednym z
powodów dla których trzeba to zrobić jest obsługa starszych adresów URL. Innym
powodem może być uproszenie ścieżek i wykonanie skrótów.

Platforma web2py zawiera dwa odrębne systemy przepisywania URL: łatwy w użyciu
system ''oparty na parametrach'' mający zastosowanie we większości przypadków
i elastyczny system ''oparty na wzorcach'' dobry dla bardziej skomplikowanych
zastosowań. W celu określenia reguł przepisywania URL, trzeba utworzyć nowy plik
w folderze "web2py" o nazwie ``routes.py`` (zawartość ``routes.py`` będzie zależeć
od tego, który z tych dwóch systemów przepisywania zostanie wybrany, tak jak opisano
to w nastęþnych dwóch rozdziałach). Te dwa systemy przepisywania nie mogą być mieszane.

-------
Trzeba pamiętać, że po edytowaniu pliku routes.py trzeba go przeładować. Można to
zrobić jednym z dwóch sposobów: przez ponowne uruchomienie serwera internetowego
albo przez klikniecie przycisku ''Przeładuj'' w interfejsie administracyjnym.
Jeśli popełniony został jakiś błąd trasowania, to nie nastąpi przeładowanie.
-------

#### System trasowania oparty na parametrach

Router oparty na parametrach (parametryczny) zapewnia łatwy dostęp do różnych
gotowych metod przepisywania ścieżek URL. Jego możliwości obejmują:

- Pominięcie w zewnętrznej ścieżce URL (tej tworzonej przez funkcję URL) nazw domyślnej aplikacji, kontrolera i funkcji;
- Odwzorowanie domen (i ewentualnie portów) do aplikacji lub kontrolerów;
- Osadzenie selektora językowego w adresie URL;
- Usuwanie stałych przedrostków z nadchodzących adresów URL i dodawanie ich z powrotem w wychodzących adresach URL;
- Odwzorowywanie plików głównych, takich jak /robots.txt do katalogu plików statycznych (static)  aplikacji.

Parametryczny router zapewnia również nieco bardziej elastycznej walidacji przychodzących adresów URL.

Załóżmy, że napisaliśmy aplikację o nazwie ``myapp`` i uczyniliśmy ja aplikacją
domyślną, tak więc nazwa tej aplikacji nie jest już częścią adresu URL widzianego
przez użytkownika. Nasz domyślny kontroler to ciągle ``default``. Chcemy też usunąć
nazwę kontrolera z adresu URL widzianego przez użytkownika. Oto co należy wpisać
w pliku ``routes.py``:
``
routers = dict(
  BASE  = dict(default_application='myapp'),
)
``:code

To jest to. Parametryczny router jest wystarczająco inteligentny, aby wiedzieć
jak właściwie przekształcić takie adresy URL jak te:
``
http://domain.com/myapp/default/myapp
``:code
lub
``
http://domain.com/myapp/myapp/index
``:code
gdzie normalnie skracana ścieżka byłaby dwuznaczna. Jeśli ma się dwie aplikacje,
``myapp`` i ``myapp2``, to można uzyskać ten sam efekt i dodatkowo ze ścieżki URL
aplikacji ``myapp2`` zostanie usunięta nazwa domyślnego kontrolera, gdy będzie to
bezpieczne (co ma miejsce w większości przypadków).

Oto inny przypadek: załóżmy, że chcemy obsługiwać języki w oparciu o URL, gdzie
ścieżki URL wyglądają tak:
``
http://myapp/en/some/path
``:code
lub (przepisane)
``
http://en/some/path
``:code

Oto jak to zrobić:
``
routers = dict(
  BASE  = dict(default_application='myapp'),
  myapp = dict(languages=['en', 'it', 'jp'], default_language='en'),
)
``:code

Teraz przychodzący adres URL,  wyglądający tak:
``
http:/domain.com/it/some/path
``:code
Będzie kierowany do ``/myapp/some/path``, a request.uri_language zostanie ustawiony
na 'it', wymuszając w ten sposób tłumaczenie. Można również obsługiwać statyczne
pliki specyficzne dla języka:

``
http://domain.com/it/static/filename
``:code
zostanie mapowane do:
``
applications/myapp/static/it/filename
``:code
jeśli ten plik istnieje. Jeśli nie, to adresy URL takie jak:
``
http://domain.com/it/static/base.css
``:code
będą nadal przekształcane na:
``
applications/myapp/static/base.css
``:code
(ponieważ nie istnieje ``static/it/base.css``).

Tak więc można mieć statyczne pliki specyficzne językowo, włączając w to obrazy,
jeśli potrzeba. Obsługiwane jest również mapowanie domenowe:
``
routers = dict(
  BASE  = dict(
      domains = {
          'domain1.com' : 'app1',
          'domain2.com' : 'app2',
      }
  ),
)
``:code
robi to, czego oczekiwaliśmy.

``
routers = dict(
  BASE  = dict(
      domains = {
          'domain.com:80'  : 'app/insecure',
          'domain.com:443' : 'app/secure',
      }
  ),
)
``:code
Odwzorowuje ``http://domain.com`` na kontroler o nazwie ``insecure``, ponieważ
dostęp przez ``HTTPS`` następuje przez kontroler ``secure``. Alternatywnie można
odwzorować różne porty na różne aplikacje, w oczywisty sposób.

W celu uzyskania więcej informacji proszę zapoznać się z plikiem
[["routes.parametric.example.py" https://github.com/web2py/web2py/blob/master/examples/routes.parametric.example.py]]
umieszczonym w folderze "examples" standardowej dystrybucji web2py.

Uwaga: System trasowania ''oparty na parametrach'' został wprowadzony po raz
pierwszy w wersji 1.92.1 web2py.

#### System trasowania oparty na wzorcach

Pomimo, że właśnie opisany system trasowania  ''oparty na parametrach'' powinien
być wystarczający dla większości, alternatywny system trasowania ''oparty na wzorcach''
zapewnia pewną dodatkową elastyczność w bardziej złożonych przypadkach. Aby użyć
system oparty na wzorcach, zamiast definiowania routerów jako słownika parametrów
trasowania, definiuje się dwie listy (lub krotki) dwóch krotek, ``routes_in`` i
``routes_out``. Każda krotka zawiera dwa elementy: wzorzec, który ma zostać być
zamieniony i ciąg znakowy go zastępujący. Na przykład:
``
routes_in = (
  ('/testme', '/examples/default/index'),
)
routes_out = (
  ('/examples/default/index', '/testme'),
)
``:code

Przy tych trasach adres URL:
``
http://127.0.0.1:8000/testme
``:code

jest odwzorowywany na:
``
http://127.0.0.1:8000/examples/default/index
``:code

Dla odwiedzającego wszystkie odnośniki URL do strony wyglądają podobnie do ``/testme``.

Wzorce mają taką samą składnie jak wyrażenia regularne Pythona. Na przykład:
``
  ('.*\.php', '/init/default/index'),
``:code

odwzorowuje wszystkie adresy URL kończące się na ".php" na stronę index.

W drugim warunku reguły można również dokonać przekierowania do innej strony:
``
  ('.*\.php', '303->http://example.com/newpage'),
``:code

Tutaj 303 jest kodem stanu HTTP do przekierowania odpowiedzi.

Czasem zachodzi potrzeba pozbycia się przedrostka z adresów URL, ponieważ chce
się udostępnić tylko jedna aplikację. Można to osiągnąć za pomocą:
``
routes_in = (
  ('/(?P<any>.*)', '/init/\g<any>'),
)
routes_out = (
  ('/init/(?P<any>.*)', '/\g<any>'),
)
``:code

Istnieje również alternatywna składnia umożliwiająca mieszanie notacji wyrażeń
regularnych ze powyższą składnią. Składa się ona ze zmiennej ``$name`` zamiast
``(?P<name>\w+)`` czy ``\g<name>``. Na przykład:
``
routes_in = (
  ('/$c/$f', '/init/$c/$f'),
)

routes_out = (
  ('/init/$c/$f', '/$c/$f'),
)
``:code

Eliminuje to również przedrostek aplikacji "/example" we wszystkich adresach URL.


Używając notacji ze zmienną ``$name``, można automatycznie odwzorowac ``routes_in``
na ``routes_out``, pod warunkiem, że nie używa się wyrażeń regularnych. Na przykład:
``
routes_in = (
  ('/$c/$f', '/init/$c/$f'),
)

routes_out = [(x, y) for (y, x) in routes_in]
``:code

Jeśli istnieje wiele tras, wykonywana jest pierwsza dopasowana ścieżka URL.
Jeśli żaden wzorzec nie zostanie dopasowany, tp ścieżka pozostaje nie zmieniona.

Można użyć zmiennej ``$anything`` aby dopasować cokolwiek (``.*``) aż do końca linii.

Oto minimalna treść pliku "routes.py" dla obsługi żądań pliku favicon.ico i robots.txt:

``favicon``:inxx ``robots``:inxx
``
routes_in = (
  ('/favicon.ico', '/examples/static/favicon.ico'),
  ('/robots.txt', '/examples/static/robots.txt'),
)
routes_out = ()
``:code

Oto bardziej złożony przykład udostępniający pojedynczą aplikację "myapp", bez
zbędnych przedrostków, ale również interfejsy **admin** i **appadmin** oraz katalog static:

``
routes_in = (
  ('/admin/$anything', '/admin/$anything'),
  ('/static/$anything', '/myapp/static/$anything'),
  ('/appadmin/$anything', '/myapp/appadmin/$anything'),
  ('/favicon.ico', '/myapp/static/favicon.ico'),
  ('/robots.txt', '/myapp/static/robots.txt'),
)
routes_out = [(x, y) for (y, x) in routes_in[:-2]]
``:code

Ogólna składnia trasy jest bardzie skomplikowana, niż widzieliśmy to do tej pory.
Oto bardziej ogólny i reprezentatywny przykład:
``
routes_in = (
 ('140\.191\.\d+\.\d+:https?://www.web2py.com:post /(?P<any>.*)\.php',
  '/test/default/index?vars=\g<any>'),
)
``:code

Odwzorowuje to ``http`` lub ``https`` żądań ``POST`` (ale nie pisane małymi literami
"post") dla hosta ``www.web2py.com`` ze zdalnego IP pasującego do wyrażenia regularnego
``
'140\.191\.\d+\.\d+'
``:code

żądana strona pasująca do wyrażenia regularnego
``
'/(?P<any>.*)\.php'
``:code

na
``
'/test/default/index?vars=\g<any>'
``:code

gdzie ``\g<any>`` jest zamieniane przez dopasowanie wyrażenia regularnego.

Ogólna składnia to
``
'[remote address]:[protocol]://[host]:[method] [path]'
``:code

Jeśli brakuje pierwszej sekcji wzorca (wszystko z wyjątkiem ``[path]``), to web2py
dostarcza domyślnie:
``
'.*?:https?://[^:/]+:[a-z]+'
``:code

Całe wyrażenie jest dopasowywane jako wyrażenie regularne, tak więc znak kropki
(.) musi być poprzedzony znakiem ucieczki (znakiem lewego ukośnika) i każde dopasowywane
podwyrażenie można przedstawić przy użyciu ``(?P<...>...)`` wykorzystując składnię
wyrażenia regularnego Pythona. Metoda żądania (zwykle GET lub POST) musi być pisana
małymi literami. Adres URL, który jest dopasowywany musi mieć jakiekolwiek wyrażenie
ucieczkowe ``%xx`` ujęte w znaki cudzysłowu.

Umożliwia to przekierowanie żądań opartych na adresie IP klienta lub domenie, na
typie żądania, na metodzie i na ścieżce. Umożliwia to również, aby web2py odwzorowywał
różne wirtualne hosty w różnych aplikacjach. Każde dopasowane podwyrażenie może być
użyte do budowy docelowej ścieżki URL i ostatecznie przekazane jako zmienna GET.

Wszystkie główne serwery internetowe, takie jak Apache czy lighttpd, mają również
zdolność przepisywania adresów URL. W środowisku produkcyjnym może to być wykorzystane
zamiast ``routes.py``. Cokolwiek się wybierze, zalecamy aby nie kodować na sztywno
wewnętrznych ścieżek URL w aplikacji ale do ich generowania używać funkcji URL.
Sprawi to, że aplikacja będzie bardziej przenośna w przypadku zmiany tras.

##### Przepisywanie adresów URL specyficzne dla aplikacji
``routes_app``:inxx
Gdy stosuje się system trasowania oparty na wzorcach, aplikacja może ustawiać swoje
własne trasy w pliku routes.py zlokalizowanym w podstawowym folderze danej aplikacji.
Jest to możliwe przez konfigurację ``routes_app`` w pliku podstawowym routes.py,
tak aby określić skąd ma być wybrana nazwa przychodzącego adresu URL aplikacji.
Gdy to nastąpi, będzie używany  plik routes.py danej aplikacji w miejsce podstawowego
pliku routes.py.

Format ``routes_app`` jest identyczny z ``routes_in`` z tym wyjątkiem, że wymienialny
wzorzec jest tylko nazwą aplikacja. Jeśli zastosowanie ``routes_app`` do przychodzącego
adresu URL z dopasowaniem nazwy aplikacji nie da rezultatu lub wynikowy plik routes.py
określonej aplikacji nie zostanie znaleziony, to zostanie użyty bazowy plik routes.py.

Uwaga: ``routes_app`` został zastosowany po raz pierwszy w wersji 1.83 web2py.

##### Domyślna aplikacja, kontroler i funkcja
``default_application``:inxx
``default_controller``:inxx
``default_function``:inxx

Gdy używa się systemu trasowania opartego na wzorcach nazwa domyślnej aplikacji,
kontrolera i funkcji mogą być zmienione z **init**, **default** czy **index**
odpowiednio na inna nazwę, przez odpowiednie ustawienie wartości w routes.py:
``
default_application = "myapp"
default_controller = "admin"
default_function = "start"
``:code

Uwaga: Elementy te po raz pierwszy zastosowano w wersji 1.83 web2py.

#### Trasy do stron błędu
``routes_onerror``:inxx

Można również wykorzystać ``routes.py`` do zmiany trasy żądań dla określonych akcji,
w przypadku gdy pojawi się na serwerze błąd. Można określić to trasowanie globalnie
dla całej aplikacji, dla każdego kodu błędu lub dla każdej aplikacji i każdego kodu
błędu. Oto przykład:
``
routes_onerror = [
  ('init/400', '/init/default/login'),
  ('init/*', '/init/static/fail.html'),
  ('*/404', '/init/static/cantfind.html'),
  ('*/*', '/init/error/index')
]
``:code

Dla każdej krotki, porównywany jest pierwszy ciąg ze wzorcem "[app name]/[error code]".
Jeśli pasuje, to błędne żądanie jest przekierowywane na ścieżkę URL określoną w drugim
ciągu dopasowanej krotki. Jeśli ścieżka URL obsługiwanego błędu nie prowadzi do pliku
statycznego, to do akcji błędu dopasowana zostanie następująca zmienna GET:
- ``code``: kod stanu HTTP (np. 404, 500);
- ``ticket``: w postaci "[app name]/[ticket number]" (lub "None" jeśli nie ma biletu);
- ``requested_uri``: odpowiednik ``request.env.request_uri``;
- ``request_url``: odpowiednik ``request.url``.

Zmienne te są dostępne dla akcji obsługującej błędy poprzez ``request.vars`` i mogą
być użyte do generowania odpowiedzi o błędzie. W szczególności, dobrym pomysłem jest
aby akcja błędu zwracała oryginalny kod błędu HTTP zamiast domyślny kod stanu 200 (OK).
Można to zrobić przez ustawienie ``response.status = request.vars.code``. Jest też
możliwe, aby akcja błędu wysyłała (lub kolejkowała) wiadomości email do administratora,
w tym odnośnik do biletu w interfejsie ``admin``.

Unmatched errors display a default error page. This default error page can also be customized here (see "routes.parametric.example.py" and "routes.patterns.example.py" in the "examples" folder):
``
error_message = '<html><body><h1>%s</h1></body></html>'
error_message_ticket = '''<html><body><h1>Internal error</h1>
     Ticket issued: <a href="/admin/default/ticket/%(ticket)s"
     target="_blank">%(ticket)s</a></body></html>'''
``:code

The first variable contains the error message when an invalid application or function is requested. The second variable contains the error message when a ticket is issued.

``routes_onerror`` work with both routing mechanisms.

``error_handler``:inxx
In "routes.py" you can also specify an action in charge of error handling:

``
error_handler = dict(application='error',
                      controller='default',
                      function='index')
``:code

If the ``error_handler`` is specified the action is called without user redirection and the handler action will be in charge of dealing with the error. In the event that the error-handling page itself returns an error, web2py will fall back to its old static responses.


#### Zarządzanie statycznymi aktywami

Since version 2.1.0, web2py has the ability to manage static assets.

When an application is in development, static file can change often, therefore web2py sends static files with no cache headers. This has the side-effect of "forcing" the browser to request static files at every request. This results in low performance when loading the page.

In a "production" site, you may want to serve static files with ``cache`` headers to prevent un-necessary downloads since static files do not change.

``cache`` headers allow the browser to fetch each file only once, thus saving bandwidth and reducing loading time.

Yet there is a problem: What should the cache headers declare? When should the files expire? When the files are first served, the server cannot forecast when they will be changed.

A manual approach consists of creating subfolders for different versions of static files. For example an early version of "layout.css" can be made available at the URL "/myapp/static/css/1.2.3/layout.css". When you change the file, you create a new subfolder and you link it as "/myapp/static/css/1.2.4/layout.css".

This procedure works but it is pedantic since every time you update the css file, you must remember to move it to another folder, change the URL of the file in your layout.html and deploy.

Static asset management solves the problem by allowing the developer to declare a version for a group of static files and they will be requested again only when the version number changes. The asset version number is made part of the file url as in the previous example. The difference from the previous approach is that the version number only appears in the URL, not in the file system.


If you want to serve "/myapp/static/layout.css" with the cache headers, you just need to include the file with a modified URL that includes a version number:
``
/myapp/static/_1.2.3/layout.css
``
(notice the URL defines a version number, it does not appear anywhere else).

Notice that the URL starts with "/myapp/static/", followed by a version number composed by an underscore and 3 integers separated by a period (as described in [[SemVer http://semver.org/]]), then followed by the filename. Also notice that you do not have to create a "_1.2.3/" folder.

Every time the static file is requested with a version in the url, it will be served with "far in the future" cache headers, specifically:
``
Cache-Control : max-age=315360000
Expires: Thu, 31 Dec 2037 23:59:59 GMT
``
This means that the browser will fetch those files only once, and they will be saved "forever" in the browser's cache.

Every time the "_1.2.3/filename" is requested, web2py will remove the version part from the path and serve your file with far in the future headers so they will be cached forever. If you changed the version number in the URL, this tricks the browser into thinking it is requesting a different file, and the file is fetched again.

You can use "_1.2.3", "_0.0.0", "_999.888.888", as long as the version starts with underscore followed by three numbers separated by period.

When in development, you can use ``response.files.append(...)`` to link the static URLs of static files. In this case you can include the "_1.2.3/" part manually, or you take advantage of a new parameter of the response object: ``response.static_version``.
Just include the files the way you used to, for example
``
{{response.files.append(URL('static','layout.css'))}}
``
and in models set
``
response.static_version = '1.2.3'
``:code
This will rewrite automatically every "/myapp/static/layout.css" url as "/myapp/static/_1.2.3/layout.css", for every file included in ``response.files``.

Often in production you let the webserver (apache, nginx, etc.) serve the static files. You need to adjust your configuration in such a way that it will "skip" the "_1.2.3/" part.

For example, in Apache, change this:
``
AliasMatch ^/([^/]+)/static/(.*) \
   /home/www-data/web2py/applications/$1/static/$2
``
into this:
``
AliasMatch ^/([^/]+)/static/(?:_[\d]+.[\d]+.[\d]+/)?(.*) \
   /home/www-data/web2py/applications/$1/static/$2
``

Similarly, in Nginx change this:
``
location ~* /(\w+)/static/ {
    root /home/www-data/web2py/applications/;
    expires max;
}
``
into this:
``
location ~* /(\w+)/static(?:/_[\d]+\.[\d]+\.[\d]+)?/(.*)$ {
   alias /home/www-data/web2py/applications/$1/static/$2;
   expires max;
}
``

### Uruchamianie zadań w tle

In web2py, every HTTP request is served in its own thread. Threads are recycled for efficiency and managed by the web server. For security, the web server sets a time-out on each request. This means that actions should not run tasks that take too long, should not create new threads, and should not fork processes (it is possible but not recommended).

The proper way to run time-consuming tasks is doing it in the background. There is not a single way of doing it, but here we describe three mechanisms that are built into web2py: **cron**, **homemade task queues**, and **scheduler**.

By **cron** we refer to a web2py functionality not to the Unix Cron mechanism. The web2py cron works on windows too.

web2py cron is the way to go if you need tasks in the background at scheduled times and these tasks take a relatively short time compared to the time interval between two calls. Each task runs in its own process, and multiple tasks can run concurrently, but you have no control over how many tasks run. If accidentally one task overlaps with itself, it can cause a database lock and a spike in memory usage.

web2py scheduler takes a different approach. The number of running processes is fixed, and they can run on different machines. Each process is called a worker. Each worker picks a task when available and executes it as soon as possible after the time when it is scheduled to run, but not necessarily at that exact time. There cannot be more processes running than the number of scheduled tasks and therefore no memory spikes. Scheduler tasks can be defined in models and are stored in the database. The web2py scheduler does not implement a distributed queue since it assumes that the time to distribute tasks is negligible compared with the time to run the tasks. Workers pick up the task from the database.

Homemade tasks queues can be a simpler alternative to the web2py scheduler in some cases.

#### Cron
``cron``:inxx

The web2py cron provides the ability for applications to execute tasks at preset times, in a platform-independent manner.

For each application, cron functionality is defined by a crontab file:

``
app/cron/crontab
``

It follows the syntax defined in ref. ``cron``:cite (with some extensions that are specific to web2py).

------
Before web2py 2.1.1, cron was enabled by default and could be disabled with the ``-N`` command line option. Since 2.1.1, cron is disabled by default and can be enabled by the ``-Y`` option. This change was motivated by the desire to push users toward using the new scheduler (which is superior to the cron mechanism) and also because cron may impact on performance.
------

This means that every application can have a separate cron configuration and that cron config can be changed from within web2py without affecting the host OS itself.

Here is an example:
``
0-59/1  *  *  *  *  root python /path/to/python/script.py
30      3  *  *  *  root *applications/admin/cron/db_vacuum.py
*/30    *  *  *  *  root **applications/admin/cron/something.py
@reboot root    *mycontroller/myfunction
@hourly root    *applications/admin/cron/expire_sessions.py
``:code

The last two lines in this example use extensions to regular cron syntax to provide additional web2py functionality.

-------
The file "applications/admin/cron/expire_sessions.py" actually exists and ships with the **admin** app. It checks for expired sessions and deletes them. "applications/admin/cron/crontab" runs this task hourly.
-------

If the task/script is prefixed with an asterisk (``*``) and ends with ``.py``, it will be executed in the web2py environment. This means you will have all the controllers and models at your disposal. If you use two asterisks (``**``), the models will not be executed. This is the recommended way of calling, as it has less overhead and avoids potential locking problems.

Notice that scripts/functions executed in the web2py environment require a manual ``db.commit()`` at the end of the function or the transaction will be reverted.

web2py does not generate tickets or meaningful tracebacks in shell mode, which is how cron is run, so make sure that your web2py code runs without errors before you set it up as a cron task as you will likely not be able to see those errors when run from cron. Moreover, be careful how you use models: while the execution happens in a separate process, database locks have to be taken into account in order to avoid pages waiting for cron tasks that may be blocking the database. Use the ``**`` syntax if you don't need to use the database in your cron task.

You can also call a controller function, in which case there is no need to specify a path. The controller and function will be that of the invoking application. Take special care about the caveats listed above. Example:
``
*/30  *  *  *  *  root *mycontroller/myfunction
``:code

If you specify ``@reboot`` in the first field in the crontab file, the given task will be executed only once, at web2py startup. You can use this feature if you want to pre-cache, check, or initialize data for an application on web2py startup. Note that cron tasks are executed in parallel with the application --- if the application is not ready to serve requests until the cron task is finished, you should implement checks to reflect this. Example:
``
@reboot  root *mycontroller/myfunction
``:code

Depending on how you are invoking web2py, there are four modes of operation for web2py cron.
- ''soft cron'': available under all execution modes
- ''hard cron'': available if using the built-in web server (either directly or via Apache mod_proxy)
- ''external cron'': available if you have access to the system's own cron service
- No cron

The default is hard cron if you are using the built-in web server; in all other cases, the default is soft cron.  Soft cron is the default method if you are using CGI, FASTCGI or WSGI (but note that soft cron is not ``enabled`` by default in the standard ``wsgihandler.py`` file provided with web2py).

Your tasks will be executed on the first call (page load) to web2py after the time specified in crontab; but only after processing the page, so no delay will be observed by the user. Obviously, there is some uncertainty regarding precisely when the task will be executed, depending on the traffic the site receives. Also, the cron task may get interrupted if the web server has a page load timeout set. If these limitations are not acceptable, see ''external cron''. Soft cron is a reasonable last resort, but if your web server allows other cron methods, they should be preferred over soft cron.

Hard cron is the default if you are using the built-in web server (either directly or via Apache mod_proxy). Hard cron is executed in a parallel thread, so unlike soft cron, there are no limitations with regard to run time or execution time precision.

External cron is not default in any scenario, but requires you to have access to the system cron facilities. It runs in a parallel process, so none of the limitations of soft cron apply. This is the recommended way of using cron under WSGI or FASTCGI.

Example of line to add to the system crontab, (usually /etc/crontab):
``
0-59/1 * * * * web2py cd /var/www/web2py/ && python web2py.py -J -C -D 1 >> /tmp/cron.output 2>&1
``:code

With external ``cron``, make sure to add either ``-J`` (or ``--cronjob``, which is the same) as indicated above so that web2py knows that task is executed by cron. Web2py sets this internally with soft and hard ``cron``.

#### Homemade task queues

While cron is useful to run tasks at regular time intervals, it is not always the best solution to run a background task. For this purpose web2py provides the ability to run any python script as if it were inside a controller:
``
python web2py.py -S app -M -R applications/app/private/myscript.py -A a b c
``:code

where ``-S app`` tells web2py to run "myscript.py" as "app", ``-M`` tells web2py to execute models, and ``-A a b c`` passes optional command line arguments ``sys.args=['a','b','c']`` to "myscript.py".

This type of background process should not be executed via cron (except perhaps for cron @reboot) because you need to be sure that no more than one instance is running at the same time. With cron it is possible that a process starts at cron iteration 1 and is not completed by cron iteration 2, so cron starts it again, and again, and again - thus jamming the mail server.

In chapter 8, we will provide an example of how to use the above method to send emails.


#### Terminarz 

Prior to version 2.6.0 the scheduler was considered experimental. From v2.6.0 the documented API is stable.
The stable API consists of these functions:
- disable()
- resume()
- terminate()
- kill()
- queue_task(), 
- task_status() 
- stop_task()

The web2py scheduler works very much like the task queue described in the previous sub-section with some differences:
- It provides a standard mechanism for creating, scheduling, and monitoring tasks.
- There is not a single background process but a set of workers processes.
- The job of worker nodes can be monitored because their state, as well as the state of the tasks, is stored in the database.
- It works without web2py but that is not documented here.

The scheduler does not use cron, although one can use cron @reboot to start the worker nodes.

More information about deploying the scheduler under Linux and Windows is in the Deployment recipes chapter.

In the scheduler, a task is simply a function defined in a model (or in a module and imported by a model). For example:

``
def task_add(a,b):
    return a+b
``:code

Tasks will always be called in the same environment seen by controllers and therefore they see all the global variables defined in models, including database connections (``db``).
Tasks differ from a controller action because they are not associated with an HTTP request and therefore there is no ``request.env``.
Also, tasks can access another environmental variable that is not present in normal requests: ``W2P_TASK``. ``W2P_TASK.id`` holds the ``scheduler_task.id`` and ``W2P_TASK.uuid`` the ``scheduler_task.uuid`` field of the task that is running.

------
Remember to call ``db.commit()`` at the end of every task if it involves inserts/updates to the database. web2py commits by default at the end of a successful action but the scheduler tasks are not actions.
------

To enable the scheduler you must instantiate the Scheduler class in a model.
The recommended way to enable the scheduler to your app is to create a model file named ``scheduler.py`` and define your function there. After the functions, you can put the following code into the model:

``
from gluon.scheduler import Scheduler
scheduler = Scheduler(db)
``:code

If your tasks are defined in a module (as opposed to a model) you may have to restart the workers.

The task is scheduled with

``
scheduler.queue_task(task_add,pvars=dict(a=1,b=2))
``:code


##### Parametry

The first argument of the ``Scheduler`` class must be the database to be used by the scheduler to communicate with the workers. This can be the ``db`` of the app or another dedicated ``db``, perhaps one shared by multiple apps. If you use SQLite it's recommended to use a separate db from the one used by your app in order to keep the app responsive.
Once the tasks are defined and the ``Scheduler`` is instantiated, all that is needed to do is to start the workers. You can do that in several ways:

``
python web2py.py -K myapp
``
starts a worker for the app ``myapp``. If you want start multiple workers for the same app, you can do so just passing ``myapp,myapp``. You can pass also the ``group_names`` (overriding the one set in your model) with

``
python web2py.py -K myapp:group1:group2,myotherapp:group1
``

If you have a model called ``scheduler.py`` you can start/stop the workers from web2py's default window (the one you use to set the ip address and the port).

##### Terminarz wdrażania
One last nice addition: if you use the embedded webserver, you can start the webserver and the scheduler with just one line of code (this assumes you don't want the web2py window popping up, else you can use the "Schedulers" menu instead)

``
python web2py.py -a yourpass -K myapp -X
``
You can pass the usual parameters (-i, -p, here -a prevents the window from showing up), pass whatever app in the -K parameter and append a -X. The scheduler will run alongside the webserver!

Windows users looking to create a service should see the Deployment Recipes chapter.


##### Kompletna sygnatura terminarza
Scheduler's complete signature is:

``
Scheduler(
    db,
    tasks=None,
    migrate=True,
    worker_name=None,
    group_names=None,
    heartbeat=HEARTBEAT,
    max_empty_runs=0,
    discard_results=False,
    utc_time=False
)
``:code

Let's see them in order:

- ``db`` is the database DAL instance where you want the scheduler tables be placed.
- ``tasks`` is a dictionary that maps task names into functions. If you do not pass this parameter, function will be searched in the app environment.
- ``worker_name`` is None by default. As soon as the worker is started, a worker name is generated as hostname-uuid. If you want to specify that, be sure that it's unique.
- ``group_names`` is by default set to **[main]**. All tasks have a ``group_name`` parameter, set to **main** by default. Workers can only pick up tasks of their assigned group.

------
NB: This is useful if you have different workers instances (e.g. on different machines) and you want to assign tasks to a specific worker.

NB2: It's possible to assign a worker more groups, and they can be also all the same, as ``['mygroup','mygroup']``. Tasks will be distributed taking into consideration that a worker with group_names ``['mygroup','mygroup']`` is able to process the double of the tasks a worker with group_names ``['mygroup']`` is.
------

- ``heartbeat`` is by default set to 3 seconds. This parameter is the one controlling how often a scheduler will check its status on the ``scheduler_worker`` table and see if there are any **ASSIGNED** tasks to itself to process.
- ``max_empty_runs`` is 0 by default, that means that the worker will continue to process tasks as soon as they are **ASSIGNED**. If you set this to a value of, let's say, 10, a worker will die automatically if it's **ACTIVE** and no tasks are **ASSIGNED** to it for 10 loops. A loop is when a worker searches for tasks, every 3 seconds (or the set ``heartbeat``)
- ``discard_results`` is False by default. If set to True, no scheduler_run records will be created.

------
NB: scheduler_run records will be created as before for **FAILED**, **TIMEOUT** and **STOPPED** tasks's statuses.
------

- ``utc_time`` is False by default. If you need to coordinate with workers living in different timezones, or don't have problems with solar/DST times, supplying datetimes from different countries, etc, you can set this to True. The scheduler will honor the UTC time and work leaving the local time aside. Caveat: you need to schedule tasks with UTC times (for start_time, stop_time, and so on.)

Now we have the infrastructure in place: defined the tasks, told the scheduler about them, started the worker(s). What remains is to actually schedule the tasks


##### Zadania
Tasks can be scheduled programmatically or via appadmin. In fact, a task is scheduled simply by adding an entry in the table "scheduler_task", which you can access via appadmin:

``
http://127.0.0.1:8000/myapp/appadmin/insert/db/scheduler_task
``

The meaning of the fields in this table is obvious. The "args" and "vars"" fields are the values to be passed to the task in JSON format. In the case of the "task_add" above, an example of "args" and "vars" could be:

``
args = [3, 4]
vars = {}
``:code

or

``
args = []
vars = {'a':3, 'b':4}
``:code

The ``scheduler_task`` table is the one where tasks are organized.

To add tasks via the API, use
``
scheduler.queue_task('mytask',...)
``
which is documented [[below #queue_task_sig]] .


##### Cykl życia zadania
All tasks follow a lifecycle


[[scheduler tasks @///image/ce8edcc3.png center]]

By default, when you send a task to the scheduler, 
it is in the **QUEUED** status.
If you need it to be executed later, use the ``start_time`` parameter (default = now).
If for some reason you need to be sure that the task does not 
get executed after a certain point in time (maybe a request to a web service
that shuts down at 1AM, a mail that needs to be sent not after the working hours, etc...) you can set a ``stop_time`` (default = None) for it.
If your task is NOT picked up by a worker before ``stop_time``, it will be set as **EXPIRED**.
Tasks with no ``stop_time`` set or picked up **BEFORE** stop_time are **ASSIGNED** to a worker. When a workers picks up a task, its status is set to **RUNNING**.

**RUNNING** tasks may end up:
- **TIMEOUT** when more than ``n`` seconds passed with ``timeout`` parameter (default = 60 seconds).
- **FAILED** when an exception is detected,
- **COMPLETED** when they successfully complete.

Values for ``start_time`` and ``stop_time`` should be datetime objects. To schedule "mytask" to run at 30 seconds from the current time, for example, you would do the following:

``
from datetime import timedelta as timed
scheduler.queue_task('mytask',
    start_time=request.now + timed(seconds=30))
``:code

Additionally, you can control how many times a task should be repeated (i.e. you need to aggregate some data at specified intervals). To do so, set the ``repeats``
parameter (default = 1 time only, 0 = unlimited). You can influence how many seconds should pass between executions with the ``period`` parameter (default = 60 seconds).

------
Default behavior: The time period is not calculated between the END of the first round and the START of the next, but from the START time of the first round to the START time of the next cycle). 
This can cause accumulating 'drift' in the start time of a job.
After v 2.8.2, a new parameter ``prevent_drift`` was added, defaulting to False. If set to True when queing a task, the start_time parameter will take precedence over the period, preventing drift.
------

You can also set how many times the function can raise an exception (i.e. requesting data from a slow web service) and be queued again instead of stopping in **FAILED**  status using the parameter ``retry_failed`` (default = 0, -1 = unlimited).

[[task repeats @///image/7d8b85e4.png center]]

Summary: you have
- ``period`` and ``repeats`` to get an automatically rescheduled function
- ``timeout`` to be sure that a function doesn't exceed a certain amount of time
- ``retry_failed`` to control how many times the task can "fail"
- ``start_time`` and ``stop_time`` to schedule a function in a restricted timeframe

##### ``queue_task`` i ``task_status`` [[queue_task_sig]]

The method:
``
scheduler.queue_task(
    function,
    pargs=[],
    pvars={},
    start_time=now, 		#datetime
    stop_time = None,		#datetime
    timeout = 60,               #seconds
    prevent_drift=False,
    period=60,                  #seconds
    immediate=False,
    repeats = 1
)
``:code
allows you to queue tasks to be executed by workers. 
It returns a row (see [[here #queue_task_return]]), and it takes the following parameters:

- ``function`` (required): It can be a task name or a reference to an actual function.
- ``pargs``: are the arguments to be passed to the task, stored as a Python list.
- ``pvars`` : are the named arguments to be passed to the task, stored as a Python dictionary.
- all other scheduler_task columns can be passed as keyword arguments; the most important are shown.

For example:

``
scheduler.queue_task('demo1', [1,2])
``
 
does the exact same thing as 

``
scheduler.queue_task('demo1', pvars={'a':1, 'b':2})
``:code

as

``
st.validate_and_insert(function_name='demo1', args=json.dumps([1,2]))
``:code

and as:

``
st.validate_and_insert(function_name='demo1', vars=json.dumps({'a':1,'b':2}))
``:code

Here is a more complex complete example:
``
def task_add(a,b):
    return a+b

scheduler = Scheduler(db, tasks=dict(demo1=task_add))

scheduler.queue_task('demo1', pvars=dict(a=1,b=2),
                     repeats = 0, period = 180)
``:code

Since version 2.4.1 if you pass an additional parameter ``immediate=True`` it will force the main worker to reassign tasks. Until 2.4.1, the worker checks for new tasks every 5 cycles (so, ``5*heartbeats`` seconds). If you had an app that needed to check frequently for new tasks, to get a ''snappy'' behaviour you were forced to lower the ``heartbeat`` parameter, putting the db under pressure for no reason. With ``immediate=True`` you can force the check for new tasks: it will happen at most as ``heartbeat`` seconds are passed   

A call to ``scheduler.queue_task`` returns the task ``id`` and ``uuid`` of the task you queued (can be the one you passed or the auto-generated one), and possible ``errors``: [[queue_task_return]]

``
<Row {'errors': {}, 'id': 1, 'uuid': '08e6433a-cf07-4cea-a4cb-01f16ae5f414'}>
``
 
If there are errors (usually syntax error or input validation errors),
you get the result of the validation, and id and uuid will be None

``
<Row {'errors': {'period': 'enter an integer greater than or equal to 0'}, 'id': None, 'uuid': None}>
``

##### Wyniki i dane wyjściowe

The table "scheduler_run" stores the status of all running tasks. Each record references a task that has been picked up by a worker.  One task can have multiple runs. For example, a task scheduled to repeat 10 times an hour will probably have 10 runs (unless one fails or they take longer than 1 hour). Beware that if the task has no return values, it is removed from the scheduler_run table as soon as it is finished.

Possible run statuses are:

``
RUNNING, COMPLETED, FAILED, TIMEOUT
``

If the run is completed, no exceptions are thrown, and there is no task timeout, the run is marked as ``COMPLETED`` and the task is marked as ``QUEUED`` or ``COMPLETED`` depending on whether it is supposed to run again at a later time. The output of the task is serialized in JSON and stored in the run record.

When a ``RUNNING`` task throws an exception, the run is mark as ``FAILED`` and the task is marked as ``FAILED``. The traceback is stored in the run record.

Similarly, when a run exceeds the timeout, it is stopped and marked as ``TIMEOUT``, and the task is marked as ``TIMEOUT``.

In any case, the stdout is captured and also logged into the run record.

Using appadmin, one can check all ``RUNNING`` tasks, the output of ``COMPLETED`` tasks, the error of ``FAILED`` tasks, etc.

The scheduler also creates one more table called "scheduler_worker", which stores the workers' heartbeat and their status.

##### Zarządzanie procesami

Worker fine management is hard. This module tries not to leave behind any platform (Mac, Win, Linux) .

When you start a worker, you may later want to:
- kill it "no matter what it's doing"
- kill it only if it is not processing tasks
- put it to sleep
Maybe you have yet some tasks queued, and you want to save some resources.
You know you want them processed every hour, so, you'll want to:
- process all queued tasks and die automatically
All of these things are possible managing ``Scheduler`` parameters or the ``scheduler_worker`` table.
To be more precise, for started workers you can change the ``status`` value of any worker to influence
its behavior.
As for tasks, workers can be in one of the following statuses: ACTIVE, DISABLED, TERMINATE or KILLED.

**ACTIVE** and **DISABLED** are "persistent", while **TERMINATE** or **KILL**, as statuses
name suggest, are more "commands" than real statuses.
Hitting ctrl+c is equal to set a worker to **KILL**

[[workers statuses @///image/bd891eed.png center]]

There are a few commodity functions since version 2.4.1 (self-explanatory)
``
scheduler.disable()
scheduler.resume()
scheduler.terminate()
scheduler.kill()
``:code

each function take an optional parameter, that can be a string or a list, to manage workers based on their ``group_names``. It defaults to the ``group_names`` defined in the scheduler istantiation.

An example is better than a thousand words: ``scheduler.terminate('high_prio')`` will TERMINATE all the workers that are processing the ``high_prio`` tasks, while ``scheduler.terminate(['high_prio', 'low_prio'])`` will terminate all ``high_prio`` and ``low_prio`` workers.
------
Watch out: if you have a worker processing ``high_prio`` and ``low_prio``, ``scheduler.terminate('high_prio')`` will terminate the worker alltogether, even if you didn't want to terminate ``low_prio`` too.
------

Everything that one can do via appadmin one can do programmatically by inserting and updating records in these tables.

Anyway, one should not update records relative to ``RUNNING`` tasks as this may create an un-expected behavior. The best practice is to queue tasks using the "queue_task" method.

For example:

``
scheduler.queue_task(
    function_name='task_add',
    pargs=[],
    pvars={'a':3,'b':4},
    repeats = 10, # run 10 times
    period = 3600, # every 1h
    timeout = 120, # should take less than 120 seconds
    )
``:code

Notice that fields "times_run", "last_run_time" and "assigned_worker_name" are not provided at schedule time but are filled automatically by the workers.

You can also retrieve the output of completed tasks:

``
completed_runs = db(db.scheduler_run.run_status='COMPLETED').select()
``:code

------
The scheduler is considered experimental because it needs more extensive testing and because the table structure may change as more features are added.
------

##### Procentowe raportowanie

A special "word" encountered in the print statements of your functions clear all
the previous output. That word is ``!clear!``.
This, coupled with the ``sync_output`` parameter, allows to report percentages.


Here is an example:

``
def reporting_percentages():
    time.sleep(5)
    print '50%'
    time.sleep(5)
    print '!clear!100%'
    return 1
``

The function ``reporting_percentages`` sleeps for 5 seconds, outputs ``50%``.
Then, it sleeps other 5 seconds and outputs ``100%``. Note that the output in the scheduler_run table is synced every 2 seconds and that the second print statement that contains ``!clear!100%`` gets the ``50%`` output cleared and replaced by ``100%`` only.

``
scheduler.queue_task(reporting_percentages,
                     sync_output=2)
``:code


### Moduły osób trzecich
``import``:inxx

web2py is written in Python, so it can import and use any Python module, including third party modules. It just needs to be able to find them. As with any Python application, modules can be installed in the official Python "site-packages" directory, and they can then be imported from anywhere inside your code.

Modules in the "site-packages" directory are, as the name suggests, site-level packages. Applications requiring site-packages are not portable unless these modules are installed separately. The advantage of having modules in "site-packages" is that multiple applications can share them. Let's consider, for example, the plotting package called "matplotlib". You can install it from the shell using the PEAK ``easy_install`` command ``easy-install``:cite (or its modern replacement ``pip`` ``PIP``:cite ):
``
easy_install py-matplotlib
``:code

and then you can import it into any model/controller/view with:
``
import matplotlib
``:code

The web2py source distribution, and the Windows binary distribution has a site-packages in the top-level folder. The Mac binary distribution has a site-packages folder in the folder:

``web2py.app/Contents/Resources/site-packages``:code

The problem with using site-packages is that it becomes difficult to use different versions of a single module at the same time, for example there could be two applications but each one uses a different version of the same file.  In this example, ``sys.path`` cannot be altered because it would affect both applications.

For this kind of situation, web2py provides another way to import modules in such a way that the global ``sys.path`` is not altered: by placing them in the "modules" folder of an application. One side benefit is that the module will be automatically copied and distributed with the application.

------
Once a module "mymodule.py" is placed into an app "modules/" folder, it can be imported from anywhere inside a web2py application (without need to alter ``sys.path`` with):
``
import mymodule
``
------

### Środowisko wykonawcze
``exec_environment``:inxx

-----
While everything discussed here works fine, we recommend instead building your application using components, as described in chapter 12.
-----

web2py model and controller files are not Python modules in that they cannot be imported using the Python ``import`` statement. The reason for this is that models and controllers are designed to be executed in a prepared environment that has been pre-populated with web2py global objects (request, response, session, cache and T) and helper functions. This is necessary because Python is a statically (lexically) scoped language, whereas the web2py environment is created dynamically.

web2py provides the ``exec_environment`` function to allow you to access models and controllers directly. ``exec_environment`` creates a web2py execution environment, loads the file into it and then returns a Storage object containing the environment. The Storage object also serves as a namespace mechanism. Any Python file designed to be executed in the execution environment can be loaded using ``exec_environment``. Uses for ``exec_environment`` include:
- Accessing data (models) from other applications.
- Accessing global objects from other models or controllers.
- Executing controller functions from other controllers.
- Loading site-wide helper libraries.

This example reads rows from the ``user`` table in the ``cas`` application:
``
from gluon.shell import exec_environment
cas = exec_environment('applications/cas/models/db.py')
rows = cas.db().select(cas.db.user.ALL)
``:code

Another example: suppose you have a controller "other.py" that contains:
``
def some_action():
    return dict(remote_addr=request.env.remote_addr)
``:code

Here is how you can call this action from another controller (or from the web2py shell):
``
from gluon.shell import exec_environment
other = exec_environment('applications/app/controllers/other.py', request=request)
result = other.some_action()
``:code

In line 2, ``request=request`` is optional. It has the effect of passing the current request to the environment of "other". Without this argument, the environment would contain a new and empty (apart from ``request.folder``) request object. It is also possible to pass a response and a session object to ``exec_environment``. Be careful when passing request, response and session objects --- modification by the called action or coding dependencies in the called action could lead to unexpected side effects.

The function call in line 3 does not execute the view; it simply returns the dictionary unless ``response.render`` is called explicitly by "some_action".

One final caution: don't use ``exec_environment`` inappropriately. If you want the results of actions in another application, you probably should implement an XML-RPC API (implementing an XML-RPC API with web2py is almost trivial). Don't use ``exec_environment`` as a redirection mechanism; use the ``redirect`` helper.

### Współpraca
``cooperation``:inxx

There are many ways applications can cooperate:
- Applications can connect to the same database and thus share tables. It is not necessary that all tables in the database are defined by all applications, but they must be defined by those applications that use them. All applications that use the same table, but one, must define the table with ``migrate=False``.
- Applications can embed components from other applications using the LOAD helper (described in Chapter 12).
- Applications can share sessions.
- Applications can call each other's actions remotely via XML-RPC.
- Applications can access each other's files via the filesystem (assuming they share the same filesystem).
- Applications can call each other's actions locally using ``exec_environment`` as discussed above.
- Applications can import each other's modules using the syntax:
``
from applications.otherapp.modules import mymodule
``:code

or

``
import applications.otherapp.modules.othermodule
``:code

- Applications can import any module in the ``PYTHONPATH`` search path, ``sys.path``.

One app can load the session of another app using the command:

``
session.connect(request, response, masterapp='appname', db=db)
``:code

Here "appname" is the name of the master application, the one that sets the initial session_id in the cookie. ``db`` is a database connection to the database that contains the session table (``web2py_session``). All apps that share sessions must use the same database for session storage.


### Rejestrowanie zdarzeń

Python provides logging APIs. Web2py provides a mechanism to configure it so
that apps can use it.

In your application, you can create a logger, for example in a model:

``
import logging
logger = logging.getLogger("web2py.app.myapp")
logger.setLevel(logging.DEBUG)
``:code

and you can use it to log messages of various importance

``
logger.debug("Just checking that %s" % details)
logger.info("You ought to know that %s" % details)
logger.warn("Mind that %s" % details)
logger.error("Oops, something bad happened %s" % details)
``:code

``logging`` is a standard python module described here:
``
http://docs.python.org/library/logging.html
``
The string "web2py.app.myapp" defines an app-level logger.

For this to work properly, you need a configuration file for the logger.
One is provided by web2py in the "examples" folder "logging.example.conf". You need to copy the file to web2py's directory and rename the file to "logging.conf" and customize it as necessary.

This file is self documenting, so you should open it and read it.

To create a configurable logger for application "myapp", you must add myapp to
the [loggers] keys list:

``
[loggers]
keys=root,rocket,markdown,web2py,rewrite,app,welcome,myapp
``:code

and you must add a [logger_myapp] section, using [logger_welcome] as a starting point.

``
[logger_myapp]
level=WARNING
qualname=web2py.app.myapp
handlers=consoleHandler
propagate=0
``:code

The "handlers" directive specifies the type of logging and here it is logging "myapp" to the console.

### WSGI
``WSGI``:inxx

web2py and WSGI have a love-hate relationship. Our perspective is that WSGI was developed as a protocol to connect web servers to web applications in a portable way, and we use it for that purpose. web2py at its core is a WSGI application: ``gluon.main.wsgibase``. Some developers have pushed WSGI to its limits as a protocol for middleware communications and develop web applications as an onion with many layers (each layer being a WSGI middleware developed independently of the entire framework). web2py does not adopt this structure internally. This is because we feel the core functionality of a frameworks (handling cookies, session, errors, transactions, dispatching) can be better optimized for speed and security if they are handled by a single comprehensive layer.

Yet web2py allows you to use third party WSGI applications and middleware in three ways (and their combinations):
- You can edit the file "wsgihandler.py" and include any third party WSGI middleware.
- You can connect third party WSGI middleware to any specific action in your apps.
- You can call a third party WSGI app from your actions.

The only limitation is that you cannot use third party middleware to replace core web2py functions.

#### Zewnętrzna warstwa pośrednia

Consider the file "wsgibase.py":
``
#...
LOGGING = False
#...
if LOGGING:
    application = gluon.main.appfactory(wsgiapp=gluon.main.wsgibase,
                                        logfilename='httpserver.log',
                                        profilerfilename=None)
else:
    application = gluon.main.wsgibase
``:code

When ``LOGGING`` is set to ``True``, ``gluon.main.wsgibase`` is wrapped by the middleware function ``gluon.main.appfactory``. It provides logging to the "httpserver.log" file. In a similar fashion you can add any third party middleware. We refer to the official WSGI documentation for more details.

#### Wewnętrzna warstwa pośrednia

Given any action in your controllers (for example ``index``) and any third party middleware application (for example ``MyMiddleware``, which converts output to upper case), you can use a web2py decorator to apply the middleware to that action. Here is an example:
``
class MyMiddleware:
    """converts output to upper case"""
    def __init__(self,app):
        self.app = app
    def __call__(self, environ, start_response):
        items = self.app(environ, start_response)
        return [item.upper() for item in items]

@request.wsgi.middleware(MyMiddleware)
def index():
    return 'hello world'
``:code

We cannot promise that all third party middleware will work with this mechanism.

#### Wywoływanie aplikacji ''WSGI''

It is easy to call WSGI app from a web2py action. Here is an example:
``
def test_wsgi_app(environ, start_response):
    """this is a test WSGI app"""
    status = '200 OK'
    response_headers = [('Content-type','text/plain'),
                        ('Content-Length','13')]
    start_response(status, response_headers)
    return ['hello world!\n']

def index():
    """a test action that calls the previous app and escapes output"""
    items = test_wsgi_app(request.wsgi.environ,
                          request.wsgi.start_response)
    for item in items:
        response.write(item,escape=False)
    return response.body.getvalue()
``:code

In this case, the ``index`` action calls ``test_wsgi_app`` and escapes the returned value before returning it. Notice that ``index`` is not itself a WSGI app and it must use the normal web2py API (such as ``response.write`` to write to the socket).
