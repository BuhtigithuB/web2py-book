## Vue d'ensemble

### Démarrage

``Linux``:inxx ``Mac``:inxx ``Windows``:inxx

web2py est fourni en tant que package binaire pour Windows et Mac OS X. Ils incluent l'interpréteur Python et vous n'avez donc pas besoin de l'installer au préalable. Il y a également une version en code source qui fonctionne sur Windows, Mac, Linux et tout autre système Unix. Le package code source nécessite la pré-installation de Python sur votre système.

web2py ne nécessite aucune installation. Pour débuter, dézippez le fichier zip que vous avez téléchargé en fonction de votre système d'exploitation et exécutez le fichier ``web2py`` correspondant.

Sur Unix et Linux (distribution source), exécutez:
``
python web2py.py
``:code

Sur OS X (distribution binaire), exécutez:
``
open web2py.app
``:code

Sur Windows (distribution binaire), exécutez:
``
web2py.exe
``:code

Sur Windows (distribution source), exécutez:
``
c:/Python27/python.exe web2py.py
``:code

------
Attention, pour exécuter web2py sur Windows depuis les sources vous devez d'abord installer les extensions win32 de Mark Hammond's depuis ``http://sourceforge.net/projects/pywin32/``.
------

Le programme web2py accepte diverses options sur la ligne de commande expliquées plus loin.

Par défaut, au démarrage, web2py affiche une fenêtre de lancement puis un widget graphique qui vous demandera de définir un mot de passe administrateur unique, l'adresse IP de l'interface réseau à utiliser pour le serveur web, et un numéro de port pour répondre aux requêtes. Par défaut, web2py utilise son serveur web sur 127.0.0.1:8000 (port 8000 sur localhost), mais vous pouvez le démarrer sur n'importe quel IP/port disponibles. Vous pouvez trouver l'adresse IP de votre interface réseau en ouvrant une invite de commande et en tapant ``ipconfig`` sur Windows ou ``ifconfig`` sur OS X et Linux. A partir de maintenant, nous supposerons que web2py fonctionne sur localhost (127.0.0.1:8000). Utilisez 0.0.0.0:80 pour lancer web2py de manière publique sur n'importe quelle interface réseau.

[[image @///image/en400.png center 306px]]

Si vous ne fournissez pas de mot de passe administrateur, l'interface d'administration est désactivée. C'est une mesure de sécurité pour éviter tout risque d'exposer l'interface administrateur publiquement.

L'interface d'administration, **admin**, est seulement accessible depuis localhost à moins que vous n'exécutiez web2py derrière Apache avec mod_proxy. Si **admin** détecte un proxy, le cookie de session est défini comme sécurisé et la connexion **admin** ne fonctionne pas à moins que la communication entre le client et le proxy ait été définie sur HTTPS; c'est une mesure de sécurité. Toutes les communications entre le client et **admin** doivent toujours être locales et chiffrées; autrement, un attaquant pourrait exécuter une attaque man-in-the-middle ou une attaque de rejeu et exécuter arbitrairement du code sur le serveur.

Une fois que le mot de passe d'administration a été défini, web2py démarre le navigateur web à la page :
``
http://127.0.0.1:8000/
``:code

Si l'ordinateur n'a pas de navigateur par défaut défini, ouvrez un navigateur et entrez l'URL.

[[image @///image/en500.png center 480px]]

En cliquant sur "interface d'administration" vous arriverez sur la page d'identification pour l'interface d'administration.

[[image @///image/en600.png center 480px]]

Le mot de passe administrateur est le mot de passe que vous avez choisi au démarrage.
Notez bien qu'il n'y a qu'un seul administrateur, et de ce fait, un seul mot de passe administrateur. Pour des raisons de sécurité, le développeur se verra demander un nouveau mot de passe à chaque redémarrage de web2py à moins que l'option <recycle> ne soit spécifiée. C'est un mécanisme distinct des authentifications des applications web2py.

Après que l'administrator soit logué sur web2py, le navigateur est redirigé à la page "site".

[[image @///image/en700.png center 480px]]

Cette page liste toutes les applications installées et autorise l'administrateur à les gérer.
web2py est fourni avec trois applications :
``admin``:inxx ``examples``:inxx ``welcome``:inxx ``scaffolding``:inxx
- Une application **admin**, celle que vous utilisez maintenant.
- Une application **examples**, avec une documentation en ligne interactive et une copie du site officiel web2py.
- Une application **welcome**. C'est le modèle basique pour toute autre application web2py. This is the basic template for any other web2py application. Elle est désignée comme ''application échafaudage''. C'est également l'application qui accueille un utilisateur au démarrage.

``appliances``:inxx
Les applications prêtes à l'emploi sont désignées comme ''appliances'' web2py. Vous pouvez télécharger un grand nombre d'appliances disponibles librement depuis ``appliances``:cite . Les utilisateurs web2py sont bien entendu encouragés à soumettre leurs propres appliances, que ce soit sous forme open-source ou non (compilées et packagées).

Depuis la page ''site'' de l'application **admin**, vous pouvez exécuter les opérations suivantes :
- **installer** une application en remplissant le formulaire en bas à droite de la page. Donnez un nom à l'application, choisissez le fichier contenant une application packagée ou l'URL où l'application est stockée, et cliquez sur "installer".
- **désinstaller** une application en cliquant sur le bouton correspondant. Il y a une page de confirmation.
- **créer** une nouvelle application en choisissant un nom et en cliquant sur "créer".
- **packager** une application pour la distribuer en cliquant sur le bouton correspondant. Une application téléchargée est un fichier tar contenant tout, incluant la base de données. Vous ne devriez pas dézipper cette archive; elle est automatiquement dépackagée par web2py lorsqu'elle est installée avec **admin**.
- **nettoyer** une application de ses fichiers temporaires, telles que les sessions, les erreurs et les fichiers de cache.
- **activer/désactiver** chaque application. Lorsqu'une application est désactivée, elle ne peut plus être utilisée de manière distante mais est toujours disponible en localhost. Cela signifie que les applications désactivées peuvent toujours être accessibles derrière un proxy. Une application est désactivée par la création d'un fichier nommé "DISABLED" dans le dossier de l'application. Les utilisateurs qui essaient d'accéder à cette application désactivée recevront une erreur HTTP 503. Vous pouvez utiliser routes_onerror pour personnaliser la page d'erreur.
- **éditer** une application.

-----
Lorsque vous créez une nouvelle application en utilisant **admin**, elle démarre en effectuant un clone de l'application de référence "welcome" avec un "models/db.py" qui créé une base de données SQLite, s'y connecte, instancie Auth, Crud, Service, et les configure. Elle fournit également un "controller/default.py" qui propose les actions "index", "download", "user" pour la gestion des utilisateurs, et "call" pour les services. Par la suite, nous supposons que ces fichiers ont été supprimés; nous créérons les applications sans base.
-----

web2py propose également un **assistant**, décrit plus tard dans ce chapitre, qui peut écrire un code de référence alternatif pour vous en se basant sur les layouts et les plugins disponibles sur le web et sur la description haut niveau des modèles.

### Exemples simples

#### Dites bonjour
``index``:inxx

Ici, comme exemple, nous créons une simple application web qui affiche le message "Hello from MyApp" à l'utilisateur. Nous appellerons cette application "myapp". Nous ajouterons également un compteur qui compte le nombre de fois où un même utilisateur visite la page.

Vous pouvez créer une nouvelle application simplement en tapant son nom dans le formulaire en haut à droite de la page **site** dans **admin**.

[[image @///image/en800.png center 447px]]

Après avoir appuyé sur [create], l'application est créée comme copie de l'application pré-construite "welcome".

[[image @///image/en900.png center 480px]]

Pour démarrer la nouvelle application, allez sur :
``
http://127.0.0.1:8000/myapp
``:code

Vous avez maintenant une copie de l'application "welcome".

Pour éditer une application, cliquez sur le bouton ''modifier'' pour la nouvelle application que vous avez créée.

La page **modifier** vous dit ce que contient l'application.
Toute application web2py possède un ensemble de fichiers, dont la plupart tombe dans l'une de ces six catégories :
- **modèles**: décrit la représentation des données.
- **controleurs**: décrit la logique de l'application et le workflow.
- **vues**: décrit la présentation des données.
- **langues**: décrit comment traduire l'application dans d'autres langues.
- **modules**: les modules Python qui appartiennent à l'application.
- **fichiers statiques**: les images statiques, les fichiers CSS ``css-w,css-o,css-school``:cite , les fichiers JavaScript ``js-w,js-b``:cite , etc.
- **plugins**: groupes de fichiers destinés à fonctionner ensemble.

Tout est soigneusement organisé selon le design pattern Modèle-Vue-Contrôleur. Toute section dans la page ''modifier'' correspond à un sous-dossier dans le dossier de l'application.

Notez que le fait de cliquer sur l'entête d'une section bascule l'affichage de son contenu. Les dossiers dans la section des fichiers statiques sont également repliables.

-------
Chaque fichier listé dans la section correspond à un fichier situé physiquement dans le sous-dossier. N'importe quelle opération exécutée sur un fichier via l'interface **admin** (créer, modifier, supprimer) peut être exécutée directement depuis le shell en utilisant votre éditeur favori.
-------

L'application contient d'autre types de fichiers (base de données, fichiers de session, fichiers d'erreur, etc.), mais ceux-ci ne sont pas listés sur la page ''modifier'' car ils ne sont ni créés ni modifiés par l'administrateur; ils sont créés et modifiés par l'application elle-même.

Les contrôleurs contiennent la logique et le workflow de l'application. Toute URL se voit mappée à l'appel d'une fonction dans les contrôleurs (actions). Il y a deux contrôleurs par défaut : "appadmin.py" et "default.py". **appadmin** fournit l'interface d'administration de la base de données; nous n'en avons pas besoin maintenant. "default.py" est le contrôleur que vous avez besoin de modifier, celui qui est appelé par défaut lorsqu'aucun n'est spécifié dans l'URL. Modifiez la fonction "index" comme suit :
``
def index():
    return "Hello from MyApp"
``:code

Voilà à quoi ressemble l'éditeur en ligne :

[[image @///image/en1000.png center 480px]]

Enregistrez et retournez à la page ''edit''. Cliquez sur le lien de l'index pour visiter la page juste créée.

Lorsque vous visitez l'URL
``
http://127.0.0.1:8000/myapp/default/index
``:code

l'action index du contrôleur par défaut de l'application myapp est appelée. Elle rnvoie une chaîne de caractères que le navigateur affiche pour nous. Votre page devrait ressembler à cela :

[[image @///image/en1100.png center 480px]]

Maintenant, modifiez la fonction "index" comme suit :
``
def index():
    return dict(message="Hello from MyApp")
``:code

Depuis la page ''modifier'', éditez également la vue "default/index.html" (le fichier de vue associé à l'action) et remplacez complètement le contenu actuel de ce fichier avec ce qui suit :
``
<html>
   <head></head>
   <body>
      <h1>{{=message}}</h1>
   </body>
</html>
``:code

Désormais, l'action renvoie un dictionnaire définissant un ``message``. Lorsqu'une action retourne un dictionnaire, web2py cherche une vue avec le nom

``
[controller]/[function].[extension]
``:code

et l'exécute. Ici, ``[extension]`` est l'extension requise. Si aucune extension n'est spécifiée, ce sera par défaut "html", et c'est ce que nous supposerons ici. Sous cette supposition, la vue est un fichier HTML qui embarque du code Python en utilisant les tags spéciaux {{ }}. En particulier, dans l'exemple, le ``{{=message}}`` indique à web2py de remplacer le code tagué avec la valeur de ``message`` retournée par l'action. Notez que ``message`` ici n'est pas un mot-clé web2py mais est défini dans l'action. Jusqu'ici nous n'avons pas utilisé les mots-clé web2py.

Si web2py ne trouve pas la vue requise, il utilise la vue "generic.html" disponible avec toute application.

-------
``Mac Mail``:inxx ``Google Maps``:inxx ``jsonp``:inxx
Si une extension autre que "html" est spécifiée ("json" par exemple), et que le fichier de vue "[controller]/[function].json" n'est pas trouvé, web2py cherche la vue "generic.json". web2py est fourni avec generic.html, generic.json, generic.jsonp, generic.xml, generic.rss, generic.ics (pour Mac Mail Calendar), generic.map (pourles cartes embarquées Google Maps), et generic.pdf (basé sur fpdf). Ces vues génériques peuvent être modifiées pour chaque application individuellement, et des vues additionnelles peuvent être ajoutées facilement.
-------

-------
Les vues génériques sont un outil de développement. En production, toute action devrait avoir sa propre vue. En fait, par défaut, les vues génériques sont seulement activées depuis localhost.
-------

-------
Vous pouvez également spécifier une vue avec ``response.view = 'default/something.html'``
-------

Vous pourrez en savoir plus sur ce sujet au chapitre 10.

Si vous retournez à "modifier" et que vous cliquez sur index, vous nerrez maintenant la page HTML suivante :

[[image @///image/en1200.png center 480px]]

#### Barre d'outil de déboguage
``toolbar``:inxx

Pour des raisons de déboguage vous pouvez insérer

``
{{=response.toolbar()}}
``:code

au code dans une vue et et cela vous affichera les informations utiles, incluant la requête, la réponse et les objets de session, et la liste de toutes les requêtes à la base de données avec leur timing.

#### C'est parti pour compter
``session``:inxx
Ajoutons maintenant un compteur à cette page qui comptera combien de fois le même utilisateur affiche la page.

web2py suit automatiquement et de manière transparente les visiteurs en utilisant les sessions et les cookies. Pour chaque nouveau visiteur, il créé une session et assigne un unique "session_id". La session est un conteneur de variables stockées côté serveur. L'id unique est envoyé au navigateur via un cookie. Lorsque le visiteur requête une autre page depuis la même application, il renvoie le cookie, qui est récupéré par web2py, et la session correspondante est restaurée.

Pour utiliser la session, modifiez le contrôleur par défaut :
``
def index():
    if not session.counter:
        session.counter = 1
    else:
        session.counter += 1
    return dict(message="Hello from MyApp", counter=session.counter)
``:code

Notez que ``counter`` n'est pas un mot-clé web2py mais une ``session``. Nous demandons à web2py de vérifier s'il y a une variable compteur dans la session et, s'il n'y a pas, d'en créer une et de fixer sa valeur à 1. Si le compteur est présent, nous demandons à web2py de l'incrémenter de 1. Finalement nous envoyons la valeur du compteur à la vue.

Un autre moyen plus compact pour coder la même fonction :
``
def index():
    session.counter = (session.counter or 0) + 1
    return dict(message="Hello from MyApp", counter=session.counter)
``:code

Modifiez maintenant la vue pour ajouter une ligne qui affiche la valeur du compteur :
``
<html>
   <head></head>
   <body>
      <h1>{{=message}}</h1>
      <h2>Number of visits: {{=counter}}</h2>
   </body>
</html>
``:code

Lorsque vous visitez la page index à nouveau (et à nouveau) vous devriez voir la page HTML suivante :

[[image @///image/en1300.png center 480px]]

Le compteur est associé à chaque visiteur, et est incrémenté chaque fois que le visiteur recharge la page. Différents visiteurs voient différents compteurs.


#### Dites mon nom
``form``:inxx ``request.vars``:inxx

Créez maintenant deux pages (première et deuxième), où la première page créé un formulaire, demande le nom du visiteur, et redirige vers la seconde page, qui salue le visiteur par nom.

[[yUML diagram @///image/en1400.png center 200px]]

Ecrivez les actions correspondantes dans le contrôleur par défaut :
``
def first():
    return dict()

def second():
    return dict()
``:code

Créez ensuite une vue "default/first.html" pour la première action,
et entrez :
``
{{extend 'layout.html'}}
<h1>What is your name?</h1>
<form action="second">
  <input name="visitor_name" />
  <input type="submit" />
</form>
``:code

Finalement, créez une vue "default/second.html" pour la deuxième action :
``
{{extend 'layout.html'}}
<h1>Hello {{=request.vars.visitor_name}}</h1>
``:code

``layout``:inxx
Dans les deux vues nous avons étendu la vue basique "layout.html" fournie avec web2py. La vue layout conserve un look and feel cohérent des deux pages. Le fichier du layout peut être édité et remplacé facilement, vu qu'il contient principalement du code HTML.

Si vous visitez maintenant la première page, entrez votre nom :

[[image @///image/en1500.png center 480px]]

et envoyez le formulaire, vous recevrez un remerciement :

[[image @///image/en1600.png center 480px]]

#### Postbacks
``redirect``:inxx ``URL``:inxx ``postback``:inxx

Le mécanisme de soumission de formulaire que nous avons utilisé auparavant est très commun, mais ne fait pas partie des bonnes pratiques de programmation. Toutes les entrées devraient être vérifiées, et dans l'exemple ci-dessus, la validation échouerait à la seconde action. Ainsi l'action qui exécute la validation est différente de l'action qui génère le formulaire. Ceci tend à causer des redondances dans le code.

Un meilleur patter de soumission de formulaire est d'envoyer le formulaire à la même action que celle qui l'a généré, dans notre exemple le "premier". La "première" action devrait recevoir les variables, les traites, les stocker côté serveur, et rediriger le visiteur vers la "seconde" page, qui récupère les variables. Ce mécanisme est appelé ''postback''.

[[yUML diagram @///image/en1700.png center 200px]]

Modifiez le contrôleur par défaut pour implémenter l'auto-soumission :
``
def first():
    if request.vars.visitor_name:
        session.visitor_name = request.vars.visitor_name
        redirect(URL('second'))
    return dict()

def second():
    return dict()
``:code

Modifiez ensuite la vue "default/first.html" :
``
{{extend 'layout.html'}}
What is your name?
<form>
  <input name="visitor_name" />
  <input type="submit" />
</form>
``:code

et la vue "default/second.html" a besoin de récupérer les données de la ``session`` au lieu de ``request.vars``:
``
{{extend 'layout.html'}}
<h1>Hello {{=session.visitor_name or "anonymous"}}</h1>
``:code

Du point de vue du visiteur, l'auto-soumission se comporte exactement pareil que l'implémentation précédente. Nous n'avons pas ajouté de validation encore, mais il est maintenant clair que la validation devrait être exécutée par la première action.

Cette approche est meilleure également car le nom du visiteur reste dans la session, et peut être accédé par toutes les actions et vues de l'application sans avoir à être passé explicitement.

Notez que si la "seconde" action n'est jamais appelée avant qu'un nom de visiteur ne soit défini, elle affichera "Hello anonymous" car ``session.visitor_name`` renvoie ``None``. D'une autre manière, on pourrait ajouter le code suivant dans le contrôleur (à l'intérieur de la ``second`` fonction) :

``
if not request.function=='first' and not session.visitor_name:
    redirect(URL('first'))
``:code

C'est un mécanisme ''ad hoc'' que vous pouvez utiliser pour renforcer l'autorisation sur les contrôleurs, voir le chapitre 9 pour une méthode encore plus puissante.

``FORM``:inxx ``INPUT``:inxx ``requires``:inxx ``IS_NOT_EMPTY``:inxx ``accepts``:inxx

Avez web2py nous pouvons aller encore plus loin et demander à web2py de générer le formulaire pour nous, incluant la validation. web2py fournit des assistants (FORM, INPUT, TEXTAREA et SELECT/OPTION) avec les mêmes noms que ses tags équivalents HTML. Ils peuvent être utilisés pour construire les formulaires aussi bien dans le contrôleur que dans la vue.

Par exemple, une possibilité pour réécrire la première action :
``
def first():
    form = FORM(INPUT(_name='visitor_name', requires=IS_NOT_EMPTY()),
              INPUT(_type='submit'))
    if form.process().accepted:
        session.visitor_name = form.vars.visitor_name
        redirect(URL('second'))
    return dict(form=form)
``:code

où nous indiquons que le tag FORM contient deux tags INPUT. Les attributs des tags input sont spécifiés par les arguments ayant un nom commençant par un underscore. L'argument ``requires`` n'est pas un attribut tag (car il ne démarre pas par un underscore) mais il définit un validateur pour la valeur de visitor_name.

Encore un autre moyen de créer le même formulaire :

``
def first():
    form = SQLFORM.factory(Field('visitor_name',
                                 label='what is your name?',
                                 requires=IS_NOT_EMPTY()))
    if form.process().accepted:
        session.visitor_name = form.vars.visitor_name
        redirect(URL('second'))
    return dict(form=form)
``:code

L'objet ``form`` peut être facilement sérialisé en HTML en l'embarquant dans la vue "default/first.html".
``
{{extend 'layout.html'}}
{{=form}}
``:code

La méthode ``form.process()`` applique les validateurs et retourne le formulaire. La variable ``form.accepted`` est mise à True si le formulaire a été traité et a réussi la validation. Si l'auto-soumission réussit la validation, il stocke les variables dans la session et redirige comme précédemment. Si le formulaire ne réussit pas la validation, les messages d'erreur sont insérés dans le formulaire et affichés à l'utilisateur, comme ci-dessous :

[[image @///image/en1800.png center 480px]]

Dans la section suivante, nous montrerons comment les formulaires peuvent être générés automatiquement depuis un modèle.

Dans tous nos exemples nous avons utilisé la session pour passer le nom d'utilisateur de la première action à la seconde. Nous aurions pu utiliser un mécanisme différent et passé les données comme partie de l'URL redirigée :

``
def first():
    form = SQLFORM.factory(Field('visitor_name', requires=IS_NOT_EMPTY()))
    if form.process().accepted:
        name = form.vars.visitor_name
        redirect(URL('second',vars=dict(name=name)))
    return dict(form=form)

def second():
    name = request.vars.visitor_name or redirect(URL('first'))
    return dict(name=name)
``:code

Pensez bien qu'en général ce n'est pas une bonne idée de passer des données d'une action à une autre en utilisant l'URL. Ceci rend plus difficile la sécurisation de l'application. Il est plus sûr de stocker les données dans une session.

#### Internationalisation

Votre code est susceptible d'inclure des chaînes de caractères codées en dur telles que "Quel est votre nom ?". Vous devriez être capable de personnaliser ces chaînes sans éditer le code et en particlulier insérer des traductions pour ces chaînes dans différents langages. De ce fait, si un visiteur a ses préférences de langue du navigateur définies à "Italien", web2py utilisera la traduction italienne pour les chaînes de caractères, si possible. Cette fonctinonalité de web2py est appelée "internationalisation" et est décrite plus précisément dans le chapitre suivant.

Nous observons juste ici que si vous souhaitez utiliser cette fonctionnalité vous devrez marquer les chaînes qui nécessitent une traduction. Ceci est fait grâce aux guillements dans le code tel que 

``
"What is your name?"
``:code

avec l'opérateur ``T`` :

``
T("What is your name?")
``:code


Vous pouvez aussi marquer des chaînes en dur pour traduction dans les vues. Par exemple

``
<h1>What is your name?</h1>
``:code

devient

``
<h1>{{=T("What is your name?")}}</h1>
``:code

Il est de bonne pratique de faire ceci pour toute chaîne dans le code (labels de champs, messages flashs, etc...) sauf pour les tables et les noms de champs.

Une fois les chaînes identifiées et marquées, web2py s'occupe de tout le reste. L'interface d'administration fournit également une page où vous pouvez traduire chaque chaîne dans la langue que vous souhaitez supporter.

-----------
web2py inclut un moteur de pluralisation puissant qui est décrit dans le prochain chapitre. Il est intégré avec le moteur d'internationalisation et celui de rendu markmin.
-----------

### Un blog d'images
``upload``:inxx

Maintenant, un autre exemple, nous souhaitons créer une application web qui autorise l'administrateur à poster des images et à leur donner un nom, et autorise les visiteur du site web à voir les images nommées et à envoyer des commentaires (posts).

Comme avant, depuis la page **site** dans **admin**, créez une nouvelle application appelée ``images``, et naviguez jusqu'à la page ''modifier'' :

[[image @///image/en1900.png center 480px]]

Nous commençons par créer un modèle, une représentation des données persistente dans l'application (les images à uploader, leurs noms, et les commentaires). Premièrement, vous avez besoin de créer/éditer un fichier modèle que nous appellerons, par manque d'imagination, "db.py". Nous supposons que le code suivant remplacera tout code existant dans "db.py". Les modèles et contrôleurs doivent avoir une extension ``.py`` puisque c'est du code Python. Si l'extension n'est pas précisée, elle est ajoutée par web2py. Les vues, elles, ont une extension ``.html`` puisqu'elles contiennent principalement du code HTML.

Modifiez le fichier "db.py" en cliquant sur le bouton "modifier" correspondant :

[[image @///image/en2000.png center 480px]]

et saisissez ceci :

``IS_EMAIL``:inxx ``IS_NOT_EMPTY``:inxx ``IS_IN_DB``:inxx
``
db = DAL("sqlite://storage.sqlite")

db.define_table('image',
   Field('title', unique=True),
   Field('file', 'upload'),
   format = '%(title)s')

db.define_table('post',
   Field('image_id', 'reference image'),
   Field('author'),
   Field('email'),
   Field('body', 'text'))

db.image.title.requires = IS_NOT_IN_DB(db, db.image.title)
db.post.image_id.requires = IS_IN_DB(db, db.image.id, '%(title)s')
db.post.author.requires = IS_NOT_EMPTY()
db.post.email.requires = IS_EMAIL()
db.post.body.requires = IS_NOT_EMPTY()

db.post.image_id.writable = db.post.image_id.readable = False
``:code

Analysons ceci ligne par ligne.

La ligne 1 définit une variable globale appelée ``db`` qui représente la connexion à la base de données. Dans ce cas, c'est une connexion à une base SQLite qui est stockée dans le fichier "applications/images/databases/storage.sqlite". Lorsque l'on utilise SQLite, si le fichier de base de données n'existe pas, il est créé. Vous pouvez changer le nom de ce fichier aussi bien que le nom de la variable globale ``db``, mais il est pratique de leur donner le même nom pour s'en souvenir plus facilement.

Les lignes 3 à 6 définissent uen table "image". ``define_table`` est une méthode de l'objet ``db``. Le premier argument, "image", est le nom de la table que nous définissons. Les autres arguments sont les champs appartenant à cette table. Cette table a un champ appelé "title", un champ appelé "file", et un dernier appelé "id" qui sert de clé primaire ("id" n'est pas déclaré explicitement car les tables ont un champ id par défaut). Le champ "title" est une chaîne, et le champ "file" est de type "upload". "upload" est un type spécial de champ utilisé par la couche d'abstraction à la base de données web2py (DAL) pour stocker les noms des fichiers uploadés. web2py sait comment uploader des fichiers (via streaming s'ils sont gros), les renommer proprement, et les stocker.

Lorsqu'une table est définie, web2py effectue l'une de ces actions possibles :
- si la table n'existe pas, la table est créée;
- si la table existe et ne correspond pas à la définitions, la table est modifiée en fonction, et si un champ a un type différent, web2py essaie de convertir le contenu;
- si la table existe et correspond à la définition, web2py ne change rien.

Ce comportement est appelé "migration". Dans web2py les migrations sont automatiques, mais peuvent être désactivées pour chaque table en passant ``migrate=False`` comme dernier argument de ``define_table``.

La ligne 6 définit un format de chaîne pour la table. Il détermine la manière dont un enregistrement devrait être représenté comme chaîne. Notez que l'argument ``format`` peut également être une fonction qui prend un enregistrement et renvoie une chaîne. Par exemple :

``
format=lambda row: row.title
``:code

Les lignes 8 à 12 définissent une autre table appelée "post".
Un post a un "author", un "email" (nous souhaitons stocker l'adresse mail de l'auteur du post), un "body" de type "texte" (nous souhaitons l'utiliser pour stocker le commentaire actuel posté par l'auteur), et un champ "image_id" de type référence qui pointe sur ``db.image`` via le champ "id".

A la ligne 14, ``db.image.title`` représente le champ "title" de la table "image". L'attribut ``requires`` vous autorise à définir les pré-requis/contrainte qui seront pris en charge par les formulaires web2py. L'unicité de "title" est requise ici :

``IS_NOT_IN_DB(db, db.image.title)``:code

''Notez que ceci est optionel car il est automatiquement défini par ``Field('title', unique=True)``''.

Les objets représentant ces contraintes sont appelés validateurs. Plusieurs validateurs peuvent être groupés dans une liste. Les validateurs sont exécutés dans l'ordre où ils apparaissent.
``IS_NOT_IN_DB(a, b)`` est un validateur spécial qui vérifie que la valeur du champ ``b`` pour un nouvel enregistrement n'est pas déjà dans ``a``.

La ligne 15 requiert que le champ "image_id" de la table "post" soit dans ``db.image.id``. Côté base de données, nous l'avons déjà défini quand nous avons défini la table "post".
Maintenant nous allons dire explicitement au modèle que la condition devrait être forcée par web2py, également au niveau du traitement du formulaire lorsqu'un nouveau commentaire est posté, afin que les valeurs invalides ne se propagent pas depuis les entrées de formulaire vers la base de données. Nous allons également demander que l' "image_id" soit représenté par le "title", ``'%(title)s'``, de l'enregistrement correspondant.

La ligne 20 indique que le champ "image_id" de la table "post" ne devrait pas apparaître dans les formulaires, ``writable=False`` et même dans ceux en lecture seule, ``readable=False``.

La signification des validateurs dans les lignes 17-18 devraient être évidents.

``format``:inxx
Notice that the validator
``
db.post.image_id.requires = IS_IN_DB(db, db.image.id, '%(title)s')
``:code

can be omitted (and would be automatic) if we specify a format for referenced table:
``
db.define_table('image', ..., format='%(title)s')
``:code

where the format can be a string or a function that takes a record and returns a string.

``appadmin``:inxx
Once a model is defined, if there are no errors, web2py creates an application administration interface to manage the database. You access it via the "database administration" link in the ''edit'' page or directly:
``
http://127.0.0.1:8000/images/appadmin
``:code

Here is a screenshot of the **appadmin** interface:

[[image @///image/en2100.png center 480px]]

This interface is coded in the controller called "appadmin.py" and the corresponding view "appadmin.html". From now on, we will refer to this interface simply as **appadmin**. It allows the administrator to insert new database records, edit and delete existing records, browse tables, and perform database joins.

The first time **appadmin** is accessed, the model is executed and the tables are created. The web2py DAL translates Python code into SQL statements that are specific to the selected database back-end (SQLite in this example). You can see the generated SQL from the ''edit'' page by clicking on the "sql.log" link under "models". Notice that the link is not present until the tables have been created.

[[image @///image/en2200.png center 480px]]

If you were to edit the model and access **appadmin** again, web2py would generate SQL to alter the existing tables. The generated SQL is logged into "sql.log".

Now go back to **appadmin** and try to insert a new image record:

[[image @///image/en2300.png center 480px]]

web2py has translated the ``db.image.file`` "upload" field into an upload form for the file. When the form is submitted and an image file is uploaded, the file is renamed in a secure way that preserves the extension, it is saved with the new name under the application "uploads" folder, and the new name is stored in the ``db.image.file`` field. This process is designed to prevent directory traversal attacks.

Notice that each field type is rendered by a ''widget''. Default widgets can be overridden.

When you click on a table name in **appadmin**, web2py performs a select of all records on the current table, identified by the DAL query
``
db.image.id > 0
``:code

and renders the result.

[[image @///image/en2400.png center 480px]]

You can select a different set of records by editing the DAL query and pressing [Submit].

To edit or delete a single record, click on the record id number.

Because of the ``IS_IN_DB`` validator, the reference field "image_id" is rendered by a drop-down menu. The items in the drop-down are stored as keys (``db.image.id``), but are represented by their ``db.image.title``, as specified by the validator.

Validators are powerful objects that know how to represent fields, filter field values, generate errors, and format values extracted from the field.

The following figure shows what happens when you submit a form that does not pass validation:

[[image @///image/en2500.png center 480px]]

The same forms that are automatically generated by **appadmin** can also be generated programmatically via the ``SQLFORM`` helper and embedded in user applications. These forms are CSS-friendly, and can be customized.

Every application has its own **appadmin**; therefore, **appadmin** itself can be modified without affecting other applications.

So far, the application knows how to store data, and we have seen how to access the database via **appadmin**. Access to **appadmin** is restricted to the administrator, and it is not intended as a production web interface for the application; hence the next part of this walk-through. Specifically we want to create:
- An "index" page that lists all available images sorted by title and links to detail pages for the images.
- A "show/[id]" page that shows the visitor the requested image and allows the visitor to view and post comments.
- A "download/[name]" action to download uploaded images.

This is represented schematically here:

[[yUML diagram @///image/en2600.png center 480px]]

Go back to the ''edit'' page and edit the "default.py" controller, replacing its contents with the following:

``select``:inxx
``
def index():
    images = db().select(db.image.ALL, orderby=db.image.title)
    return dict(images=images)
``:code

This action returns a dictionary. The keys of the items in the dictionary are interpreted as variables passed to the view associated to the action. When developing, if there is no view, the action is rendered by the "generic.html" view that is provided with every web2py application.

The index action performs a select of all fields (``db.image.ALL``) from table image, ordered by ``db.image.title``. The result of the select is a ``Rows`` object containing the records. Assign it to a local variable called ``images`` returned by the action to the view. ``images`` is iterable and its elements are the selected rows. For each row the columns can be accessed as dictionaries:
``images[0]['title']`` or equivalently as ``images[0].title``.

If you do not write a view, the dictionary is rendered by "views/generic.html" and a call to the index action would look like this:

[[image @///image/en2700.png center 480px]]

You have not created a view for this action yet, so web2py renders the set of records in plain tabular form.

Proceed to create a view for the index action. Return to admin, edit "default/index.html" and replace its content with the following:
``
{{extend 'layout.html'}}
<h1>Current Images</h1>
<ul>
{{for image in images:}}
{{=LI(A(image.title, _href=URL("show", args=image.id)))}}
{{pass}}
</ul>
``:code

The first thing to notice is that a view is pure HTML with special {{...}} tags. The code embedded in {{...}} is pure Python code with one caveat: indentation is irrelevant. Blocks of code start with lines ending in colon (:) and end in lines beginning with the keyword ``pass``. In some cases the end of a block is obvious from context and the use of ``pass`` is not required.

Lines 5-7 loop over the image rows and for each row image display:
``
LI(A(image.title, _href=URL('show', args=image.id))
``:code

This is a ``<li>...</li>`` tag that contains an ``<a href="...">...</a>`` tag which contains the ``image.title``. The value of the hypertext reference (href attribute) is:
``
URL('show', args=image.id)
``:code

i.e., the URL within the same application and controller as the current request that calls the function called "show", passing a single argument to the function, ``args=image.id``.
``LI``, ``A``, etc. are web2py helpers that map to the corresponding HTML tags. Their unnamed arguments are interpreted as objects to be serialized and inserted in the tag's innerHTML. Named arguments starting with an underscore (for example ``_href``) are interpreted as tag attributes but without the underscore. For example ``_href`` is the ``href`` attribute, ``_class`` is the ``class`` attribute, etc.

As an example, the following statement:
``
{{=LI(A('something', _href=URL('show', args=123))}}
``:code

is rendered as:
``
<li><a href="/images/default/show/123">something</a></li>
``:code

A handful of helpers (``INPUT``, ``TEXTAREA``, ``OPTION`` and ``SELECT``) also support some special named attributes not starting with underscore (``value``, and ``requires``). They are important for building custom forms and will be discussed later.

Go back to the ''edit'' page. It now indicates that "default.py exposes index". By clicking on "index", you can visit the newly created page:
``
http://127.0.0.1:8000/images/default/index
``:code

which looks like:

[[image @///image/en2800.png center 480px]]

If you click on the image name link, you are directed to:
``
http://127.0.0.1:8000/images/default/show/1
``:code

and this results in an error, since you have not yet created an action called "show" in controller "default.py".

Let's edit the "default.py" controller and replace its content with:

``SQLFORM``:inxx ``accepts``:inxx ``response.flash``:inxx ``request.args``:inxx
``response.download``:inxx
``
def index():
    images = db().select(db.image.ALL, orderby=db.image.title)
    return dict(images=images)

def show():
    image = db.image(request.args(0,cast=int)) or redirect(URL('index'))
    db.post.image_id.default = image.id
    form = SQLFORM(db.post)
    if form.process().accepted:
        response.flash = 'your comment is posted'
    comments = db(db.post.image_id==image.id).select()
    return dict(image=image, comments=comments, form=form)

def download():
    return response.download(request, db)
``:code

The controller contains two actions: "show" and "download".
The "show" action selects the image with the ``id`` parsed from the request args and all comments related to the image. "show" then passes everything to the view "default/show.html".

The image id referenced by:
``
URL('show', args=image.id)
``:code

in "default/index.html", can be accessed as:

``request.args(0,cast=int)``

from the "show" action. The ``cast=int`` argument is optional but very important. It attempts to cast the string value passed in the PATH_INFO into an int. On failure it raises a proper exception instead of causing a ticket. One can also specify a redirect in case of failure to cast:

``request.args(0,cast=int,otherwise=URL('error'))``

Moreover ``db.image(...)`` is a shortcut for

``
db(db.image.id==...).select().first()
``:code

The "download" action expects a filename in ``request.args(0)``, builds a path to the location where that file is supposed to be, and sends it back to the client. If the file is too large, it streams the file without incurring any memory overhead.

Notice the following statements:
- Line 6 sets the value for the reference field, which is not part of the input form because it is not in the list of fields specified above.
- Line 7 creates an insert form SQLFORM for the ``db.post`` table using only the specified fields.
- Line 8 processes the submitted form (the submitted form variables are in ``request.vars``) within the current session (the session is used to prevent double submissions, and to enforce navigation). If the submitted form variables are validated, the new comment is inserted in the ``db.post`` table; otherwise the form is modified to include error messages (for example, if the author's email address is invalid). This is all done in line 9!.
- Line 9 is only executed if the form is accepted, after the record is inserted into the database table. ``response.flash`` is a web2py variable that is displayed in the views and used to notify the visitor that something happened.
- Line 10 selects all comments that reference the current image.

-------
The "download" action is already defined in the "default.py" controller of the scaffolding application.
-------

The "download" action does not return a dictionary, so it does not need a view. The "show" action, though, should have a view, so return to **admin** and create a new view called "default/show.html".

Edit this new file and replace its content with the following:
``
{{extend 'layout.html'}}
<h1>Image: {{=image.title}}</h1>
<center>
<img width="200px"
     src="{{=URL('download', args=image.file)}}" />
</center>
{{if len(comments):}}
  <h2>Comments</h2><br /><p>
  {{for post in comments:}}
    <p>{{=post.author}} says <i>{{=post.body}}</i></p>
  {{pass}}</p>
{{else:}}
  <h2>No comments posted yet</h2>
{{pass}}
<h2>Post a comment</h2>
{{=form}}
``:code

This view displays the **image.file** by calling the "download" action inside an ``<img ... />`` tag.
If there are comments, it loops over them and displays each one.

Here is how everything will appear to a visitor.

[[image @///image/en2900.png center 480px]]

When a visitor submits a comment via this page, the comment is stored in the database and appended at the bottom of the page.

#### Adding authentication

The web2py API for Role-Based Access Control is quite sophisticated, but for now we will limit ourselves to restricting access to the show action to authenticated users, deferring a more detailed discussion to Chapter 9.

To limit access to authenticated users, we need to complete three steps. In a model, for example "db.py", we need to add:
``
from gluon.tools import Auth
auth = Auth(db)
auth.define_tables(username=True)
``:code

In our controller, we need to add one action:
``
def user():
    return dict(form=auth())
``:code

This is sufficient to enable login, register, logout, etc. pages. The default layout will also show options to the corresponding pages in the top right corner.

[[image @///image/en3000.png center 300px]]

We can now decorate the functions that we want to restrict, for example:
``
@auth.requires_login()
def show():
    ...
``:code

Any attempt to access
``
http://127.0.0.1:8000/images/default/show/[image_id]
``:code

will require login. If the user is not logged it, the user will be redirected to
``
http://127.0.0.1:8000/images/default/user/login
``:code

[[image @///image/en3100.png center 480px]]

The ``user`` function also exposes, among others, the following actions:
``
http://127.0.0.1:8000/images/default/user/logout
http://127.0.0.1:8000/images/default/user/register
http://127.0.0.1:8000/images/default/user/profile
http://127.0.0.1:8000/images/default/user/change_password
http://127.0.0.1:8000/images/default/user/request_reset_password
http://127.0.0.1:8000/images/default/user/retrieve_username
http://127.0.0.1:8000/images/default/user/retrieve_password
http://127.0.0.1:8000/images/default/user/verify_email
http://127.0.0.1:8000/images/default/user/impersonate
http://127.0.0.1:8000/images/default/user/not_authorized
``:code

Now, a first-time user needs to register in order to be able to log in and read or post comments.

-------
Both the ``auth`` object and the ``user`` function are already defined in the scaffolding application. The ``auth`` object is highly customizable and can deal with email verification, registration approvals, CAPTCHA, and alternate login methods via plugins.
-------

#### Adding grids

We can improve this further using the ``SQLFORM.grid`` and ``SQLFORM.smartgrid`` gadgets to create a management interface for our application:

``
@auth.requires_membership('manager')
def manage():
    grid = SQLFORM.smartgrid(db.image,linked_tables=['post'])
    return dict(grid=grid)
``:code

with associated "views/default/manage.html"

``
{{extend 'layout.html'}}
<h2>Management Interface</h2>
{{=grid}}
``

Using appadmin create a group "manager" and make some users members of the group. They will be able to access

``
http://127.0.0.1:8000/images/default/manage
``

and browse, search:

[[image @///image/en3200.png center 480px]]

create, update and delete images and their comments:

[[image @///image/en3300.png center 480px]]

#### Configuring the layout

You can configure the default layout by editing "views/layout.html" but you can also configure it without editing the HTML. In fact, the "static/base.css" stylesheet is well documented and described in Chapter 5. You can change color, columns, size, borders and background without editing the HTML. If you want to edit the menu, the title or the subtitle, you can do so in any model file. The scaffolding app, sets default values of these parameters in the file "models/menu.py":

``
response.title = request.application
response.subtitle = 'customize me!'
response.meta.author = 'you'
response.meta.description = 'describe your app'
response.meta.keywords = 'bla bla bla'
response.menu = [ [ 'Index', False, URL('index') ] ]
``:code

### A simple wiki
``wiki``:inxx ``RSS``:inxx ``Ajax``:inxx ``XMLRPC``:inxx

In this section, we build a simple wiki from scratch using only low level APIs (as opposed to using the built-in wiki capabilities of web2py demonstrated in the next section). The visitor will be able to create pages, search them (by title), and edit them. The visitor will also be able to post comments (exactly as in the previous applications), and also post documents (as attachments to the pages) and link them from the pages. As a convention, we adopt the Markmin syntax for our wiki syntax. We will also implement a search page with Ajax, an RSS feed for the pages, and a handler to search the pages via XML-RPC``xmlrpc``:cite . The following diagram lists the actions that we need to implement and the links we intend to build among them.

[[yUML diagram @///image/en3400.png center 200px]]

Start by creating a new scaffolding app, naming it "mywiki".

The model must contain three tables: page, comment, and document. Both comment and document reference page because they belong to page. A document contains a file field of type upload as in the previous images application.

Here is the complete model:
``
db = DAL('sqlite://storage.sqlite')

from gluon.tools import *
auth = Auth(db)
auth.define_tables()
crud = Crud(db)

db.define_table('page',
    Field('title'),
    Field('body', 'text'),
    Field('created_on', 'datetime', default=request.now),
    Field('created_by', 'reference auth_user', default=auth.user_id),
    format='%(title)s')

db.define_table('post',
    Field('page_id', 'reference page'),
    Field('body', 'text'),
    Field('created_on', 'datetime', default=request.now),
    Field('created_by', 'reference auth_user', default=auth.user_id))

db.define_table('document',
    Field('page_id', 'reference page'),
    Field('name'),
    Field('file', 'upload'),
    Field('created_on', 'datetime', default=request.now),
    Field('created_by', 'reference auth_user', default=auth.user_id),
    format='%(name)s')

db.page.title.requires = IS_NOT_IN_DB(db, 'page.title')
db.page.body.requires = IS_NOT_EMPTY()
db.page.created_by.readable = db.page.created_by.writable = False
db.page.created_on.readable = db.page.created_on.writable = False

db.post.body.requires = IS_NOT_EMPTY()
db.post.page_id.readable = db.post.page_id.writable = False
db.post.created_by.readable = db.post.created_by.writable = False
db.post.created_on.readable = db.post.created_on.writable = False

db.document.name.requires = IS_NOT_IN_DB(db, 'document.name')
db.document.page_id.readable = db.document.page_id.writable = False
db.document.created_by.readable = db.document.created_by.writable = False
db.document.created_on.readable = db.document.created_on.writable = False
``:code

Edit the controller "default.py" and create the following actions:
- index: list all wiki pages
- create: add a new wiki page
- show: show a wiki page and its comments, and add new comments
- edit: edit an existing page
- documents: manage the documents attached to a page
- download: download a document (as in the images example)
- search: display a search box and, via an Ajax callback, return all matching titles as the visitor types
- callback: the Ajax callback function. It returns the HTML that gets embedded in the search page while the visitor types.

Here is the "default.py" controller:
``
def index():
     """ this controller returns a dictionary rendered by the view
         it lists all wiki pages
     >>> index().has_key('pages')
     True
     """
     pages = db().select(db.page.id,db.page.title,orderby=db.page.title)
     return dict(pages=pages)

@auth.requires_login()
def create():
     """creates a new empty wiki page"""
     form = SQLFORM(db.page).process(next=URL('index'))
     return dict(form=form)

def show():
     """shows a wiki page"""
     this_page = db.page(request.args(0,cast=int)) or redirect(URL('index'))
     db.post.page_id.default = this_page.id
     form = SQLFORM(db.post).process() if auth.user else None
     pagecomments = db(db.post.page_id==this_page.id).select()
     return dict(page=this_page, comments=pagecomments, form=form)

@auth.requires_login()
def edit():
     """edit an existing wiki page"""
     this_page = db.page(request.args(0,cast=int)) or redirect(URL('index'))
     form = SQLFORM(db.page, this_page).process(
         next = URL('show',args=request.args))
     return dict(form=form)

@auth.requires_login()
def documents():
     """browser, edit all documents attached to a certain page"""
     page = db.page(request.args(0,cast=int)) or redirect(URL('index'))
     db.document.page_id.default = page.id
     db.document.page_id.writable = False
     grid = SQLFORM.grid(db.document.page_id==page.id,args=[page.id])
     return dict(page=page, grid=grid)

def user():
     return dict(form=auth())

def download():
     """allows downloading of documents"""
     return response.download(request, db)

def search():
     """an ajax wiki search page"""
     return dict(form=FORM(INPUT(_id='keyword',_name='keyword',
              _onkeyup="ajax('callback', ['keyword'], 'target');")),
              target_div=DIV(_id='target'))

def callback():
     """an ajax callback that returns a <ul> of links to wiki pages"""
     query = db.page.title.contains(request.vars.keyword)
     pages = db(query).select(orderby=db.page.title)
     links = [A(p.title, _href=URL('show',args=p.id)) for p in pages]
     return UL(*links)
``:code


Lines 2-6 constitute a comment for the index action. Lines 4-5 inside the comment are interpreted by python as test code (doctest). Tests can be run via the admin interface. In this case the tests verify that the index action runs without errors.

Lines 18, 27, and 35 try to fetch a ``page`` record with the id in
``request.args(0)``.

Lines 13, 20 define and process create forms for a new page and a new comment and

Line 28 defines and processes an update form for a wiki page.

Line 38 creates a ``grid`` object that allows to view, add and update the comments linked to a page.

Some magic happens in line 51. The ``onkeyup`` attribute of the INPUT tag "keyword" is set. Every time the visitor releases a key, the JavaScript code inside the ``onkeyup`` attribute is executed, client-side. Here is the JavaScript code:
``
ajax('callback', ['keyword'], 'target');
``:code
``ajax`` is a JavaScript function defined in the file "web2py.js" which is included by the default "layout.html". It takes three parameters: the URL of the action that performs the synchronous callback, a list of the IDs of variables to be sent to the callback (["keyword"]), and the ID where the response has to be inserted ("target").

As soon as you type something in the search box and release a key, the client calls the server and sends the content of the 'keyword' field, and, when the sever responds, the response is embedded in the page itself as the innerHTML of the 'target' tag.

The 'target' tag is a DIV defined in line 52. It could have been defined in the view as well.

Here is the code for the view "default/create.html":
``
{{extend 'layout.html'}}
<h1>Create new wiki page</h1>
{{=form}}
``:code

Assuming you are registered and logged in, if you visit the **create** page, you see the following:

[[image @///image/en3500.png center 480px]]

Here is the code for the view "default/index.html":
``
{{extend 'layout.html'}}
<h1>Available wiki pages</h1>
[ {{=A('search', _href=URL('search'))}} ]<br />
<ul>{{for page in pages:}}
     {{=LI(A(page.title, _href=URL('show', args=page.id)))}}
{{pass}}</ul>
[ {{=A('create page', _href=URL('create'))}} ]
``:code

It generates the following page:

[[image @///image/en3600.png center 480px]]

Here is the code for the view "default/show.html":

``markdown``:inxx ``MARKMIN``:inxx
``
{{extend 'layout.html'}}
<h1>{{=page.title}}</h1>
[ {{=A('edit', _href=URL('edit', args=request.args))}}
| {{=A('documents', _href=URL('documents', args=request.args))}} ]<br />
{{=MARKMIN(page.body)}}
<h2>Comments</h2>
{{for post in comments:}}
  <p>{{=db.auth_user[post.created_by].first_name}} on {{=post.created_on}}
     says <i>{{=post.body}}</i></p>
{{pass}}
<h2>Post a comment</h2>
{{=form}}
``:code

If you wish to use markdown syntax instead of markmin syntax:

``
from gluon.contrib.markdown import WIKI as MARKDOWN
``:code

and use ``MARKDOWN`` instead of the ``MARKMIN`` helper.
Alternatively, you can choose to accept raw HTML instead of markmin syntax. In this case you would replace:
``
{{=MARKMIN(page.body)}}
``:code

with:
``
{{=XML(page.body)}}
``:code

``sanitize``:inxx
(so that the XML does not get escaped, which web2py normally does by default for security reasons).

This can be done better with:
``
{{=XML(page.body, sanitize=True)}}
``:code

By setting ``sanitize=True``, you tell web2py to escape unsafe XML tags such as "<script>", and thus prevent XSS vulnerabilities.

Now if, from the index page, you click on a page title, you can see the page that you have created:

[[image @///image/en3700.png center 480px]]

Here is the code for the view "default/edit.html":
``
{{extend 'layout.html'}}
<h1>Edit wiki page</h1>
[ {{=A('show', _href=URL('show', args=request.args))}} ]<br />
{{=form}}
``:code

It generates a page that looks almost identical to the create page.

Here is the code for the view "default/documents.html":
``
{{extend 'layout.html'}}
<h1>Documents for page: {{=page.title}}</h1>
[ {{=A('show', _href=URL('show', args=request.args))}} ]<br />
<h2>Documents</h2>
{{=grid}}
``:code

If, from the "show" page, you click on documents, you can now manage the documents attached to the page.

[[image @///image/en3800.png center 480px]]

Finally here is the code for the view "default/search.html":
``
{{extend 'layout.html'}}
<h1>Search wiki pages</h1>
[ {{=A('listall', _href=URL('index'))}}]<br />
{{=form}}<br />{{=target_div}}
``:code

which generates the following Ajax search form:

[[image @///image/en3900.png center 480px]]

You can also try to call the callback action directly by visiting, for example, the following URL:
``
http://127.0.0.1:8000/mywiki/default/callback?keyword=wiki
``:code

If you look at the page source you see the HTML returned by the callback:
``
<ul><li><a href="/mywiki/default/show/4">I made a Wiki</a></li></ul>
``:code

``rss``:inxx
Generating an RSS feed of your wiki pages using web2py is easy because web2py includes ``gluon.contrib.rss2``. Just append the following action to the default controller:
``
def news():
    """generates rss feed from the wiki pages"""
    response.generic_patterns = ['.rss']
    pages = db().select(db.page.ALL, orderby=db.page.title)
    return dict(
       title = 'mywiki rss feed',
       link = 'http://127.0.0.1:8000/mywiki/default/index',
       description = 'mywiki news',
       created_on = request.now,
       items = [
          dict(title = row.title,
               link = URL('show', args=row.id, scheme=True, 
	                  host=True, extension=False),
               description = MARKMIN(row.body).xml(),
               created_on = row.created_on
               ) for row in pages])
``:code

and when you visit the page
``
http://127.0.0.1:8000/mywiki/default/news.rss
``:code

you see the feed (the exact output depends on the feed reader). Notice that the dict is automatically converted to RSS, thanks to the .rss extension in the URL.

[[image @///image/en4000.png center 480px]]

web2py also includes feedparser to read third-party feeds.

Notice that the line:

``
response.generic_patterns = ['.rss']
``:code

instructs web2py to use generic views (in our case "views/generic.rss") when the URL ends in the glob pattern ".rss". By default generic views are only allowed from localhost for development purposes.

``XMLRPC``:inxx
Finally, let's add an XML-RPC handler that allows searching the wiki programmatically:
``
service = Service()

@service.xmlrpc
def find_by(keyword):
     """finds pages that contain keyword for XML-RPC"""
     return db(db.page.title.contains(keyword)).select().as_list()

def call():
    """exposes all registered services, including XML-RPC"""
    return service()
``:code

Here, the handler action simply publishes (via XML-RPC), the functions specified in the list. In this case, ``find_by``. ``find_by`` is not an action (because it takes an argument). It queries the database with ``.select()`` and then extracts the records as a list with ``.response`` and returns the list.

Here is an example of how to access the XML-RPC handler from an external
Python program.
``
>>> import xmlrpclib
>>> server = xmlrpclib.ServerProxy(
    'http://127.0.0.1:8000/mywiki/default/call/xmlrpc')
>>> for item in server.find_by('wiki'):
        print item['created_on'], item['title']
``:code

The handler can be accessed from many other programming languages that understand XML-RPC, including C, C++, C# and Java.

#### On ``date``, ``datetime`` and ``time`` format

There are three different representations for each of the field types ``date``, ``datetime`` and ``time``:
- the database representation
- the internal web2py representation
- the string representation in forms and tables

The database representation is an internal issue and does not affect the code. Internally, at the web2py level, they are stored as ``datetime.date``, ``datetime.datetime`` and ``datetime.time`` object respectively and they can be manipulated as such:

``
for page in db(db.page).select():
    print page.title, page.day, page.month, page.year
``

When dates are converted to strings in forms they are converted using the ISO representation
``
%Y-%m-%d %H:%M:%S
``

yet this representation is internationalized and you can use the admin translation page to change the format to an alternate one. For example:

``
%m/%d/%Y %H:%M:%S
``

Mind that by default English is not translated because web2py assumes the applications are written in English. If you want internationalization to work for English you need to create the translation file (using admin) and you need to declare that the application's current language is something other than english, for example:
``
T.current_languages = ['null']
``

### The built-in web2py wiki

Now you can forget the code we have built-in the previous section (not what you have learned about web2py APIs, just the code of the specific example) as we are going to provide an example of the built-in web2py wiki.

In fact, web2py comes with wiki capabilities including media attachments, tags, tag cloud, page permissions, and support for oembed ``oembed``:cite and components (chapter 14). This wiki can be used with any web2py application.

------
Notice the API of the built-in wiki is still considered experimental and small changes are still possible.
------

Here we assume we are starting from scratch from a simple clone of the "welcome" application called "wikidemo". Edit the controller and replace the "index" action with

``
def index(): return auth.wiki()
``:code

Done! You have a fully working wiki. At this point no page has been created and in order to create pages you must be logged-in and you must be member of a group called "wiki_editor" or "wiki_author". If you are logged-in as administrator the "wiki_editor" group is created automatically and you are made a member. The difference between editors and authors is that the editors can create pages, edit and delete any page, while the authors can create pages (with some optional restrictions) and can only edit/delete the pages they have created.

The ``auth.wiki()`` function returns in a dictionary with a key ``content`` which is understood by the scaffolding "views/default/index.html". You can make your own view for this action:

``
{{extend 'layout.html'}}
{{=content}}
``:code

and add extra HTML or code as needed. You do not have to use the "index" action to expose the wiki. You can use an action with a different name.

To try the wiki, simply login into admin, visit the page

``
http://127.0.0.1:8000/wikidemo/default/index
``

Then choose a slug (in the publishing business, a slug is a short name given to an article that is in production) and you will be redirected to an empty page where you can edit the content using MARKMIN wiki syntax. A new menu item called "[wiki]" will allow you to create, search, and edit pages. Wiki pages have URLs like:

``
http://127.0.0.1:8000/wikidemo/default/index/[slug]
``

Service pages have names which start by underscore:

``
http://127.0.0.1:8000/wikidemo/default/index/_create
http://127.0.0.1:8000/wikidemo/default/index/_search
http://127.0.0.1:8000/wikidemo/default/index/_could
http://127.0.0.1:8000/wikidemo/default/index/_recent
http://127.0.0.1:8000/wikidemo/default/index/_edit/...
http://127.0.0.1:8000/wikidemo/default/index/_editmedia/...
http://127.0.0.1:8000/wikidemo/default/index/_preview/...
``

Try to create more pages such as "index", "aboutus", and "contactus".
Try to edit them.


The ``wiki`` method has the following signature:

``
def wiki(self, slug=None, env=None, render='markmin',
         manage_permissions=False, force_prefix='',
         restrict_search=False, resolve=True,
         extra=None, menugroups=None)
``:code

It takes the following arguments:

- ``render`` which defaults to ``'markmin'`` but can be set equal to ``'html'``. It determines the syntax of the wiki. We will discuss the markmin wiki markup later. If you change it to HTML you can use a wysiwyg javascript editor such as TinyMCE or NicEdit.
- ``manage_permissions``. This is set to ``False`` by default and only recognizes permissions for "wiki_editor" and "wiki_author". If you change it to ``True`` the create/edit page will give the option to specify by name the group(s) whose members have permission to read and edit the page. There is a group "everybody" which includes all users.

- ``force_prefix``. If set to something like ``'%(id)s-'`` it will restrict authors (not editors) to creating pages with a prefix like "[user id]-[page name]". The prefix can contain the id ("%(id)s") or the username ("%(username)s") or any other field from the auth_user table, as long as the corresponding column contains a valid string that would pass URL validation.
- ``restrict_search``. This defaults to ``False`` and any logged-in user can search all wiki pages (but not necessary read or edit them). If set to ``True``, authors can search only their own pages, editors can search everything, other users cannot search anything.
- ``menu_groups``. This defaults to ``None`` and it indicates that wiki management menu (search, create, edit, etc.) is always displayed. You can set it to a list of group names whose members only can see this menu, for example ``['wiki_editor','wiki_author']``. Notice that even if the menu is exposed to everybody that does not mean everybody is allowed to perform actions listed in the menu since they are regulated by the access control system.

The ``wiki`` method has some additional parameters which will be explained later: ``slug``, ``env``, and ``extra``.



#### MARKMIN basics

The MARKMIN syntax allows you to markup **bold** text using ``**bold**``, ''italic'' text with ``''italic''``, and ``code`` text should be delimited by double inverted quotes. Titles must be prefixed by a #, sections by ##, and sub-sections by ###. Use a minus(-) to prefix an un-ordered item and plus(+) to prefix an ordered item. URLs are automatically converted into links. Here is an example of markmin text:

``
# This is a title
## this is a section title
### this is a subsection title

Text can be **bold**, ''italic'', !`!!`!code!`!!`! etc.
Learn more at:

http://web2py.com
``:code


You can use the ``extra`` parameter of ``auth.wiki`` to pass extra rendering rules to the MARKMIN helper.

You can find more information about the MARKMIN syntax in chapter 5.

``auth.wiki`` is more powerful than the barebones MARKMIN helpers, supporting oembed and components.

You can use the ``env`` parameter of ``auth.wiki`` to expose functions to your wiki.
For example:

``
auth.wiki(env=dict(join=lambda a,b,c:"%s-%s-%s" % (a,b,c)))
``

allows you to use the markup syntax:

``
@(join:1,2,3)
``


This calls the join function passed as extra with parameters ``a,b,c=1,2,3`` and will be rendered as ``1-2-3``.

#### Oembed protocol

You can type in (or cut-and-paste) any URL into a wiki page and it is rendered as a link to the URL. There are exceptions:

- If the URL has an image extension, the link is embedded as an image, ``<img/>``.
- If the URL has an audio extension, the link is embedded as HTML5 audio ``<audio/>``.
- If the URL has a video extension, the link is embedded as HTML5 video ``<video/>``.
- If the URL has a MS Office or PDF extension, Google Doc Viewer is embedded, showing the content of the document (only works for public documents).
- If the URL points to a YouTube page, a Vimeo page, or a Flickr page, web2py contacts the corresponding web service and queries it about the proper way to embed the content. This is done using the ``oembed`` protocol.

Here is a complete list of supported formats:
``
Image (.PNG, .GIF, .JPG, .JPEG)
Audio (.WAV, .OGG, .MP3)
Video (.MOV, .MPE, .MP4, .MPG, .MPG2, .MPEG, .MPEG4, .MOVIE)
``

Supported via Google Doc Viewer:

``
Microsoft Excel (.XLS and .XLSX)
Microsoft PowerPoint 2007 / 2010 (.PPTX)
Apple Pages (.PAGES)
Adobe PDF (.PDF)
Adobe Illustrator (.AI)
Adobe Photoshop (.PSD)
Autodesk AutoCad (.DXF)
Scalable Vector Graphics (.SVG)
PostScript (.EPS, .PS)
TrueType (.TTF)
xml Paper Specification (.XPS)
``:code

Supported by oembed:

``
flickr.com
youtube.com
hulu.com
vimeo.com
slideshare.net
qik.com
polleverywhere.com
wordpress.com
revision3.com
viddler.com
``:code

This is implemented in the web2py file ``gluon.contrib.autolinks`` and specifically in the function ``expand_one``. You can extend oembed support by registering more services. This is done by appending an entry to the ``EMBED_MAPS`` list:

``
from gluon.contrib.autolinks import EMBED_MAPS
EMBED_MAPS.append((re.compile('http://vimeo.com/\S*'),
                   'http://vimeo.com/api/oembed.json'))
``:code

#### Referencing wiki content

If you create a wiki page with slug "contactus" you can refer to this page as

``
\@////contactus
``:code

Here @````//// stands for

``
\@/app/controller/function/
``:code

but "app", "controller", and "function" are omitted thus assuming default.

Similarly you can use the wiki menu to upload a media file (for example an image) linked to the page. The "manage media" page will show all the files you have uploaded and will also show the proper expression to link the media file. If, for example you upload a file named "test.jpg" with title "beach", the link expression will be something like:

``
\@////15/beach.jpg
``:code

``\@////`` is the same prefix described before. ``15`` is the id of the record storing the media file. ``beach`` is the title. ``.jpg`` is the extension of the original file.

If you cut and paste ``\@////15/beach.jpg`` into wiki pages you embed the image.

Mind that media files are linked to pages and inherit access permission from the pages.

#### Wiki menus

If you create a page with slug "wiki-menu" page it will be interpreted as a description of the menu. Here is an example:

``
- Home > \@////index
- Info > \@////info
- web2py > http://www.web2py.com
- - About us > \@////aboutus
- - Contact us > \@////contactus
``

Each line a menu item. We used double dash for nested menu items. The ``>`` symbols separates the menu item title from the menu item link.

Mind that the menu is appended to ``response.menu``. It does not replace it. The ``[wiki]`` menu item with service functions is added automatically.

#### Service functions

If, for example, you want to use the wiki to create an editable sidebar you could create a page with ``slug="sidebar"`` and then embed it in your layout.html with

``
{{=auth.wiki(slug='sidebar')}}
``:code

Notice that there is nothing special with the word "sidebar". Any wiki page can be retrieved and embedded at any point in your code. This allows you mix and match wiki functionalities with regular web2py functionalities.

------
Also note that ``auth.wiki('sidebar')``:code is the same as ``auth.wiki(slug='sidebar')``:code, since the slug kwarg is the first in the method signature. The former gives a slightly simpler syntax.
------


You can also embed special wiki functions such as the search by tags:

``
{{=auth.wiki('_search')}}
``:code

or the tag cloud:

``
{{=auth.wiki('_cloud')}}
``:code


#### Extending the auth.wiki feature

When your wiki-enabled app gets more complicated, perhaps you might need to customize the wiki db records managed by the Auth interface or expose customized forms for wiki CRUD tasks. For example, you might want to customize a wiki table record representation or add a new field validator. This is not allowed by default, since the wiki model is defined only after the wiki interface is requested with the auth.wiki() method. To allow access to the wiki specific db setup within the model of your app you must add the following sentence to your model file (i.e. db.py)

``
# Make sure this is called after the auth instance is created
# and before any change to the wiki tables
auth.wiki(resolve=False)
``:code

By using the line above in your model, the wiki tables will be accessible (i.e. ``wiki_page``) for custom CRUD or other db tasks.

------
Note that you still have to call auth.wiki() in the controller or view in order to expose the wiki interface, since the ``resolve=False`` parameter instructs the auth object to just build the wiki model without any other interface setup.
------


Also, by setting resolve to ``False`` in the method call, the wiki tables will be now accessible through the app's default db interface at ``<app>/appadmin`` for managing wiki records.


Another customization possible is adding extra fields to the standard wiki tables (in the same way as with the ``auth_user`` table, as described in Chapter 9). Here is how:

``
# Place this after auth object initialization
auth.settings.extra_fields["wiki_page"] = [Field("ablob", "blob"),]
``:code

The line above adds a ``blob`` field to the ``wiki_page`` table. There is no need to call ``auth.wiki(resolve=False)``:code for this option, unless you need access to the wiki model for other customizations.


#### Components

One of the most powerful functions of the new web2py consists in the ability of embedding an action inside another action. We call this a component.

Consider the following model:

``
db.define_table('thing',Field('name',requires=IS_NOT_EMPTY()))
``:code

and the following action:

``
@auth.requires_login()
def manage_things():
    return SQLFORM.grid(db.thing)
``:code

This action is special because it returns a widget/helper not a dict of objects. Now we can embed this ``manage_things`` action into any view, with

``
{{=LOAD('default','manage_things',ajax=True)}}
``:code

This allows the visitor interact with the component via Ajax without reloading the host page that embeds the widget. The action is called via Ajax, inherits the style of the host page, and captures all form submissions and flash messages so that they are handled within the current page. On top of this the ``SQLFORM.grid`` widget uses digitally signed URLs to restrict access. More information about components can be found in chapter 13.

Components like the one above can be embedded into wiki pages using the MARKMIN syntax:

``
@{component:default/manage_things}
``

This simply tells web2py that we want to include the "manage_things" action defined in the "default" controller as an Ajax "component".

---------
Most users will be able to build relatively complex applications simply by using ``auth.wiki`` to create pages and menus and embedded custom components into wiki pages. Wikis can be thought of as a mechanism to allow members of the group to create pages, but they can also be thought of as a way to develop applications in a modular way.
---------

### More on **admin**
``admin``:inxx

The administrative interface provides additional functionality that we briefly review here.

#### Site
``site``:inxx

This page is the main administrative interface of web2py. It lists all installed applications on the left, while on the right side there are some special action forms.

The first of them shows the web2py version and proposes to upgrade it if new versions are available. Of course, before upgrading be sure to have a full working backup!
Then there are two other forms that allow the creation of a new application (simple or by using an online wizard) by specifying its name.

``Instant Press``:inxx ``Movuca``:inxx
The following form allows uploading an existing application from either a local file or a remote URL. When you upload an application, you need to specify a name for it (using different names
allows you to install multiple copies of the same application). You can try, for example, to upload the Movuca Social Networking application app created by Bruno Rocha:

``
https://github.com/rochacbruno/Movuca
``

or Instant Press CMS created by Martin Mulone:

``
http://code.google.com/p/instant-press/
``

or one of the many example applications available at:

``
http://web2py.com/appliances
``

------
Web2py files are packages as ``.w2p`` files. These are tar gzipped files. Web2py uses the ``.w2p`` extension instead of the ``.tgz`` extension to prevent the browser from unzipping on download. They can be uncompressed manually with ``tar zxvf [filename]`` although this is never necessary.
------

[[image @///image/en4100.png center 444px]]

Upon successful upload, web2py displays the MD5 checksum of the uploaded file. You can use it to verify that the file was not corrupted during upload. The InstantPress name will appear in the list of installed applications.

If you run web2py from source and you have ``gitpython`` installed (if necessary, set it up with 'easy_install gitpython'), you can install applications directly from git repositories
using the ``.git`` URL in the upload form. In this case you will also be enabled to use the admin interface to push changes back into the repository, but this is an experimental feature.

For example, you can locally install the application that shows this book on the web2py site with the URL:

``
https://github.com/mdipierro/web2py-book.git
``

------
That repository hosts the current, updated version of this book (which could be different from the stable version you can see on the web site). You are warmly invited to use it for submitting
improvements, fixes and corrections in the form of pull requests.
------
  
For each application installed you can use the ''site'' page to:
- Go directly to the application by clicking on its name.
- Uninstall the application.
- Jump to the ''about'' page (read below).
- Jump to the ''edit'' page (read below).
- Jump to the ''errors'' page (read below).
- Clean up temporary files (sessions, errors, and cache.disk files).
- Pack all. This returns a tar file containing a complete copy of the application. We suggest that you clean up temporary files before packing an application.
- Compile the application. If there are no errors, this option will bytecode-compiles all models, controllers and views. Because views can extend and include other views in a tree, before bytecode compilation, the view tree for every controller is collapsed into a single file. The net effect is that a bytecode-compiled application is faster, because there is no more parsing of templates or string substitutions occurring at runtime.
- Pack compiled. This option is only present for bytecode-compiled applications. It allows packing the application without source code for distribution as closed source. Note that Python (as any other programming language) can technically be decompiled; therefore compilation does not provide complete protection of the source code. Nevertheless, de-compilation can be difficult and can be illegal.
- Remove compiled. It simply removes the byte-code compiled models, views and controllers from the application. If the application was packaged with source code or edited locally, there is no harm in removing the bytecode-compiled files, and the application will continue to work. If the application was installed form a packed compiled file, then this is not safe, because there is no source code to revert to, and the application will no longer work.

``admin.py``:inxx

-------
All the functionality available from the web2py admin site page is also accessible programmatically via the API defined in the module ``gluon/admin.py``. Simply open a python shell and import this module.
-------

If the Google App Engine SDK is installed the admin ''site'' page shows a button to push your applications to GAE. If ``python-git`` is installed, there is also a button to push your application to Open Shift. To install applications on ``Heroku`` or other hosting system you should look into the "scripts" folder for the appropriate script.

#### About
``about``:inxx ``license``:inxx

The ''about'' tab allows editing the description of the application and its license. These are written respectively in the ABOUT and LICENSE files in the application folder.

[[image @///image/en4300.png center 480px]]

You can use ``MARKMIN``, or ``gluon.contrib.markdown.WIKI`` syntax for these files as described in ref.``markdown2``:cite .

#### Design
``EDIT``:inxx
You have used the ''edit'' page already in this chapter. Here we want to point out a few more functionalities of the ''edit'' page.
- If you click on any file name, you can see the contents of the file with syntax highlighting.
- If you click on edit, you can edit the file via a web interface.
- If you click on delete, you can delete the file (permanently).
- If you click on test, web2py will run tests. Tests are written by the developer using Python doctests, and each function should have its own tests.
- You can add language files, scan the app to discover all strings, and edit string translations via the web interface.
- If the static files are organized in folders and subfolders, the folder hierarchy can be toggled by clicking on a folder name.

The image below shows the output of the test page for the welcome application.

[[image @///image/en4400.png center 480px]]

The image below show the languages tab for the welcome application.

[[image @///image/en4500.png center 480px]]

The image below shows how to edit a language file, in this case the "it" (Italian) language for the welcome application.

[[image @///image/en4600.png center 480px]]

#### Integrated web-based debugger

''(requires Python 2.6 or later)''

The web2py admin includes a web-based debugger.
``debugger``:inxx
Using the provided web-based editor you can add breakpoints to the Python code and, from the associated debugger console, you can inspect the system variables at those breakpoints and resume execution. This is illustrated in the following screenshot:
The interactive console also serves as a python scratchpad.

[[image @///image/debugger.png center 480px]]

This functionality is based on the Qdb debugger created by Mariano Reingart.
It uses multiprocessing.connection to communicate between the backend
and frontend, with a JSON-RPC-like stream protocol. ``qdb``:cite

##### Setting breakpoints via code
``breakpoints``:inxx
Include this:
``
from gluon.debug import dbg
``:code

and to drop into the debugger, put this in the desired location:
``
dbg.set_trace() 
``:code

The debugger app has a breakpoint manager.

``Notes:
web2py does not know whether you actually have a debug window open in your browser; execution suspends regardless.

IDEs usually have their own inter-process debugger, e.g. PyCharm or PyDev. They may complain if you include the gluon library.
``


#### Web-based Python shell

If you click on the "shell" link under the controllers tab in ''edit'', web2py will open a web based Python shell and will execute the models for the current application. This allows you to interactively talk to your application.

[[image @///image/en4700.png center 480px]]

-------
Be careful using the web based shell - because different shell requests will be executed in different threads. This easily gives errors, especially if you play with databases
creation and connections. For activities like these (i.e. if you need persistence) it's much better to use the python command line.
-------
#### Crontab

Also under the controllers tab in ''edit'' there is a "crontab" link. By clicking on this link you will be able to edit the web2py crontab file. This follows the same syntax as the Unix crontab but does not rely on Unix. In fact, it only requires web2py, and it works on Windows. It allows you to register actions that need to be executed in background at scheduled times.
For more information about this, see the next chapter.

#### Errors
``errors``:inxx

When programming web2py, you will inevitably make mistakes and introduce bugs. web2py helps in two ways: 1) it allows you to create tests for every function that can be run in the browser from the ''edit'' page; and 2) when an error manifests itself, a ticket is issued to the visitor and the error is logged.

Intentionally introduce an error in the images application as shown below:
``
def index():
    images = db().select(db.image.ALL,orderby=db.image.title)
    1/0
    return dict(images=images)
``:code

When you access the index action, you get the following ticket:

[[image @///image/en4800.png center 480px]]

Only the administrator can access the ticket:

[[image @///image/en4900.png center 480px]]

The ticket shows the traceback, and the content of the file that caused the problem, and the complete state of system (variables, request, session, etc.) If the error occurs in a view, web2py shows the view converted from HTML into Python code. This allows to easily identify the logical structure of the file.

By default tickets are stored on filesystem and displayed grouped by traceback. The administrative interface provides an aggregate views (type of traceback and number of occurrence) and a detailed view (all tickets are listed by ticket id). The administrator can switch between the two views.

Notice that everywhere **admin** shows syntax-highlighted code (for example, in error reports, web2py keywords are shown in orange). If you click on a web2py keyword, you are redirected to a documentation page about the keyword.

If you fix the divide-by-zero bug in the index action and introduce one in the index view:
``
{{extend 'layout.html'}}

<h1>Current Images</h1>
<ul>
{{for image in images:}}
{{1/0}}
{{=LI(A(image.title, _href=URL("show", args=image.id)))}}
{{pass}}
</ul>
``:code

you get the following ticket:

[[image @///image/en5000.png center 480px]]

Note that web2py has converted the view from HTML into a Python file, and the error described in the ticket refers to the generated Python code and NOT to the original view file:

[[image @///image/en5100.png center 480px]]

This may seem confusing at first, but in practice it makes debugging easier, because the Python indentation highlights the logical structure of the code that you embedded in the views.

The code is shown at the bottom of the same page.

All tickets are listed under admin in the ''errors'' page for each application:

[[image @///image/en5200.png center 480px]]

#### Mercurial
``Mercurial``:inxx

If you are running from source, the administrative interface shows one more menu item called "Versioning". 

[[images @///image/en5300.png center 480px]]

Entering a comment and pressing the "commit" button in the resulting page will commit the current application. With the first commit, a local Mercurial repository for the specific 
application will be created. 
Under the hood, Mercurial stores information about changes you make in your code into a hidden folder ".hg" in your app subfolder. Every app has its own ".hg" folder and its own ".hgignore" file (tells Mercurial which files to ignore).
In order to use this feature, you must have the Mercurial version control libraries installed (at least version 1.9):


``
easy_install mercurial
``:code

The Mercurial web interface does allow you to browse previous commit and diff files but we do recommend you use Mercurial directly from the shell or one of the many GUI-based Mercurial clients since they are more powerful. For example they will allow you to sync your app with a remote source repository.



You can read more about Mercurial here:
``
http://mercurial.selenic.com/
``

#### Git integration
``git``:inxx
The admin app also includes git integration. Python git libraries are required, e.g.
``
pip install gitpython
``:code

and then per application, you must clone or otherwise configure a git repository.

After these steps, the Manage menu for each git-managed application will show git push and git pull.
Applications which are not managed by git are ignored.
You can pull and push apps from the default remote repository. 


#### Application Wizard (experimental)

The **admin** interface includes a Wizard that can help you create a new applications.
You can access the wizard from the "sites" page as shown in the image below.

[[image @///image/en5400.png center 480px]]

The wizard will guide you through a series of steps involved in creating a new application:

- Chose a name for the application
- Configure the application and choose required plugins
- Build required models (it will create CRUD pages for each model)
- Allow you to edit the views of those pages using MARKMIN syntax

The image below shows the second step of the process.

[[image @///image/en5500.png center 480px]]

You can see a dropdown to select a layout plugin (from ``web2py.com/layouts``), a multiple choice dropdown to check other plugins (from ``web2py.com/plugins``) and a "login config" field where to put the Janrain "domain:key".

The other steps are pretty much self-explanatory.

The Wizard works well for what it does but it is considered an ''experimental feature'' for two reasons:

- Applications created with the wizard and edited manually, cannot later be modified by the wizard.
- The interface of the wizard will change over time to include support for more features and easier visual development.

In any case the wizard is a handy tool for fast prototyping and it can be used to bootstrap a new application with an alternate layout and optional plugins.

#### Configuring **admin**

Normally there is no need to perform any configuration of **admin** but a few customizations are possible. After you login into admin you can edit the admin configuration file via the URL:
``
http://127.0.0.1:8000/admin/default/edit/admin/models/0.py
``
Notice that **admin** can be used to edit itself. In fact **admin** is an app as any other one.

The file "0.py" is more or less self documented, anyway, here are some of the most important possible customizations:

``
GAE_APPCFG = os.path.abspath(os.path.join('/usr/local/bin/appcfg.py'))
``
This should point to the location of the "appcfg.py" file that comes with the Google App Engine SDK. If you have the SDK you may want to change these config parameters to the correct value. It will allow you to deploy to GAE from the admin interface.

``DEMO_MODE``:inxx

You can also set web2py admin in demo mode:
``
DEMO_MODE = True
FILTER_APPS = ['welcome']
``
And only the apps listed in FILTER_APPS will be accessible and they will be only accessible in read-only mode.

``MULTI_USER_MODE``:inxx
``virtual laboratory``:inxx

If you are a teacher and want to expose the administrative interface to students so that students can share one administrative interface for their projects (think of a virtual lab), can do it by setting:
``
MULTI_USER_MODE = True
``
In this way students will be required to login and will only be able to access their own apps via admin. You, as first user/teacher, will be able to access them all.

In multi user mode, you can register students using the "bulk register" link in admin and manage them using the "manage students" link. The system also keeps track of when students login and how many lines of code they add/remove to/from their code. This data is presented to the administrator as charts under the application "about" page.

Mind that this mechanism still assumes all users are trusted. All the apps created under admin run under the same credentials on the same filesystem. It is possible for an app created by a student to access the data and the source of an app created by another student. It is also possible for a student to create an app that locks the server.

#### Mobile **admin**

Notice that the admin application includes "plugin_jqmobile" which packages jQuery Mobile. When admin is accessed from a mobile device, this is detected by web2py and the interface is displayed using a mobile-friendly layout:

[[image @///image/mobile.png center 306px]]

### More on **appadmin**

``appadmin``:inxx

**appadmin** is not intended to be exposed to the public. It is designed to help you by providing an easy access to the database. It consists of only two files: a controller "appadmin.py" and a view "appadmin.html" which are used by all actions in the controller.

The **appadmin** controller is relatively small and readable; it provides an example of designing a database interface.

**appadmin** shows which databases are available and which tables exist in each database. You can insert records and list all records for each table individually. **appadmin** paginates output 100 records at a time.

Once a set of records is selected, the header of the pages changes, allowing you to update or delete the selected records.

To update the records, enter an SQL assignment in the Query string field:
``
title = 'test'
``:code

where string values must be enclosed in single quotes. Multiple fields can be separated by commas.

To delete a record, click the corresponding checkbox to confirm that you are sure.

**appadmin** can also perform joins if the SQL FILTER contains a SQL condition that involves two or more tables. For example, try:
``
db.image.id == db.post.image_id
``:code

web2py passes this along to the DAL, and it understands that the query links two tables; hence, both tables are selected with an INNER JOIN. Here is the output:

[[image @///image/en5600.png center 480px]]

If you click on the number of an id field, you get an edit page for the record with the corresponding id.

If you click on the number of a reference field, you get an edit page for the referenced record.

You cannot update or delete rows selected by a join, because they involve records from multiple tables and this would be ambiguous.

In addition to its database administration capabilities, **appadmin** also enables you to view details about the contents of the application's ``cache`` (at ``/yourapp/appadmin/cache``) as well as the contents of the current ``request``, ``response``, and ``session`` objects (at ``/yourapp/appadmin/state``).

**appadmin** replaces ``response.menu`` with its own menu, which provides links to the application's **edit** page in **admin**, the **db** (database administration) page, the **state** page, and the **cache** page. If your application's layout does not generate a menu using ``response.menu``, then you will not see the **appadmin** menu. In that case, you can modify the appadmin.html file and add ``{{=MENU(response.menu)}}`` to display the menu.
