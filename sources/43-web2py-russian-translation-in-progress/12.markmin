# Компоненты и плагины
``component``:inxx
``plugin``:inxx

Компоненты и плагины являются относительно новыми особенностями web2py, и есть некоторые разногласия между разработчиками о том, что они из себя представляют и какими они должны быть. Большая часть путаницы проистекает из различных способов использования этих терминов в других программных проектах и из того, что разработчики все еще работают над завершением спецификации.

Тем не менее, поддержка плагинов является важной особенностью, и нам необходимо предоставить некоторые определения. Эти определения не являются окончательными, а просто соответствуют шаблонам программирования, которые мы хотим обсудить в этой главе.

Мы постараемся решить две проблемы здесь:

- Как мы построить модульные приложения, которые минимизируют нагрузку на сервер с максимальным повторным использованием кода?
- Как распространять куски кода в более или менее манере "установил плагин и играй"?

''Компоненты'' это решения первой проблемы; ''плагины'' это решения второй.

## Компоненты, LOAD и Ajax

``load``:inxx
``LOAD``:inxx
``Ajax``:inxx

------
**Компонент** является функционально-автономной частью веб-страницы.
------

Компонент может состоять из модулей, контроллеров и представлений, но нет строгого требования, за исключением, когда встроенный в веб-страницы компонент должен быть локализован внутри HTML тега (например DIV, SPAN, или IFRAME) и он должен выполнять свою задачу независимо от остальной части страницы. Мы специально заинтересованы в компонентах, которые загружаются на странице и обмениваются данными с помощью функции контроллера компонента через Ajax.

Примером компонента является "компонент комментарий", который содержится в DIV и показывает комментарии пользователей и публикует форму для добавления нового комментария. Когда форма будет отправлена, она отправляется на сервер через Ajax, список обновляется, и комментарий сохраняется на стороне сервера в базе данных. Содержание DIV обновляется без перезагрузки остальной части страницы.

### Загрузка LOAD
Функция web2py LOAD позволяет с легкостью выполнить загрузку без явного знания JavaScript/Ajax или программирования.

Наша цель состоит в том, чтобы иметь возможность разработки веб-приложений путем сборки компонентов в макетах страниц.

Рассмотрим простое web2py приложение "test", которое расширяет скаффолдинг-приложение по умолчанию с пользовательской моделью в файле "models/db_comments.py":

``
db.define_table('comment_post',
   Field('body','text',label='Your comment'),
   auth.signature)
``:code

одим действием в "controllers/comments.py"

``
@auth.requires_login()
def post():
    return dict(form=SQLFORM(db.comment_post).process(),
                comments=db(db.comment_post).select())
``:code

и соответствующим представлением "views/comments/post.html"

``
{{extend 'layout.html'}}
{{for post in comments:}}
<div class="post">
  On {{=post.created_on}} {{=post.created_by.first_name}}
  says <span class="post_body">{{=post.body}}</span>
</div>
{{pass}}
{{=form}}
``:code

Вы можете получить доступ к нему, как обычно:

``
http://127.0.0.1:8000/test/comments/post
``:code

До сих пор нет ничего особенного в этом действии, но мы можем превратить его в компонент путем определения нового представления с расширением ".load", который не расширяет макет.

Поэтому мы создаем "views/comments/post.load":

``
{{for post in comments:}}
<div class="post">
  On {{=post.created_on}} {{=post.created_by.first_name}}
  says <blockquote class="post_body">{{=post.body}}</blockquote>
</div>
{{pass}}
{{=form}}
``:code

Мы можем получить доступ к нему по URL

``
http://127.0.0.1:8000/test/comments/post.load
``:code

Это компонент, который мы можем встроить в любую другую страницу, просто сделав:

``
{{=LOAD('comments','post.load',ajax=True)}}
``:code

Например, в "controllers/default.py" мы можем отредактировать

``
def index():
    return dict()
``:code

и в соответствующем представлении добавить компонент:

``
{{extend 'layout.html'}}
{{=LOAD('comments','post.load',ajax=True)}}
``:code

При посещении страницы

``
http://127.0.0.1:8000/test/default/index
``:code

покажет нормальное содержание и компонент комментариев:

[[image @///image/en8100.png center 480px]]

Компонент ``{{=LOAD(...)}}`` отображает следующее:

``
<script type="text/javascript"><!--
web2py_component("/test/comment/post.load","c282718984176")
//--></script><div id="c282718984176">loading...</div>
``:code

(фактический сгенерированный код зависит от параметров, переданных функции LOAD).

Функция ``web2py_component(url,id)`` определена в "web2py_ajax.html" и она выполняет все волшебство: она вызывает ``url`` с помощью Ajax и встраивает ответ в DIV с соответствующими ``id``; она улавливает каждую отправку формы в DIV и передает эти формы с помощью Ajax. Целью Ajax всегда является собственно DIV.

#### LOAD подпись

Полная подпись помощника LOAD состоит в следующем:

``
LOAD(c=None, f='index', args=[], vars={},
     extension=None, target=None,
     ajax=False, ajax_trap=False,
     url=None,user_signature=False,
     timeout=None, times=1,
     content='loading...',**attr):
``:code

Здесь:
- первые два аргумента ``c`` и ``f`` являются соответственно контроллером и функцией, которую мы хотим вызвать.
- ``args`` и ``vars`` аргументы и переменные, которые мы хотим передать к функции. Первый является списком, последний является словарем.
- ``extension`` является необязательным расширением. Обратите внимание на то, что расширение также может быть передано как часть функции, как в ``f='index.load'``.
- ``target`` является ``id`` целевого DIV. Если данныей агрумент не был указан, то генерируется случайный целевой ``id``.
- ``ajax`` должен быть установлен в ``True`` если DIV должен быть заполнен с помощью Ajax и ``False`` если DIV должен быть заполнен перед возвратом текущей страницы (что позволит избежать вызова Ajax). Если установить в ``False``, то код компонента и представления будет выполнен в той же самой web2py среде, что и вызывающий объект.
- ``ajax_trap=True`` означает, что любая форма представления в DIV должна быть перехвачена и отправлена через Ajax, а ответ должен быть отображен внутри DIV. ``ajax_trap=False`` указывает на то, что формы должны быть направлены нормально с перезагрузкой всей страницы. ``ajax_trap`` игнорируется и считается равным ``True`` если ``ajax=True``.
- ``url``, если он указан, отменяет значения ``c``, ``f``, ``args``, ``vars`` и ``extension`` и загружает компонент указанному по``url``. Он используется для загрузки в качестве компонентов страниц, подаваемых другими приложениями (которые могут или не могут быть созданы с web2py). Обратите внимание, что использование ``url`` подразумевает ``ajax`` всегда равным ``True``, потому что web2py не может знать заранее находится ли компонент в пределах web2py или это просто внешняя страница.
- ``user_signature`` по умолчанию используется значение False, но если вы вошли в систему, то он должен быть установлен в значение True. Это позволит убедиться, что обратный вызов Ajax имеет цифровую подпись. Это описано в главе 4.
- ``times`` определяет, сколько раз компонент должен быть запрошен. Использование "infinity" поддерживает беспрерывную загрузку компонента. Эта опция полезна при переключении регулярного распорядка для запроса данного документа.
- ``timeout`` устанавливает время ожидания в миллисекундах перед началом запроса или частоту если ``times`` больше 1.
- ``content`` представляет собой содержание, которое будет отображаться во время выполнения вызова Ajax. Это может быть помощником, как в ``content=IMG(..)``.
- необязательный ``**attr`` (атрибуты) могут быть переданы во вложенный ``DIV``.

Если не указано представление с ``.load``, то существует ``generic.load``, которое отображает словарь, возвращенный действием без макета. Это работает лучше всего, если словарь содержит один элемент.

Если ваш компонент LOAD имеет расширение ``.load`` и соответствующая функция контроллера перенаправляет к другому действию (например, форму входа), то расширение ``.load``  распространяется и на новый URL-адрес (и на другие перенаправления тоже), который также загружаются с расширением ``.load``.

#### Redirect from a component
To redirect from a component, use this:
``
redirect(URL(...),client_side=True)
``:code
but note that the redirected URL will default to the extension of the component. See notes about the argument ``extension`` in [[the URL function in Chapter 4 ../04#URL]]

#### Reload page via redirect after component submission
If you call an action via Ajax and you want the action to force a redirect of the parent page you can do it with a redirect from the LOADed controller function. 
If you want to reload the parent page, you can redirect to it. The parent URL is known (see [[Client-Server component communications #client_server_coms]] )

so after processing the form submit, the controller function reloads the parent page via redirect:
``
if form.process().accepted: 
    ...
    redirect( request.env.http_web2py_component_location,client_side=True)
``:code

Note that the section below, [[Client-Server component communications #client_server_coms]], describes how the component can return javascript, which could be used for more sophisticated actions when the component is submitted. The specific case of reloading another component is described next.


#### Reload another component 
If you use multiple components on a page, you may want the submission of one component to reload another.
You do this by getting the submitted component to return some javascript.

It's possible to hard-code the target DIV, but in this recipe we use a query-string variable to inform the submitting-controller which component we want to reload. It's identified by the id of the DIV containing the target component. In this case, the DIV has id 'map'. Note that it is necessary to use ``target='map'`` in the LOAD of the target; without this, the target id is randomised and reload() won't work. See LOAD signature above.

In the view, do this:
``
{{=LOAD('default','submitting_component.load',ajax=True,vars={'reload_div':'map'})}}

``:code

The controller belonging to the submitting component needs to send javascript back, so just add this to the existing controller code when processing the submit:
``
if form.process().accepted:
...
    if request.vars.reload_div:
        response.js =  "jQuery('#%s').get(0).reload()" % request.vars.reload_div
``:code

(Of course, remove the redirect if you were using the approach of the previous section.)
 
That's it. web2py's javascript libraries look after the reload. This could be generalised to handle multiple components with javascript looking like:
``
jQuery('#div1,#div2,#div3').get(0).reload()
``:code

For more information about response.js see [[Client-Server component communications #client_server_coms]] (below).

#### Ajax post does not support multipart forms

Because Ajax post does not support multipart forms, i.e. file uploads, upload fields will not work with the LOAD component. You could be fooled into thinking it would work because upload fields will function normally if POST is done from the individual component's .load view. Instead, uploads are done with ajax-compatible 3rd-party widgets and web2py manual upload store commands.

[[client_server_coms]]
### LOAD and Client-Server component communications 

When the action of a component is called via Ajax, web2py passes two HTTP headers with the request:

``
web2py-component-location
web2py-component-element
``:code

which can be accessed by the action via the variables:

``
request.env.http_web2py_component_location
request.env.http_web2py_component_element
``:code

The latter is also accessible via: ``request.cid``:inxx

``
request.cid
``:code

The former contains the URL of the page that called the component action.
The latter contains the ``id`` of the DIV that will contain the response.

The component action can also store data in two special HTTP response headers that will be interpreted by the full page upon response. They are:

``
web2py-component-flash
web2py-component-command
``:code

and they can be set via:

``
response.headers['web2py-component-flash']='....'
response.headers['web2py-component-command']='...'
``:code

or (if the action is called by a component) automatically via:

``
response.flash='...'
response.js='...'
``:code

The former contains text that you want to be flashed upon response.
The latter contains JavaScript code that you want to be executed upon response. It cannot contain newlines.

As an example, let's define a contact form component in "controllers/contact/ask.py" that allows the user to ask a question. The component will email the question to the system administrator, flash a "thank you" message, and remove the component from the page:

``
def ask():
    form=SQLFORM.factory(
        Field('your_email',requires=IS_EMAIL()),
        Field('question',requires=IS_NOT_EMPTY()))
    if form.process().accepted:
        if mail.send(to='admin@example.com',
                  subject='from %s' % form.vars.your_email,
                  message = form.vars.question):
            response.flash = 'Thank you'
            response.js = "jQuery('#%s').hide()" % request.cid
        else:
            form.errors.your_email = "Unable to send the email"
    return dict(form=form)
``:code

The first four lines define the form and accept it. The mail object used for sending is defined in the default scaffolding application. The last four lines implement all the component-specific logic by getting data from the HTTP request headers and setting the HTTP response headers.

Now you can embed this contact form in any page via

``
{{=LOAD('contact','ask.load',ajax=True)}}
``:code

Notice that we did not define a ``.load`` view for our ``ask`` component. We do not have to because it returns a single object (form) and therefore the "generic.load" will do just fine. Remember that generic views are a development tool. In production you should copy "views/generic.load" into "views/contact/ask.load".

``user_signature``:inxx ``requires_signature``:inxx
We can block access to a function called via Ajax by digitally signing the URL using the ``user_signature`` argument:

``
{{=LOAD('contact','ask.load',ajax=True,user_signature=True)}}
``:code

which add a digital signature to the URL.
The digital signature must then be validated using a decorator in the callback function:

``
@auth.requires_signature()
def ask(): ...
``:code


[[trapped_ajax_links]]
#### Trapped Ajax links and the A Helper
``A``:inxx
``Ajax links``:inxx

Normally a link is not trapped, and by clicking in a link inside a component, the entire linked page is loaded. Sometimes you want the linked page to be loaded inside the component. This can be achieved using the ``A`` helper:

``
{{=A('linked page',_href='http://example.com',cid=request.cid)}}
``:code

If ``cid`` is specified, the linked page is loaded via Ajax.
The ``cid`` is the ``id`` of the html element where to place the loaded page content.
In this case we set it to ``request.cid``, i.e. the ``id`` of the component that generates the link. The linked page can be and usually is an internal URL generated using the [[URL helper ../04#URL]] .

## Plugins

-------
A **plugin** is any subset of the files of an application.
-------

and we really mean ''any'':

- A plugin is not a module, is not a model, it is not a controller, is not a view, yet it may contain modules, models, controllers and/or views.
- A plugin does not need to be functionally autonomous and it may depend on other plugins or specific user code.
- A ''plugin'' is not a ''plugins system'' and therefore has no concept of registration nor isolation, although we will give rules to try to achieve some isolation.
- We are talking about a plugin for your app, not a plugin for web2py.

So why is it called a ''plugin''? Because it provides a mechanism for packing a subset of an app and unpacking it over another app (i.e. ''plug-in''). Under this definition, any file in your app can be treated as a plugin.

When the app is distributed, its plugins are packed and distributed with it.

In practice, the **admin** provides an interface for packing and unpacking plugins separately from your app. Files and folder of your application that have names with the prefix ``plugin_``''name'' can be packed together into a file called:

``web2py.plugin.``''name''``.w2p``

and distributed together.

[[image @///image/en8200.png center 480px]]

Any file can be made part of a plugin and these files are not treated by web2py any differently than other files. Except that files and folder in that have a ``plugin_`` prefix are recognized by **admin** and grouper together by **admin** according to their postfix name. **admin** treats them differently, not web2py.

[[image @///image/en8300.png center 480px]]

In practice we will only be concerned with two types of plugins:

- ''Component Plugins''. These are plugins that contain components as defined in the previous section. A component plugin can contain one or more components. We can think for example of a ``plugin_comments`` that contains the ''comments'' component proposed above. Another example could be ``plugin_tagging`` that contains a ''tagging'' component and a ''tag-cloud'' component that share some database tables also defined by the plugin.
- ''Layout Plugins''. These are plugins that contain a layout view and the static files required by such layout. When the plugin is applied it gives the app a new look and feel.

By the above definitions, the components created in the previous section, for example "controllers/contact.py", are already plugins. We can move them from one app to another and use the components they define. Yet they are not recognized as such by **admin** because there is nothing that labels them as plugins. So there are two problems we need to solve:

- Name the plugin files using a convention, so that **admin** can recognize them as belonging to the same plugin
- If the plugin has model files, establish a convention so that the objects it defines do not pollute the namespace and do not conflict with each other.

Let's assume a plugin is called ''name''. Here are the rules that should be followed:

**Rule 1**:
Plugin models and controllers should be called, respectively

- ``models/plugin_``''name''``.py``
- ``controllers/plugin_``''name''``.py``

and plugin views, modules, static, and private files should be in folders called, respectively:

- ``views/plugin_``''name''``/``
- ``modules/plugin_``''name''``/``
- ``static/plugin_``''name''``/``
- ``private/plugin_``''name''``/``

**Rule 2**:
Plugin models can only define objects with names that start with
- ``plugin_``''name''
- ``Plugin``''Name''
- ``_``

**Rule 3**:
Plugin models can only define session variables with names that start with
- ``session.plugin_``''name''
- ``session.Plugin``''Name''

**Rule 4**:
Plugins should include license and documentation. These should be placed in:
- ``static/plugin_``''name''``/license.html``
- ``static/plugin_``''name''``/about.html``

**Rule 5**:
The plugin can only rely on the existence of the global objects defined in scaffolding "db.py", i.e.

- a database connection called ``db``
- an ``Auth`` instance called ``auth``
- a ``Crud`` instance called ``crud``
- a ``Service`` instance called ``service``

Some plugins may be more sophisticated and have a configuration parameter in case more than one db instance exists.

**Rule 6**:
If a plugin needs configuration parameters, these should be set via a PluginManager as described below.
``PluginManager``:inxx

By following the above rules we can make sure that:
- **admin** recognizes all the ``plugin_``''name'' files and folder as part of a single entity.
- plugins do not interfere with each other.

The rules above do not solve the problem of plugin versions and dependencies. That is beyond our scope.


### Component plugins
``component plugin``:inxx

Component plugins are plugins that define components. Components usually access the database and define with their own models.

Here we turn the previous ``comments`` component into a ``comments_plugin`` by using the same code we wrote before, but following all of the previous rules.

First, we create a model called "models/plugin_comments.py":

``
db.define_table('plugin_comments_comment',
   Field('body','text', label='Your comment'),
   auth.signature)

def plugin_comments():
    return LOAD('plugin_comments','post',ajax=True)
``:code
(notice the last two lines define a function that will simplify the embedding of the plugin)

Second, we define a "controllers/plugin_comments.py"

``
def post():
    if not auth.user:
        return A('login to comment',_href=URL('default','user/login'))
    comment = db.plugin_comments_comment
    return dict(form=SQLFORM(comment).process(),
                comments=db(comment).select())
``:code

Third, we create a view called "views/plugin_comments/post.load":

``
{{for comment in comments:}}
<div class="comment">
  on {{=comment.created_on}} {{=comment.created_by.first_name}}
  says <span class="comment_body">{{=comment.body}}</span>
</div>
{{pass}}
{{=form}}
``:code

Now we can use **admin** to pack the plugin for distribution. Admin will save this plugin as:

``
web2py.plugin.comments.w2p
``:code

We can use the plugin in any view by simply installing the plugin via the **edit** page in **admin** and adding this to our own views

``
{{=plugin_comments()}}
``:code

Of course we can make the plugin more sophisticated by having components that take parameters and configuration options. The more complex the components, the more difficult it becomes to avoid name collisions. The Plugin Manager described below is designed to avoid this problem.

### Plugin manager

The ``PluginManager`` is a class defined in ``gluon.tools``. Before we explain how it works inside, we will explain how to use it.

Here we consider the previous ``plugin_comments`` and we make it better. We want to be able to customize:

``
db.plugin_comments_comment.body.label
``:code

without having to edit the plugin code itself.

Here is how we can do it:

First, rewrite the plugin "models/plugin_comments.py" in this way:

``
def _():
    from gluon.tools import PluginManager
    plugins = PluginManager('comments', body_label='Your comment')

    db.define_table('plugin_comments_comment',
        Field('body','text',label=plugins.comments.body_label),
        auth.signature)
    return lambda: LOAD('plugin_comments','post.load',ajax=True)
plugin_comments = _()
``:code

Notice how all the code except the table definition is encapsulated in a single function called ``_`` so that it does not pollute the global namespace. Also notice how the function creates an instance of a ``PluginManager``.

Now in any other model in your app, for example in "models/db.py", you can configure this plugin as follows:

``
from gluon.tools import PluginManager
plugins = PluginManager()
plugins.comments.body_label = T('Post a comment')
``:code

-----
The ``plugins`` object is already instantiated in the default scaffolding app in "models/db.py"
-----

The PluginManager object is a thread-level singleton Storage object of Storage objects. That means you can instantiate as many as you like within the same application but (whether they have the same name or not) they act as if there were a single PluginManager instance.

In particular each plugin file can make its own PluginManager object and register itself and its default parameters with it:

``
plugins = PluginManager('name', param1='value', param2='value')
``:code

You can override these parameters elsewhere (for example in "models/db.py") with the code:

``
plugins = PluginManager()
plugins.name.param1 = 'other value'
``:code

You can configure multiple plugins in one place.

``
plugins = PluginManager()
plugins.name.param1 = '...'
plugins.name.param2 = '...'
plugins.name1.param3 = '...'
plugins.name2.param4 = '...'
plugins.name3.param5 = '...'
``:code

-----
When the plugin is defined, the PluginManager must take arguments: the plugin name and optional named arguments which are default parameters. However, when the plugins are configured, the PluginManager constructor must take no arguments. The configuration must precede the definition of the plugin (i.e. it must be in a model file that comes first alphabetically).
-----

### Layout plugins
``layout plugin``:inxx

Layout plugins are simpler than component plugins because usually they do not contain code, but only views and static files. Yet you should still follow  good practice:

First, create a folder called "static/plugin_layout_''name''/" (where name is the name of your layout) and place all your static files there.

Second, create a layout file called "views/plugin_layout_''name''/layout.html" that contains your layout and links the images, CSS and JavaScript files in "static/plugin_layout_''name''/"

Third, modify the "views/layout.html" so that it simply reads:

``
{{extend 'plugin_layout_name/layout.html'}}
{{include}}
``:code

The benefit of this design is that users of this plugin can install multiple layouts and choose which one to apply simply by editing "views/layout.html". Moreover, "views/layout.html" will not be packed by **admin** together with the plugin, so there is no risk that the plugin will override the user's code in the previously installed layout.

### Plugin repositories, plugin install via admin

While there is no single repository of web2py plugins you can find many of them at one of the following URLs:

``
http://web2pyslices.com (this is the leading repository and is integrated to the web2py admin application for one-click installs)

http://web2py.com/plugins
http://web2py.com/layouts
``:code

Recent versions of web2py admin allow automatic fetch and install of plugins from web2pyslices. To add a plugin to an app, edit it via the admin application, and choose Download Plugins, currently at the bottom of the screen. 

To publish your own plugins, make an account at web2pyslices.

Here is a screenshot showing some of the auto-installable plugins:

[[image @///image/web2py_slices_plugins.png center 480px]]

