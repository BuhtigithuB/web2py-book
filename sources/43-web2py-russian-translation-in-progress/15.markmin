## Оказание помощи web2py: ошибки, улучшения и документация
web2py приветствует сообщения об ошибках, документации и усовершенствований.

### Группа Google
Главным форумом для обсуждения ошибок и новых функций является:
[[web2py-users https://groups.google.com/forum/#!forum/web2py]]
(URL is ``https://groups.google.com/forum/#!forum/web2py``)

### Подача отчета об ошибке
До января 2015 года выпуски не отслеживались на Google Code, и многие исторические ссылки в группе новостей и в старых документах направят вас туда.
В рамках перехода на GitHub, проект теперь использует выпуски GitHub. Только открытые выпуски были переданы в GitHub. 

Если вы нашли ошибку и обсуждали это в группе, то вы можете предложить подать отчет об ошибке путем создания Issue на GitHub.

Пожалуйста, посетите страницу GitHub проекта и перейдите по ссылке на Issues.

https://github.com/web2py/web2py

(или непосредственно посетите https://github.com/web2py/web2py/issues) .

Как обычно, хорошая отчетность об ошибке означает то, что мы должны знать вашу операционную систему, версию Python и web2py, что должно было произойти, и что получилось вместо этого.
Бонусные баллы при размещении полного примера кода, который указывает на вопрос: немного кода лучше, чем тысяча слов. 


### Отчеты об ошибках безопасности
 ``reporting security bugs``:inxx
При составлении отчетов об ошибках безопасности, будьте осторожны при раскрытии информации, которая может способствовать злонамеренный эксплуатации.
После размещения в группе Google или поднимая проблему в GitHub, вам необходимо связаться с разработчиком для обмена информацией в частном порядке.

## Содействие при написании кода и документировании изменений

### Как управляется код проекта
Базовый код Web2py управляется в git репозитории GitHub. Оригинальная система управления версиями Mercurial ранее находилась на Google Code, но сейчас идет активная разрабатка на GitHub.

#### PyDAL: DAL в настоящее время является независимым проектом
Важной частью web2py является Абстрактный Уровень Базы данных (DAL). В начале 2015 года данный модуль был отделен в отдельный код базы (PyDAL). С точки зрения Git, это суб-модуль основного репозитория.

Использование суб-модуля требует одноразового использования флага ``--recursive`` для git клона, если вы клонировали web2py с нуля.

``    
git clone --recursive https://github.com/web2py/web2py.git
``

Если у вас есть существующий репозиторий, то команды ниже должны быть выполнены, по крайней мере один раз:

``
git submodule update --init --recursive
``

Если у вас есть папка ``gluon/dal``, то вы должны удалить ее:

``
rm -r gluon/dal
``

PyDAL использует отдельный цикл стабильного выпуска к остальной части web2py.
Выпуски PyDAL будут использовать схему наименований по дате, подобную Ubuntu.
Вопросы, связанные с PyDAL должны быть представлены в своем отдельном репозитории.

### GitHub репозитории

Репозитории GitHub:

https://github.com/web2py/web2py

https://github.com/web2py/pydal

web2py имеет две важные версии: текущая стабильная версия и снимок разработки. В git снимок разработки обычно называют как "master", но в проекте web2py обычно говорят "Ствол" ("trunk"), который является эквивалентным термином от Mercurial и SVN. Обратите внимание, что термин "ствол" прекрасно подходит для использования на производстве, но это не является гарантией. Пожалуйста, используйте маркированные релизы, если вам нужна стабильная база кода. 

Исправления ошибок и улучшения идут в ствол, поэтому вам нужно будет использовать ствол для быстрого исправления ошибки.
Лучший способ это клонировать репозиторий git. Это первый шаг при использовании кода, хранящегося и хорошо задокументированного на GitHub. Поскольку релизы помечаются, вы можете переключаться между ответвлением ствола (который 'master') и текущим релизом (или любым другим релизом). Это делает использование git-репозитория очень практичным, даже в производстве.

Вам понадобятся следующие навыки работы с git:

+ клонирование репозитория, размещенного на GitHub
+ извлечение наружу ветки(branch) мастера
+ проверка внешней ветки, основанной на метке

Они хорошо охватываются в руководстве по GitHub: смотрите ниже.

### Обсуждение предлагаемых изменений
Если изменение относится к ошибке, то обсуждение по этому вопросу вероятнее всего будет происходить на GitHub (см выше).
Если изменение относится к усовершенствованию, то изначально лучшим местом для обсуждения является группа разработчиков: [[группа разработчиков web2py https://groups.google.com/forum/#!forum/web2py-developers]]
(URL-Адрес ``https://groups.google.com/forum/#!forum/web2py-developers``)

Поскольку web2py обещает обратную совместимость для неэкспериментальных функций, то принятие изменения в код базы является обещанием обслуживать будущих пользователей, и это не то обещание, которое может быть легко выполнено. Менее опытные пользователи в процессе обсуждения могут обнаружить, что существут методы добиться того, чего они хотят; к сожалению, документирование сильных возможностей иногда отстает (см улучшение документации ниже).

Когда вы будете готовы подать изменение кода, то обсуждение изменений вероятнее всего перейдет в комментарии, прикрепленные к Pull Request (обсуждается ниже).

### Стиль написания кода
 ``coding style``:inxx
Как правило, следует придерживаться стилю написания кода PEP8. http://www.python.org/dev/peps/pep-0008/ 

Существуют конкретные указания здесь: [[Стиль web2py ../01#web2py_style]]


##### Стиль документации
стиль документации указывается [[ниже #api_documentation]]

### Советы по настройке среды разработки 
Глава 13 содержит некоторые советы по использованию различных интегрированных сред разработки (IDE) с web2py.

### Приготовление: использование GitHub
 ``patches``:inxx
 ``GitHub``:inxx

Так как web2py использует GitHub, то общий поток изменений выглядит следующим образом:

+ Вы создаете клон web2py на GitHub, который GitHub называет "ответвление" ("forking").
+ Вы создаете клон своей web2py 'ветки' ('fork') на локальной машине (или где вы хотите делать изменения)
+ Вы создаете новую ветвь (branch) для ваших изменений
+ Вы работаете над своей новой веткой и фиксируетесь
+ Вы выталкиваете (push) ваши изменения обратно на GitHub ветку (fork) (git выталкивает (push) оригинальное имя новой ветви name_of_new_branch)
+ Вы делаете запрос на вытягивание (pull request) через GitHub
+ Если ваш запрос на вытягивание (pull request) будет принят, то ваша фиксация будет в главной (master) ветви web2py.

На момент написания, основные технические приемы git/GitHub охватываются здесь:
https://help.GitHub.com/articles/fork-a-repo

Тем не менее, вам необходимо следовать нижеприведенным инструкциям по создаванию патчей, которые в дальнейшем могут быть аккуратно объединены.

Обратите внимание: git-репозиторий web2py содержится в качестве подмодуля для DAL.
Это означает, что при первоначальном извлечении следует использовать --recursive для инициализации подмодуля.

### Preparation: using travis with your GitHub fork
 ``travis``:inxx
web2py works with travis, a continuous integration testing service. This means that a commit will trigger all the integrated unit tests. 

You can easily add travis to your own GitHub repository to avoid sending patches which will fail travis testing upstream. 

Follow the instructions here:
http://about.travis-ci.org/docs/user/getting-started/

### The four parts of a good quality enhancement

A high-quality enhancement has four parts:

+ The code change
+ Documentating API changes (see API documentation below)
+ Testing for the new functionality
+ Updating the book (which is also maintained at GitHub)

### Ensuring a clean patch: using the correct git branch technique
 ``git``:inxx

Using git properly is a little more complex in a shared project.  

Here are the specific guidelines to make sure your pull request can be applied cleanly. 

Firstly, make sure you have a remote repository setup which points to the main web2py GitHub repository. Your remote repository should be called upstream. You only need to do this once. 

Adding an upstream repository is covered by the introductory GitHub article linked above, but in case you missed it, you can add upstream like this:

``
git remote add upstream https://github.com/web2py/web2py/
``:code

Next you need to create a branch name for your changes. git encourages lots of branch names, as specific as possible. 
For web2py, we recommend names like this:
- every bug-fixing commit should come from a branch named "issue/number_of_the_issue_on_github" (like issue/1684)
- every enhancement commit should come in a branch named "enhancement/title_of_the_enhancement" (like enhancement/trapped_links)

The trick to ensure sending a clean PR is to start your branch always from the most recent web2py code, which is on the master branch.
If you NEVER work on your repo's master branch, you can keep it in sync with web2py's master, and be sure to "play safe" only in your newly-created branches.
You can keep in sync your master with web2py's with these commands:
``
git checkout master
git fetch upstream
git merge upstream/master
``:code

Now, in your local environment, checkout the branch for your changes (while you're on master)...substitute CHANGE1 for your branch name.
``
git checkout -b CHANGE1
``:code

... Make changes or cherry pick from another local branch. commit if necessary. 
When you are ready to send your local changes to your web2py fork:

``
git push origin CHANGE1
``:code

Now your branch in on GitHub... go the GitHub website, change to the new branch and do a pull request. 
GitHub has a "delete branch" button after your pull request is merged or closed. 
There can be no guarantees, but PRs are usually reviewed within a few days. Most people submitting patches as PRs also update either the issue report or enhancement thread.
Now, remember that if you want to start another PR, you MUST return to the master branch on your repository, re-sync, and create a new branch.
Let's suppose you need to create another branch, named CHANGE2
``
git checkout master
git fetch upstream
git merge upstream/master
# now master is in sync
git checkout -b CHANGE2
...
``:code

When you do several commits on the same "feature" branch, the resulting merge from the Pull Request would include every commit you did on that branch.
In order to keep the "merge tree" clean, you should rebase your PR in order to contain - ideally - only one commit.
In this case, the process of [[rebasing https://help.github.com/articles/about-git-rebase/]] "rewrites" the history retaining the same changes in code, while "collapses" all those changes in a single commit.

To start the rebase process, while in your branch, do something like

``
git rebase --interactive HEAD~10
``:code

This code will bring up the latest 10 commits: what you want to do is changing "pick" to "squash" in every commit you want to "collapse", and keep only one of them

## Adding tests
 ``code tests``:inxx
 ``unit tests``:inxx
Unit tests should be added when an enhancement changes or adds functionality.
Tests are python scripts contained in gluon/tests
Copy the approach of existing tests. You will notice that tests often need to create something such as table, perform a test of the functionality and check the outcome, and then return the state do before the test (which in this case would mean dropping the table).
There is a good reference to testing here:
[[Web2pyslice 1691 http://www.web2pyslices.com/slice/show/1691/help-developers-adding-tests-to-web2py]]

http://www.web2pyslices.com/slice/show/1691/help-developers-adding-tests-to-web2py

### Running tests
You can run all tests:
``python web2py.py --run_system_tests``:code
See the slice referenced above for more information, including running individual tests.

### Example unit test
Writing tests is easy. This is an example from gluon/tests/test_dal.py
You can see how the test extends a TestCase class. Note how a sufficiently complex table is added, the test performed and output validated, and then the database changes are torn down, leaving the campsite as clean as when you arrived.

``
class TestVirtualFields(unittest.TestCase):

    def testRun(self):
        db = DAL(DEFAULT_URI, check_reserved=['all'])
        db.define_table('tt', Field('aa'))
        db.commit()
        db.tt.insert(aa="test")
        class Compute:
            def a_upper(row): return row.tt.aa.upper()
        db.tt.virtualfields.append(Compute())
        assert db(db.tt.id>0).select().first().a_upper == 'TEST'
        db.tt.drop()
        db.commit()
``:code

[[updating_book]]
## Documentation: Updating the book
``Updating book``:inxx

The book is also in GitHub and the same git workflow can be used.
The book source contains sources in various languages, under the sources directory. The content is written in [[markmin ../05#markmin_syntax]] .

A tip: The markmin content of the book uses anchors for links.

To refer to an anchor in another book chapter, write a link like so:
``[[markmin ../05#markmin_syntax]]``:code

The book is a web2py app. You may find it convenient to make a GitHub fork of the book, and clone your local repository in the applications directory of a web2py installation. This makes it easy to see your changes rendered in a browser.

[[web2pyslices]]
## Documentation: web2pyslices.com
``web2pyslices``:inxx

 ``web2pyslices.com``:inxx
web2pyslices.com is a resource for recipes, code snippets and samples. 

[[api_documentation]]
## Documentation: API, in-code and docstring documentation

The web2py API documentation is here: http://web2py.readthedocs.org/en/latest/

It uses sphinx, which means it is generated based on documentation included in the source files.

API (i.e. docstrings) and in-code documentation should follow the [[Google Python Style Guide - Comments http://google-styleguide.googlecode.com/svn/trunk/pyguide.html?showone=Comments#Comments]]

Here is an example from the web2py code-base:

``
def getcfs(key, filename, filter=None):
    """
Caches the *filtered* file `filename` with `key` until the file is
modified.

Args:
key(str): the cache key
filename: the file to cache
filter: is the function used for filtering. Normally `filename` is a
.py file and `filter` is a function that bytecode compiles the file.
In this way the bytecode compiled file is cached. (Default = None)

This is used on Google App Engine since pyc files cannot be saved.
"""
``:code

and an example from Google's style-guide:
``
def fetch_bigtable_rows(big_table, keys, other_silly_variable=None):
    """Fetches rows from a Bigtable.

    Retrieves rows pertaining to the given keys from the Table instance
    represented by big_table.  Silly things may happen if
    other_silly_variable is not None.

    Args:
        big_table: An open Bigtable Table instance.
        keys: A sequence of strings representing the key of each table row
            to fetch.
        other_silly_variable: Another optional variable, that has a much
            longer name than the other args, and which does nothing.

    Returns:
        A dict mapping keys to the corresponding table row data
        fetched. Each row is represented as a tuple of strings. For
        example:

        {'Serak': ('Rigel VII', 'Preparer'),
         'Zim': ('Irk', 'Invader'),
         'Lrrr': ('Omicron Persei 8', 'Emperor')}

        If a key from the keys argument is missing from the dictionary,
        then that row was not found in the table.

    Raises:
        IOError: An error occurred accessing the bigtable.Table object.
    """
    pass
``:code


Some further web2py-specific notes re API documentation via docstrings:

- "experimental" features should be clearly marked
- sphinx was chosen because it's largely supported, maintained AND has the added bonus of readthedocs.org
- new features should be clearly marked (i.e. "starting from 2.4.6...")
- new features should be closely related to the official changelog
- readthedocs.org allows us to build "statically linked" version of the docs for future tagged releases (good for "feature comparison")
- The web2py developers adopt the Google style guide as it offers the best of sphinx without all the hassle of ReST "decorations"
- until sphinx 1.3 is out, sphinx-napoleon is a requirement for building the docs
